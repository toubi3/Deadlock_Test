
Deadlock_Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003bbe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000050  00802000  00003bbe  00003c52  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000c85  00802050  00802050  00003ca2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003ca2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003cd4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000758  00000000  00000000  00003d14  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000e2e5  00000000  00000000  0000446c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004e2d  00000000  00000000  00012751  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004d51  00000000  00000000  0001757e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001878  00000000  00000000  0001c2d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000056bd  00000000  00000000  0001db48  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000093af  00000000  00000000  00023205  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000808  00000000  00000000  0002c5b4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 1c 01 	jmp	0x238	; 0x238 <__ctors_end>
       4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
       8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
       c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      10:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      14:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      18:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      1c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      20:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      24:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      28:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      2c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      30:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      34:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      38:	0c 94 4e 05 	jmp	0xa9c	; 0xa9c <__vector_14>
      3c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      40:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      44:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      48:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      4c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      50:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      54:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      58:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      5c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      60:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      64:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      68:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      6c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      70:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      74:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      78:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      7c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      80:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      84:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      88:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      8c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      90:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      94:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      98:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      9c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      a0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      a4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      a8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      ac:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      b0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      b4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      b8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      bc:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      c0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      c4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      c8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      cc:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      d0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      d4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      d8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      dc:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      e0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      e4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      e8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      ec:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      f0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      f4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      f8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      fc:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     100:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     104:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     108:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     10c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     110:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     114:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     118:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     11c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     120:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     124:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     128:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     12c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     130:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     134:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     138:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     13c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     140:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     144:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     148:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     14c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     150:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     154:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     158:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     15c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     160:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     164:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     168:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     16c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     170:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     174:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     178:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     17c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     180:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     184:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     188:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     18c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     190:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     194:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     198:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     19c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1a0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1a4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1a8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1ac:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1b0:	0c 94 01 15 	jmp	0x2a02	; 0x2a02 <__vector_108>
     1b4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1b8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1bc:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1c0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1c4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1c8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1cc:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1d0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1d4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1d8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1dc:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1e0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1e4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1e8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1ec:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1f0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1f4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1f8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
     1fc:	bc 12       	cpse	r11, r28
     1fe:	bc 12       	cpse	r11, r28
     200:	bc 12       	cpse	r11, r28
     202:	09 13       	cpse	r16, r25
     204:	f1 12       	cpse	r15, r17
     206:	06 13       	cpse	r16, r22
     208:	bc 12       	cpse	r11, r28
     20a:	bc 12       	cpse	r11, r28
     20c:	09 13       	cpse	r16, r25
     20e:	f1 12       	cpse	r15, r17

00000210 <__trampolines_start>:
     210:	0c 94 bc 12 	jmp	0x2578	; 0x2578 <prvTimerTask+0x178>
     214:	0c 94 39 03 	jmp	0x672	; 0x672 <vEventGroupSetBitsCallback>
     218:	0c 94 27 14 	jmp	0x284e	; 0x284e <vT2>
     21c:	0c 94 09 13 	jmp	0x2612	; 0x2612 <prvTimerTask+0x212>
     220:	0c 94 8d 13 	jmp	0x271a	; 0x271a <vT1>
     224:	0c 94 06 13 	jmp	0x260c	; 0x260c <prvTimerTask+0x20c>
     228:	0c 94 a0 16 	jmp	0x2d40	; 0x2d40 <vDisplayUpdateTask>
     22c:	0c 94 f1 12 	jmp	0x25e2	; 0x25e2 <prvTimerTask+0x1e2>
     230:	0c 94 00 12 	jmp	0x2400	; 0x2400 <prvTimerTask>
     234:	0c 94 7b 0a 	jmp	0x14f6	; 0x14f6 <prvIdleTask>

00000238 <__ctors_end>:
     238:	11 24       	eor	r1, r1
     23a:	1f be       	out	0x3f, r1	; 63
     23c:	cf ef       	ldi	r28, 0xFF	; 255
     23e:	cd bf       	out	0x3d, r28	; 61
     240:	df e3       	ldi	r29, 0x3F	; 63
     242:	de bf       	out	0x3e, r29	; 62
     244:	00 e0       	ldi	r16, 0x00	; 0
     246:	0c bf       	out	0x3c, r16	; 60

00000248 <init_mem>:
// !!! Never call this function, it is part of .init-Code
void __attribute__ ((naked, section(".init3"))) init_mem (void);
void init_mem (void)
{
   //  Use inline assembler so it works even with optimization turned off
   __asm volatile (
     248:	e5 ed       	ldi	r30, 0xD5	; 213
     24a:	fc e2       	ldi	r31, 0x2C	; 44
     24c:	8a ea       	ldi	r24, 0xAA	; 170
     24e:	90 e4       	ldi	r25, 0x40	; 64
     250:	81 93       	st	Z+, r24
     252:	e0 30       	cpi	r30, 0x00	; 0
     254:	f9 07       	cpc	r31, r25
     256:	e0 f3       	brcs	.-8      	; 0x250 <init_mem+0x8>

00000258 <__do_copy_data>:
     258:	10 e2       	ldi	r17, 0x20	; 32
     25a:	a0 e0       	ldi	r26, 0x00	; 0
     25c:	b0 e2       	ldi	r27, 0x20	; 32
     25e:	ee eb       	ldi	r30, 0xBE	; 190
     260:	fb e3       	ldi	r31, 0x3B	; 59
     262:	00 e0       	ldi	r16, 0x00	; 0
     264:	0b bf       	out	0x3b, r16	; 59
     266:	02 c0       	rjmp	.+4      	; 0x26c <__do_copy_data+0x14>
     268:	07 90       	elpm	r0, Z+
     26a:	0d 92       	st	X+, r0
     26c:	a0 35       	cpi	r26, 0x50	; 80
     26e:	b1 07       	cpc	r27, r17
     270:	d9 f7       	brne	.-10     	; 0x268 <__do_copy_data+0x10>

00000272 <__do_clear_bss>:
     272:	2c e2       	ldi	r18, 0x2C	; 44
     274:	a0 e5       	ldi	r26, 0x50	; 80
     276:	b0 e2       	ldi	r27, 0x20	; 32
     278:	01 c0       	rjmp	.+2      	; 0x27c <.do_clear_bss_start>

0000027a <.do_clear_bss_loop>:
     27a:	1d 92       	st	X+, r1

0000027c <.do_clear_bss_start>:
     27c:	a5 3d       	cpi	r26, 0xD5	; 213
     27e:	b2 07       	cpc	r27, r18
     280:	e1 f7       	brne	.-8      	; 0x27a <.do_clear_bss_loop>
     282:	0e 94 c6 14 	call	0x298c	; 0x298c <main>
     286:	0c 94 dd 1d 	jmp	0x3bba	; 0x3bba <_exit>

0000028a <__bad_interrupt>:
     28a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000028e <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     28e:	0f 93       	push	r16
     290:	cf 93       	push	r28
     292:	df 93       	push	r29
     294:	1f 92       	push	r1
     296:	cd b7       	in	r28, 0x3d	; 61
     298:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
     29a:	2f b7       	in	r18, 0x3f	; 63
     29c:	29 83       	std	Y+1, r18	; 0x01
     29e:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     2a0:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     2a2:	fc 01       	movw	r30, r24
     2a4:	08 ed       	ldi	r16, 0xD8	; 216
     2a6:	04 bf       	out	0x34, r16	; 52
     2a8:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
     2aa:	89 81       	ldd	r24, Y+1	; 0x01
     2ac:	8f bf       	out	0x3f, r24	; 63
#endif
}
     2ae:	0f 90       	pop	r0
     2b0:	df 91       	pop	r29
     2b2:	cf 91       	pop	r28
     2b4:	0f 91       	pop	r16
     2b6:	08 95       	ret

000002b8 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
     2b8:	61 11       	cpse	r22, r1
     2ba:	02 c0       	rjmp	.+4      	; 0x2c0 <CLKSYS_XOSC_Config+0x8>
     2bc:	90 e0       	ldi	r25, 0x00	; 0
     2be:	01 c0       	rjmp	.+2      	; 0x2c2 <CLKSYS_XOSC_Config+0xa>
     2c0:	90 e2       	ldi	r25, 0x20	; 32
     2c2:	84 2b       	or	r24, r20
     2c4:	89 2b       	or	r24, r25
     2c6:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
     2ca:	08 95       	ret

000002cc <CLKSYS_PLL_Config>:
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
     2cc:	6f 71       	andi	r22, 0x1F	; 31
     2ce:	86 2b       	or	r24, r22
     2d0:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
     2d4:	08 95       	ret

000002d6 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
     2d6:	e0 e5       	ldi	r30, 0x50	; 80
     2d8:	f0 e0       	ldi	r31, 0x00	; 0
     2da:	90 81       	ld	r25, Z
     2dc:	28 2f       	mov	r18, r24
     2de:	20 95       	com	r18
     2e0:	92 23       	and	r25, r18
     2e2:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
     2e4:	90 81       	ld	r25, Z
	return clkEnabled;
}
     2e6:	89 23       	and	r24, r25
     2e8:	08 95       	ret

000002ea <CLKSYS_Prescalers_Config>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
     2ea:	68 2b       	or	r22, r24
     2ec:	81 e4       	ldi	r24, 0x41	; 65
     2ee:	90 e0       	ldi	r25, 0x00	; 0
     2f0:	0e 94 47 01 	call	0x28e	; 0x28e <CCPWrite>
     2f4:	08 95       	ret

000002f6 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
     2f6:	0f 93       	push	r16
     2f8:	1f 93       	push	r17
     2fa:	cf 93       	push	r28
     2fc:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
     2fe:	00 e4       	ldi	r16, 0x40	; 64
     300:	10 e0       	ldi	r17, 0x00	; 0
     302:	f8 01       	movw	r30, r16
     304:	60 81       	ld	r22, Z
	CCPWrite( &CLK.CTRL, clkCtrl );
     306:	68 7f       	andi	r22, 0xF8	; 248
     308:	68 2b       	or	r22, r24
     30a:	80 e4       	ldi	r24, 0x40	; 64
     30c:	90 e0       	ldi	r25, 0x00	; 0
     30e:	0e 94 47 01 	call	0x28e	; 0x28e <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
     312:	f8 01       	movw	r30, r16
     314:	80 81       	ld	r24, Z
	return clkCtrl;
}
     316:	8c 23       	and	r24, r28
     318:	cf 91       	pop	r28
     31a:	1f 91       	pop	r17
     31c:	0f 91       	pop	r16
     31e:	08 95       	ret

00000320 <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
     320:	fc 01       	movw	r30, r24
     322:	90 81       	ld	r25, Z
     324:	90 7f       	andi	r25, 0xF0	; 240
     326:	69 2b       	or	r22, r25
     328:	60 83       	st	Z, r22
     32a:	08 95       	ret

0000032c <TC0_ConfigWGM>:
     32c:	fc 01       	movw	r30, r24
     32e:	91 81       	ldd	r25, Z+1	; 0x01
     330:	98 7f       	andi	r25, 0xF8	; 248
     332:	69 2b       	or	r22, r25
     334:	61 83       	std	Z+1, r22	; 0x01
     336:	08 95       	ret

00000338 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
     338:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
     33a:	96 81       	ldd	r25, Z+6	; 0x06
     33c:	9c 7f       	andi	r25, 0xFC	; 252
     33e:	69 2b       	or	r22, r25
     340:	66 83       	std	Z+6, r22	; 0x06
     342:	08 95       	ret

00000344 <software_reset>:
	 // TODO from here:
	 //
	 // - log the occurance of any error in flash mem (inc counter)
	 // - print a message

	 software_reset();
     344:	00 00       	nop
     346:	88 ed       	ldi	r24, 0xD8	; 216
     348:	84 bf       	out	0x34, r24	; 52
     34a:	81 e0       	ldi	r24, 0x01	; 1
     34c:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     350:	08 95       	ret

00000352 <vApplicationStackOverflowHook>:
     352:	0e 94 a2 01 	call	0x344	; 0x344 <software_reset>
     356:	08 95       	ret

00000358 <xEventGroupCreate>:
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
}
     358:	cf 93       	push	r28
     35a:	df 93       	push	r29
     35c:	80 e1       	ldi	r24, 0x10	; 16
     35e:	90 e0       	ldi	r25, 0x00	; 0
     360:	0e 94 49 03 	call	0x692	; 0x692 <pvPortMalloc>
     364:	ec 01       	movw	r28, r24
     366:	00 97       	sbiw	r24, 0x00	; 0
     368:	41 f0       	breq	.+16     	; 0x37a <xEventGroupCreate+0x22>
     36a:	fc 01       	movw	r30, r24
     36c:	11 92       	st	Z+, r1
     36e:	11 92       	st	Z+, r1
     370:	11 92       	st	Z+, r1
     372:	11 92       	st	Z+, r1
     374:	cf 01       	movw	r24, r30
     376:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
     37a:	ce 01       	movw	r24, r28
     37c:	df 91       	pop	r29
     37e:	cf 91       	pop	r28
     380:	08 95       	ret

00000382 <xEventGroupWaitBits>:
     382:	2f 92       	push	r2
     384:	3f 92       	push	r3
     386:	4f 92       	push	r4
     388:	5f 92       	push	r5
     38a:	6f 92       	push	r6
     38c:	7f 92       	push	r7
     38e:	8f 92       	push	r8
     390:	9f 92       	push	r9
     392:	af 92       	push	r10
     394:	bf 92       	push	r11
     396:	cf 92       	push	r12
     398:	df 92       	push	r13
     39a:	ef 92       	push	r14
     39c:	ff 92       	push	r15
     39e:	0f 93       	push	r16
     3a0:	1f 93       	push	r17
     3a2:	cf 93       	push	r28
     3a4:	df 93       	push	r29
     3a6:	ec 01       	movw	r28, r24
     3a8:	4a 01       	movw	r8, r20
     3aa:	5b 01       	movw	r10, r22
     3ac:	62 2e       	mov	r6, r18
     3ae:	70 2e       	mov	r7, r16
     3b0:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <vTaskSuspendAll>
     3b4:	28 80       	ld	r2, Y
     3b6:	39 80       	ldd	r3, Y+1	; 0x01
     3b8:	4a 80       	ldd	r4, Y+2	; 0x02
     3ba:	5b 80       	ldd	r5, Y+3	; 0x03
     3bc:	01 11       	cpse	r16, r1
     3be:	0d c0       	rjmp	.+26     	; 0x3da <xEventGroupWaitBits+0x58>
     3c0:	81 e0       	ldi	r24, 0x01	; 1
     3c2:	b2 01       	movw	r22, r4
     3c4:	a1 01       	movw	r20, r2
     3c6:	48 21       	and	r20, r8
     3c8:	59 21       	and	r21, r9
     3ca:	6a 21       	and	r22, r10
     3cc:	7b 21       	and	r23, r11
     3ce:	45 2b       	or	r20, r21
     3d0:	46 2b       	or	r20, r22
     3d2:	47 2b       	or	r20, r23
     3d4:	79 f4       	brne	.+30     	; 0x3f4 <xEventGroupWaitBits+0x72>
     3d6:	80 e0       	ldi	r24, 0x00	; 0
     3d8:	0d c0       	rjmp	.+26     	; 0x3f4 <xEventGroupWaitBits+0x72>
     3da:	81 e0       	ldi	r24, 0x01	; 1
     3dc:	b2 01       	movw	r22, r4
     3de:	a1 01       	movw	r20, r2
     3e0:	48 21       	and	r20, r8
     3e2:	59 21       	and	r21, r9
     3e4:	6a 21       	and	r22, r10
     3e6:	7b 21       	and	r23, r11
     3e8:	48 15       	cp	r20, r8
     3ea:	59 05       	cpc	r21, r9
     3ec:	6a 05       	cpc	r22, r10
     3ee:	7b 05       	cpc	r23, r11
     3f0:	09 f0       	breq	.+2      	; 0x3f4 <xEventGroupWaitBits+0x72>
     3f2:	80 e0       	ldi	r24, 0x00	; 0
     3f4:	88 23       	and	r24, r24
     3f6:	81 f0       	breq	.+32     	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
     3f8:	66 20       	and	r6, r6
     3fa:	09 f4       	brne	.+2      	; 0x3fe <xEventGroupWaitBits+0x7c>
     3fc:	70 c0       	rjmp	.+224    	; 0x4de <__LOCK_REGION_LENGTH__+0xde>
     3fe:	80 94       	com	r8
     400:	90 94       	com	r9
     402:	a0 94       	com	r10
     404:	b0 94       	com	r11
     406:	82 20       	and	r8, r2
     408:	93 20       	and	r9, r3
     40a:	a4 20       	and	r10, r4
     40c:	b5 20       	and	r11, r5
     40e:	88 82       	st	Y, r8
     410:	99 82       	std	Y+1, r9	; 0x01
     412:	aa 82       	std	Y+2, r10	; 0x02
     414:	bb 82       	std	Y+3, r11	; 0x03
     416:	63 c0       	rjmp	.+198    	; 0x4de <__LOCK_REGION_LENGTH__+0xde>
     418:	c1 14       	cp	r12, r1
     41a:	d1 04       	cpc	r13, r1
     41c:	e1 04       	cpc	r14, r1
     41e:	f1 04       	cpc	r15, r1
     420:	09 f4       	brne	.+2      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
     422:	5d c0       	rjmp	.+186    	; 0x4de <__LOCK_REGION_LENGTH__+0xde>
     424:	66 20       	and	r6, r6
     426:	29 f0       	breq	.+10     	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
     428:	40 e0       	ldi	r20, 0x00	; 0
     42a:	50 e0       	ldi	r21, 0x00	; 0
     42c:	60 e0       	ldi	r22, 0x00	; 0
     42e:	71 e0       	ldi	r23, 0x01	; 1
     430:	03 c0       	rjmp	.+6      	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
     432:	40 e0       	ldi	r20, 0x00	; 0
     434:	50 e0       	ldi	r21, 0x00	; 0
     436:	ba 01       	movw	r22, r20
     438:	71 10       	cpse	r7, r1
     43a:	74 60       	ori	r23, 0x04	; 4
     43c:	48 29       	or	r20, r8
     43e:	59 29       	or	r21, r9
     440:	6a 29       	or	r22, r10
     442:	7b 29       	or	r23, r11
     444:	97 01       	movw	r18, r14
     446:	86 01       	movw	r16, r12
     448:	ce 01       	movw	r24, r28
     44a:	04 96       	adiw	r24, 0x04	; 4
     44c:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <vTaskPlaceOnUnorderedEventList>
     450:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
     454:	81 11       	cpse	r24, r1
     456:	02 c0       	rjmp	.+4      	; 0x45c <__LOCK_REGION_LENGTH__+0x5c>
     458:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
     45c:	0e 94 3d 10 	call	0x207a	; 0x207a <uxTaskResetEventItemValue>
     460:	91 fd       	sbrc	r25, 1
     462:	39 c0       	rjmp	.+114    	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
     464:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     468:	ff 93       	push	r31
     46a:	f8 7f       	andi	r31, 0xF8	; 248
     46c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     470:	68 81       	ld	r22, Y
     472:	79 81       	ldd	r23, Y+1	; 0x01
     474:	8a 81       	ldd	r24, Y+2	; 0x02
     476:	9b 81       	ldd	r25, Y+3	; 0x03
     478:	71 10       	cpse	r7, r1
     47a:	0d c0       	rjmp	.+26     	; 0x496 <__LOCK_REGION_LENGTH__+0x96>
     47c:	21 e0       	ldi	r18, 0x01	; 1
     47e:	75 01       	movw	r14, r10
     480:	64 01       	movw	r12, r8
     482:	c6 22       	and	r12, r22
     484:	d7 22       	and	r13, r23
     486:	e8 22       	and	r14, r24
     488:	f9 22       	and	r15, r25
     48a:	cd 28       	or	r12, r13
     48c:	ce 28       	or	r12, r14
     48e:	cf 28       	or	r12, r15
     490:	79 f4       	brne	.+30     	; 0x4b0 <__LOCK_REGION_LENGTH__+0xb0>
     492:	20 e0       	ldi	r18, 0x00	; 0
     494:	0d c0       	rjmp	.+26     	; 0x4b0 <__LOCK_REGION_LENGTH__+0xb0>
     496:	21 e0       	ldi	r18, 0x01	; 1
     498:	75 01       	movw	r14, r10
     49a:	64 01       	movw	r12, r8
     49c:	c6 22       	and	r12, r22
     49e:	d7 22       	and	r13, r23
     4a0:	e8 22       	and	r14, r24
     4a2:	f9 22       	and	r15, r25
     4a4:	c8 14       	cp	r12, r8
     4a6:	d9 04       	cpc	r13, r9
     4a8:	ea 04       	cpc	r14, r10
     4aa:	fb 04       	cpc	r15, r11
     4ac:	09 f0       	breq	.+2      	; 0x4b0 <__LOCK_REGION_LENGTH__+0xb0>
     4ae:	20 e0       	ldi	r18, 0x00	; 0
     4b0:	22 23       	and	r18, r18
     4b2:	71 f0       	breq	.+28     	; 0x4d0 <__LOCK_REGION_LENGTH__+0xd0>
     4b4:	66 20       	and	r6, r6
     4b6:	61 f0       	breq	.+24     	; 0x4d0 <__LOCK_REGION_LENGTH__+0xd0>
     4b8:	80 94       	com	r8
     4ba:	90 94       	com	r9
     4bc:	a0 94       	com	r10
     4be:	b0 94       	com	r11
     4c0:	86 22       	and	r8, r22
     4c2:	97 22       	and	r9, r23
     4c4:	a8 22       	and	r10, r24
     4c6:	b9 22       	and	r11, r25
     4c8:	88 82       	st	Y, r8
     4ca:	99 82       	std	Y+1, r9	; 0x01
     4cc:	aa 82       	std	Y+2, r10	; 0x02
     4ce:	bb 82       	std	Y+3, r11	; 0x03
     4d0:	ff 91       	pop	r31
     4d2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     4d6:	1b 01       	movw	r2, r22
     4d8:	2c 01       	movw	r4, r24
     4da:	55 24       	eor	r5, r5
     4dc:	02 c0       	rjmp	.+4      	; 0x4e2 <__LOCK_REGION_LENGTH__+0xe2>
     4de:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
     4e2:	c2 01       	movw	r24, r4
     4e4:	b1 01       	movw	r22, r2
     4e6:	df 91       	pop	r29
     4e8:	cf 91       	pop	r28
     4ea:	1f 91       	pop	r17
     4ec:	0f 91       	pop	r16
     4ee:	ff 90       	pop	r15
     4f0:	ef 90       	pop	r14
     4f2:	df 90       	pop	r13
     4f4:	cf 90       	pop	r12
     4f6:	bf 90       	pop	r11
     4f8:	af 90       	pop	r10
     4fa:	9f 90       	pop	r9
     4fc:	8f 90       	pop	r8
     4fe:	7f 90       	pop	r7
     500:	6f 90       	pop	r6
     502:	5f 90       	pop	r5
     504:	4f 90       	pop	r4
     506:	3f 90       	pop	r3
     508:	2f 90       	pop	r2
     50a:	08 95       	ret

0000050c <xEventGroupClearBits>:
     50c:	0f 93       	push	r16
     50e:	1f 93       	push	r17
     510:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     514:	ff 93       	push	r31
     516:	f8 7f       	andi	r31, 0xF8	; 248
     518:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     51c:	fc 01       	movw	r30, r24
     51e:	00 81       	ld	r16, Z
     520:	11 81       	ldd	r17, Z+1	; 0x01
     522:	22 81       	ldd	r18, Z+2	; 0x02
     524:	33 81       	ldd	r19, Z+3	; 0x03
     526:	40 95       	com	r20
     528:	50 95       	com	r21
     52a:	60 95       	com	r22
     52c:	70 95       	com	r23
     52e:	40 23       	and	r20, r16
     530:	51 23       	and	r21, r17
     532:	62 23       	and	r22, r18
     534:	73 23       	and	r23, r19
     536:	40 83       	st	Z, r20
     538:	51 83       	std	Z+1, r21	; 0x01
     53a:	62 83       	std	Z+2, r22	; 0x02
     53c:	73 83       	std	Z+3, r23	; 0x03
     53e:	ff 91       	pop	r31
     540:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     544:	c9 01       	movw	r24, r18
     546:	b8 01       	movw	r22, r16
     548:	1f 91       	pop	r17
     54a:	0f 91       	pop	r16
     54c:	08 95       	ret

0000054e <xEventGroupSetBits>:
     54e:	4f 92       	push	r4
     550:	5f 92       	push	r5
     552:	6f 92       	push	r6
     554:	7f 92       	push	r7
     556:	af 92       	push	r10
     558:	bf 92       	push	r11
     55a:	cf 92       	push	r12
     55c:	df 92       	push	r13
     55e:	ef 92       	push	r14
     560:	ff 92       	push	r15
     562:	0f 93       	push	r16
     564:	1f 93       	push	r17
     566:	cf 93       	push	r28
     568:	df 93       	push	r29
     56a:	ec 01       	movw	r28, r24
     56c:	6a 01       	movw	r12, r20
     56e:	7b 01       	movw	r14, r22
     570:	8c 01       	movw	r16, r24
     572:	09 5f       	subi	r16, 0xF9	; 249
     574:	1f 4f       	sbci	r17, 0xFF	; 255
     576:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <vTaskSuspendAll>
     57a:	eb 85       	ldd	r30, Y+11	; 0x0b
     57c:	fc 85       	ldd	r31, Y+12	; 0x0c
     57e:	88 81       	ld	r24, Y
     580:	99 81       	ldd	r25, Y+1	; 0x01
     582:	aa 81       	ldd	r26, Y+2	; 0x02
     584:	bb 81       	ldd	r27, Y+3	; 0x03
     586:	c8 2a       	or	r12, r24
     588:	d9 2a       	or	r13, r25
     58a:	ea 2a       	or	r14, r26
     58c:	fb 2a       	or	r15, r27
     58e:	c8 82       	st	Y, r12
     590:	d9 82       	std	Y+1, r13	; 0x01
     592:	ea 82       	std	Y+2, r14	; 0x02
     594:	fb 82       	std	Y+3, r15	; 0x03
     596:	0e 17       	cp	r16, r30
     598:	1f 07       	cpc	r17, r31
     59a:	09 f4       	brne	.+2      	; 0x59e <xEventGroupSetBits+0x50>
     59c:	42 c0       	rjmp	.+132    	; 0x622 <xEventGroupSetBits+0xd4>
     59e:	c1 2c       	mov	r12, r1
     5a0:	d1 2c       	mov	r13, r1
     5a2:	76 01       	movw	r14, r12
     5a4:	a4 80       	ldd	r10, Z+4	; 0x04
     5a6:	b5 80       	ldd	r11, Z+5	; 0x05
     5a8:	80 81       	ld	r24, Z
     5aa:	91 81       	ldd	r25, Z+1	; 0x01
     5ac:	a2 81       	ldd	r26, Z+2	; 0x02
     5ae:	b3 81       	ldd	r27, Z+3	; 0x03
     5b0:	ac 01       	movw	r20, r24
     5b2:	bd 01       	movw	r22, r26
     5b4:	77 27       	eor	r23, r23
     5b6:	b2 fd       	sbrc	r27, 2
     5b8:	0f c0       	rjmp	.+30     	; 0x5d8 <xEventGroupSetBits+0x8a>
     5ba:	48 80       	ld	r4, Y
     5bc:	59 80       	ldd	r5, Y+1	; 0x01
     5be:	6a 80       	ldd	r6, Y+2	; 0x02
     5c0:	7b 80       	ldd	r7, Y+3	; 0x03
     5c2:	44 22       	and	r4, r20
     5c4:	55 22       	and	r5, r21
     5c6:	66 22       	and	r6, r22
     5c8:	77 22       	and	r7, r23
     5ca:	21 e0       	ldi	r18, 0x01	; 1
     5cc:	45 28       	or	r4, r5
     5ce:	46 28       	or	r4, r6
     5d0:	47 28       	or	r4, r7
     5d2:	89 f4       	brne	.+34     	; 0x5f6 <xEventGroupSetBits+0xa8>
     5d4:	20 e0       	ldi	r18, 0x00	; 0
     5d6:	0f c0       	rjmp	.+30     	; 0x5f6 <xEventGroupSetBits+0xa8>
     5d8:	48 80       	ld	r4, Y
     5da:	59 80       	ldd	r5, Y+1	; 0x01
     5dc:	6a 80       	ldd	r6, Y+2	; 0x02
     5de:	7b 80       	ldd	r7, Y+3	; 0x03
     5e0:	44 22       	and	r4, r20
     5e2:	55 22       	and	r5, r21
     5e4:	66 22       	and	r6, r22
     5e6:	77 22       	and	r7, r23
     5e8:	21 e0       	ldi	r18, 0x01	; 1
     5ea:	44 16       	cp	r4, r20
     5ec:	55 06       	cpc	r5, r21
     5ee:	66 06       	cpc	r6, r22
     5f0:	77 06       	cpc	r7, r23
     5f2:	09 f0       	breq	.+2      	; 0x5f6 <xEventGroupSetBits+0xa8>
     5f4:	20 e0       	ldi	r18, 0x00	; 0
     5f6:	22 23       	and	r18, r18
     5f8:	71 f0       	breq	.+28     	; 0x616 <xEventGroupSetBits+0xc8>
     5fa:	b0 ff       	sbrs	r27, 0
     5fc:	04 c0       	rjmp	.+8      	; 0x606 <xEventGroupSetBits+0xb8>
     5fe:	c4 2a       	or	r12, r20
     600:	d5 2a       	or	r13, r21
     602:	e6 2a       	or	r14, r22
     604:	f7 2a       	or	r15, r23
     606:	48 81       	ld	r20, Y
     608:	59 81       	ldd	r21, Y+1	; 0x01
     60a:	6a 81       	ldd	r22, Y+2	; 0x02
     60c:	7b 81       	ldd	r23, Y+3	; 0x03
     60e:	72 60       	ori	r23, 0x02	; 2
     610:	cf 01       	movw	r24, r30
     612:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <vTaskRemoveFromUnorderedEventList>
     616:	ea 2d       	mov	r30, r10
     618:	fb 2d       	mov	r31, r11
     61a:	0e 17       	cp	r16, r30
     61c:	1f 07       	cpc	r17, r31
     61e:	11 f6       	brne	.-124    	; 0x5a4 <xEventGroupSetBits+0x56>
     620:	03 c0       	rjmp	.+6      	; 0x628 <xEventGroupSetBits+0xda>
     622:	c1 2c       	mov	r12, r1
     624:	d1 2c       	mov	r13, r1
     626:	76 01       	movw	r14, r12
     628:	c0 94       	com	r12
     62a:	d0 94       	com	r13
     62c:	e0 94       	com	r14
     62e:	f0 94       	com	r15
     630:	88 81       	ld	r24, Y
     632:	99 81       	ldd	r25, Y+1	; 0x01
     634:	aa 81       	ldd	r26, Y+2	; 0x02
     636:	bb 81       	ldd	r27, Y+3	; 0x03
     638:	c8 22       	and	r12, r24
     63a:	d9 22       	and	r13, r25
     63c:	ea 22       	and	r14, r26
     63e:	fb 22       	and	r15, r27
     640:	c8 82       	st	Y, r12
     642:	d9 82       	std	Y+1, r13	; 0x01
     644:	ea 82       	std	Y+2, r14	; 0x02
     646:	fb 82       	std	Y+3, r15	; 0x03
     648:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
     64c:	68 81       	ld	r22, Y
     64e:	79 81       	ldd	r23, Y+1	; 0x01
     650:	8a 81       	ldd	r24, Y+2	; 0x02
     652:	9b 81       	ldd	r25, Y+3	; 0x03
     654:	df 91       	pop	r29
     656:	cf 91       	pop	r28
     658:	1f 91       	pop	r17
     65a:	0f 91       	pop	r16
     65c:	ff 90       	pop	r15
     65e:	ef 90       	pop	r14
     660:	df 90       	pop	r13
     662:	cf 90       	pop	r12
     664:	bf 90       	pop	r11
     666:	af 90       	pop	r10
     668:	7f 90       	pop	r7
     66a:	6f 90       	pop	r6
     66c:	5f 90       	pop	r5
     66e:	4f 90       	pop	r4
     670:	08 95       	ret

00000672 <vEventGroupSetBitsCallback>:
     672:	0e 94 a7 02 	call	0x54e	; 0x54e <xEventGroupSetBits>
     676:	08 95       	ret

00000678 <xEventGroupSetBitsFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
	{
     678:	0f 93       	push	r16
     67a:	1f 93       	push	r17
	BaseType_t xReturn;

		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
     67c:	89 01       	movw	r16, r18
     67e:	9a 01       	movw	r18, r20
     680:	ab 01       	movw	r20, r22
     682:	bc 01       	movw	r22, r24
     684:	89 e3       	ldi	r24, 0x39	; 57
     686:	93 e0       	ldi	r25, 0x03	; 3
     688:	0e 94 2f 13 	call	0x265e	; 0x265e <xTimerPendFunctionCallFromISR>

		return xReturn;
	}
     68c:	1f 91       	pop	r17
     68e:	0f 91       	pop	r16
     690:	08 95       	ret

00000692 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     692:	cf 93       	push	r28
     694:	df 93       	push	r29
     696:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     698:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     69c:	20 91 50 20 	lds	r18, 0x2050	; 0x802050 <__data_end>
     6a0:	30 91 51 20 	lds	r19, 0x2051	; 0x802051 <__data_end+0x1>
     6a4:	c9 01       	movw	r24, r18
     6a6:	8c 0f       	add	r24, r28
     6a8:	9d 1f       	adc	r25, r29
     6aa:	88 3b       	cpi	r24, 0xB8	; 184
     6ac:	4b e0       	ldi	r20, 0x0B	; 11
     6ae:	94 07       	cpc	r25, r20
     6b0:	58 f4       	brcc	.+22     	; 0x6c8 <pvPortMalloc+0x36>
     6b2:	28 17       	cp	r18, r24
     6b4:	39 07       	cpc	r19, r25
     6b6:	58 f4       	brcc	.+22     	; 0x6ce <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     6b8:	e9 01       	movw	r28, r18
     6ba:	ce 5a       	subi	r28, 0xAE	; 174
     6bc:	df 4d       	sbci	r29, 0xDF	; 223
			xNextFreeByte += xWantedSize;			
     6be:	80 93 50 20 	sts	0x2050, r24	; 0x802050 <__data_end>
     6c2:	90 93 51 20 	sts	0x2051, r25	; 0x802051 <__data_end+0x1>
     6c6:	05 c0       	rjmp	.+10     	; 0x6d2 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     6c8:	c0 e0       	ldi	r28, 0x00	; 0
     6ca:	d0 e0       	ldi	r29, 0x00	; 0
     6cc:	02 c0       	rjmp	.+4      	; 0x6d2 <pvPortMalloc+0x40>
     6ce:	c0 e0       	ldi	r28, 0x00	; 0
     6d0:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     6d2:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     6d6:	ce 01       	movw	r24, r28
     6d8:	df 91       	pop	r29
     6da:	cf 91       	pop	r28
     6dc:	08 95       	ret

000006de <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6de:	08 95       	ret

000006e0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6e0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6e2:	03 96       	adiw	r24, 0x03	; 3
     6e4:	81 83       	std	Z+1, r24	; 0x01
     6e6:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6e8:	4f ef       	ldi	r20, 0xFF	; 255
     6ea:	5f ef       	ldi	r21, 0xFF	; 255
     6ec:	ba 01       	movw	r22, r20
     6ee:	43 83       	std	Z+3, r20	; 0x03
     6f0:	54 83       	std	Z+4, r21	; 0x04
     6f2:	65 83       	std	Z+5, r22	; 0x05
     6f4:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6f6:	87 83       	std	Z+7, r24	; 0x07
     6f8:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6fa:	81 87       	std	Z+9, r24	; 0x09
     6fc:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6fe:	10 82       	st	Z, r1
     700:	08 95       	ret

00000702 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     702:	fc 01       	movw	r30, r24
     704:	12 86       	std	Z+10, r1	; 0x0a
     706:	13 86       	std	Z+11, r1	; 0x0b
     708:	08 95       	ret

0000070a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     70a:	cf 93       	push	r28
     70c:	df 93       	push	r29
     70e:	9c 01       	movw	r18, r24
     710:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     712:	dc 01       	movw	r26, r24
     714:	11 96       	adiw	r26, 0x01	; 1
     716:	cd 91       	ld	r28, X+
     718:	dc 91       	ld	r29, X
     71a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     71c:	c4 83       	std	Z+4, r28	; 0x04
     71e:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     720:	8e 81       	ldd	r24, Y+6	; 0x06
     722:	9f 81       	ldd	r25, Y+7	; 0x07
     724:	86 83       	std	Z+6, r24	; 0x06
     726:	97 83       	std	Z+7, r25	; 0x07

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     728:	8e 81       	ldd	r24, Y+6	; 0x06
     72a:	9f 81       	ldd	r25, Y+7	; 0x07
     72c:	dc 01       	movw	r26, r24
     72e:	14 96       	adiw	r26, 0x04	; 4
     730:	6d 93       	st	X+, r22
     732:	7c 93       	st	X, r23
     734:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxPrevious = pxNewListItem;
     736:	6e 83       	std	Y+6, r22	; 0x06
     738:	7f 83       	std	Y+7, r23	; 0x07

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     73a:	22 87       	std	Z+10, r18	; 0x0a
     73c:	33 87       	std	Z+11, r19	; 0x0b

	( pxList->uxNumberOfItems )++;
     73e:	f9 01       	movw	r30, r18
     740:	80 81       	ld	r24, Z
     742:	8f 5f       	subi	r24, 0xFF	; 255
     744:	80 83       	st	Z, r24
}
     746:	df 91       	pop	r29
     748:	cf 91       	pop	r28
     74a:	08 95       	ret

0000074c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     74c:	0f 93       	push	r16
     74e:	1f 93       	push	r17
     750:	cf 93       	push	r28
     752:	df 93       	push	r29
     754:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     756:	08 81       	ld	r16, Y
     758:	19 81       	ldd	r17, Y+1	; 0x01
     75a:	2a 81       	ldd	r18, Y+2	; 0x02
     75c:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     75e:	0f 3f       	cpi	r16, 0xFF	; 255
     760:	4f ef       	ldi	r20, 0xFF	; 255
     762:	14 07       	cpc	r17, r20
     764:	24 07       	cpc	r18, r20
     766:	34 07       	cpc	r19, r20
     768:	21 f4       	brne	.+8      	; 0x772 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     76a:	fc 01       	movw	r30, r24
     76c:	a1 85       	ldd	r26, Z+9	; 0x09
     76e:	b2 85       	ldd	r27, Z+10	; 0x0a
     770:	11 c0       	rjmp	.+34     	; 0x794 <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     772:	dc 01       	movw	r26, r24
     774:	13 96       	adiw	r26, 0x03	; 3
     776:	01 c0       	rjmp	.+2      	; 0x77a <vListInsert+0x2e>
     778:	df 01       	movw	r26, r30
     77a:	14 96       	adiw	r26, 0x04	; 4
     77c:	ed 91       	ld	r30, X+
     77e:	fc 91       	ld	r31, X
     780:	15 97       	sbiw	r26, 0x05	; 5
     782:	40 81       	ld	r20, Z
     784:	51 81       	ldd	r21, Z+1	; 0x01
     786:	62 81       	ldd	r22, Z+2	; 0x02
     788:	73 81       	ldd	r23, Z+3	; 0x03
     78a:	04 17       	cp	r16, r20
     78c:	15 07       	cpc	r17, r21
     78e:	26 07       	cpc	r18, r22
     790:	37 07       	cpc	r19, r23
     792:	90 f7       	brcc	.-28     	; 0x778 <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     794:	14 96       	adiw	r26, 0x04	; 4
     796:	ed 91       	ld	r30, X+
     798:	fc 91       	ld	r31, X
     79a:	15 97       	sbiw	r26, 0x05	; 5
     79c:	ec 83       	std	Y+4, r30	; 0x04
     79e:	fd 83       	std	Y+5, r31	; 0x05
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     7a0:	c6 83       	std	Z+6, r28	; 0x06
     7a2:	d7 83       	std	Z+7, r29	; 0x07
	pxNewListItem->pxPrevious = pxIterator;
     7a4:	ae 83       	std	Y+6, r26	; 0x06
     7a6:	bf 83       	std	Y+7, r27	; 0x07
	pxIterator->pxNext = pxNewListItem;
     7a8:	14 96       	adiw	r26, 0x04	; 4
     7aa:	cd 93       	st	X+, r28
     7ac:	dc 93       	st	X, r29
     7ae:	15 97       	sbiw	r26, 0x05	; 5

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     7b0:	8a 87       	std	Y+10, r24	; 0x0a
     7b2:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
     7b4:	fc 01       	movw	r30, r24
     7b6:	20 81       	ld	r18, Z
     7b8:	2f 5f       	subi	r18, 0xFF	; 255
     7ba:	20 83       	st	Z, r18
}
     7bc:	df 91       	pop	r29
     7be:	cf 91       	pop	r28
     7c0:	1f 91       	pop	r17
     7c2:	0f 91       	pop	r16
     7c4:	08 95       	ret

000007c6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     7c6:	cf 93       	push	r28
     7c8:	df 93       	push	r29
     7ca:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     7cc:	a2 85       	ldd	r26, Z+10	; 0x0a
     7ce:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     7d0:	c4 81       	ldd	r28, Z+4	; 0x04
     7d2:	d5 81       	ldd	r29, Z+5	; 0x05
     7d4:	86 81       	ldd	r24, Z+6	; 0x06
     7d6:	97 81       	ldd	r25, Z+7	; 0x07
     7d8:	8e 83       	std	Y+6, r24	; 0x06
     7da:	9f 83       	std	Y+7, r25	; 0x07
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     7dc:	c6 81       	ldd	r28, Z+6	; 0x06
     7de:	d7 81       	ldd	r29, Z+7	; 0x07
     7e0:	84 81       	ldd	r24, Z+4	; 0x04
     7e2:	95 81       	ldd	r25, Z+5	; 0x05
     7e4:	8c 83       	std	Y+4, r24	; 0x04
     7e6:	9d 83       	std	Y+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7e8:	11 96       	adiw	r26, 0x01	; 1
     7ea:	8d 91       	ld	r24, X+
     7ec:	9c 91       	ld	r25, X
     7ee:	12 97       	sbiw	r26, 0x02	; 2
     7f0:	e8 17       	cp	r30, r24
     7f2:	f9 07       	cpc	r31, r25
     7f4:	31 f4       	brne	.+12     	; 0x802 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7f6:	86 81       	ldd	r24, Z+6	; 0x06
     7f8:	97 81       	ldd	r25, Z+7	; 0x07
     7fa:	11 96       	adiw	r26, 0x01	; 1
     7fc:	8d 93       	st	X+, r24
     7fe:	9c 93       	st	X, r25
     800:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     802:	12 86       	std	Z+10, r1	; 0x0a
     804:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     806:	8c 91       	ld	r24, X
     808:	81 50       	subi	r24, 0x01	; 1
     80a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     80c:	8c 91       	ld	r24, X
}
     80e:	df 91       	pop	r29
     810:	cf 91       	pop	r28
     812:	08 95       	ret

00000814 <_portSetInterruptMaskFromIsr>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     814:	e0 ea       	ldi	r30, 0xA0	; 160
     816:	f0 e0       	ldi	r31, 0x00	; 0
     818:	82 81       	ldd	r24, Z+2	; 0x02
     81a:	92 81       	ldd	r25, Z+2	; 0x02
     81c:	98 7f       	andi	r25, 0xF8	; 248
     81e:	92 83       	std	Z+2, r25	; 0x02
     820:	08 95       	ret

00000822 <pxPortInitialiseStack>:
     822:	cf 92       	push	r12
     824:	df 92       	push	r13
     826:	ef 92       	push	r14
     828:	ff 92       	push	r15
     82a:	31 e1       	ldi	r19, 0x11	; 17
     82c:	fc 01       	movw	r30, r24
     82e:	30 83       	st	Z, r19
     830:	31 97       	sbiw	r30, 0x01	; 1
     832:	22 e2       	ldi	r18, 0x22	; 34
     834:	20 83       	st	Z, r18
     836:	31 97       	sbiw	r30, 0x01	; 1
     838:	a3 e3       	ldi	r26, 0x33	; 51
     83a:	a0 83       	st	Z, r26
     83c:	6b 01       	movw	r12, r22
     83e:	e1 2c       	mov	r14, r1
     840:	f1 2c       	mov	r15, r1
     842:	31 97       	sbiw	r30, 0x01	; 1
     844:	60 83       	st	Z, r22
     846:	31 97       	sbiw	r30, 0x01	; 1
     848:	d0 82       	st	Z, r13
     84a:	31 97       	sbiw	r30, 0x01	; 1
     84c:	e0 82       	st	Z, r14
     84e:	31 97       	sbiw	r30, 0x01	; 1
     850:	61 e3       	ldi	r22, 0x31	; 49
     852:	60 83       	st	Z, r22
     854:	31 97       	sbiw	r30, 0x01	; 1
     856:	60 e8       	ldi	r22, 0x80	; 128
     858:	60 83       	st	Z, r22
     85a:	31 97       	sbiw	r30, 0x01	; 1
     85c:	67 e8       	ldi	r22, 0x87	; 135
     85e:	60 83       	st	Z, r22
     860:	31 97       	sbiw	r30, 0x01	; 1
     862:	10 82       	st	Z, r1
     864:	31 97       	sbiw	r30, 0x01	; 1
     866:	10 82       	st	Z, r1
     868:	31 97       	sbiw	r30, 0x01	; 1
     86a:	62 e0       	ldi	r22, 0x02	; 2
     86c:	60 83       	st	Z, r22
     86e:	31 97       	sbiw	r30, 0x01	; 1
     870:	63 e0       	ldi	r22, 0x03	; 3
     872:	60 83       	st	Z, r22
     874:	31 97       	sbiw	r30, 0x01	; 1
     876:	64 e0       	ldi	r22, 0x04	; 4
     878:	60 83       	st	Z, r22
     87a:	31 97       	sbiw	r30, 0x01	; 1
     87c:	65 e0       	ldi	r22, 0x05	; 5
     87e:	60 83       	st	Z, r22
     880:	31 97       	sbiw	r30, 0x01	; 1
     882:	66 e0       	ldi	r22, 0x06	; 6
     884:	60 83       	st	Z, r22
     886:	31 97       	sbiw	r30, 0x01	; 1
     888:	67 e0       	ldi	r22, 0x07	; 7
     88a:	60 83       	st	Z, r22
     88c:	31 97       	sbiw	r30, 0x01	; 1
     88e:	68 e0       	ldi	r22, 0x08	; 8
     890:	60 83       	st	Z, r22
     892:	31 97       	sbiw	r30, 0x01	; 1
     894:	69 e0       	ldi	r22, 0x09	; 9
     896:	60 83       	st	Z, r22
     898:	31 97       	sbiw	r30, 0x01	; 1
     89a:	60 e1       	ldi	r22, 0x10	; 16
     89c:	60 83       	st	Z, r22
     89e:	31 97       	sbiw	r30, 0x01	; 1
     8a0:	30 83       	st	Z, r19
     8a2:	31 97       	sbiw	r30, 0x01	; 1
     8a4:	32 e1       	ldi	r19, 0x12	; 18
     8a6:	30 83       	st	Z, r19
     8a8:	31 97       	sbiw	r30, 0x01	; 1
     8aa:	33 e1       	ldi	r19, 0x13	; 19
     8ac:	30 83       	st	Z, r19
     8ae:	31 97       	sbiw	r30, 0x01	; 1
     8b0:	34 e1       	ldi	r19, 0x14	; 20
     8b2:	30 83       	st	Z, r19
     8b4:	31 97       	sbiw	r30, 0x01	; 1
     8b6:	35 e1       	ldi	r19, 0x15	; 21
     8b8:	30 83       	st	Z, r19
     8ba:	31 97       	sbiw	r30, 0x01	; 1
     8bc:	36 e1       	ldi	r19, 0x16	; 22
     8be:	30 83       	st	Z, r19
     8c0:	31 97       	sbiw	r30, 0x01	; 1
     8c2:	37 e1       	ldi	r19, 0x17	; 23
     8c4:	30 83       	st	Z, r19
     8c6:	31 97       	sbiw	r30, 0x01	; 1
     8c8:	38 e1       	ldi	r19, 0x18	; 24
     8ca:	30 83       	st	Z, r19
     8cc:	31 97       	sbiw	r30, 0x01	; 1
     8ce:	39 e1       	ldi	r19, 0x19	; 25
     8d0:	30 83       	st	Z, r19
     8d2:	31 97       	sbiw	r30, 0x01	; 1
     8d4:	30 e2       	ldi	r19, 0x20	; 32
     8d6:	30 83       	st	Z, r19
     8d8:	31 97       	sbiw	r30, 0x01	; 1
     8da:	31 e2       	ldi	r19, 0x21	; 33
     8dc:	30 83       	st	Z, r19
     8de:	31 97       	sbiw	r30, 0x01	; 1
     8e0:	20 83       	st	Z, r18
     8e2:	31 97       	sbiw	r30, 0x01	; 1
     8e4:	23 e2       	ldi	r18, 0x23	; 35
     8e6:	20 83       	st	Z, r18
     8e8:	6a 01       	movw	r12, r20
     8ea:	31 97       	sbiw	r30, 0x01	; 1
     8ec:	40 83       	st	Z, r20
     8ee:	31 97       	sbiw	r30, 0x01	; 1
     8f0:	d0 82       	st	Z, r13
     8f2:	31 97       	sbiw	r30, 0x01	; 1
     8f4:	26 e2       	ldi	r18, 0x26	; 38
     8f6:	20 83       	st	Z, r18
     8f8:	31 97       	sbiw	r30, 0x01	; 1
     8fa:	27 e2       	ldi	r18, 0x27	; 39
     8fc:	20 83       	st	Z, r18
     8fe:	31 97       	sbiw	r30, 0x01	; 1
     900:	28 e2       	ldi	r18, 0x28	; 40
     902:	20 83       	st	Z, r18
     904:	31 97       	sbiw	r30, 0x01	; 1
     906:	29 e2       	ldi	r18, 0x29	; 41
     908:	20 83       	st	Z, r18
     90a:	31 97       	sbiw	r30, 0x01	; 1
     90c:	20 e3       	ldi	r18, 0x30	; 48
     90e:	20 83       	st	Z, r18
     910:	88 97       	sbiw	r24, 0x28	; 40
     912:	ff 90       	pop	r15
     914:	ef 90       	pop	r14
     916:	df 90       	pop	r13
     918:	cf 90       	pop	r12
     91a:	08 95       	ret

0000091c <xPortStartScheduler>:
     91c:	83 ef       	ldi	r24, 0xF3	; 243
     91e:	91 e0       	ldi	r25, 0x01	; 1
     920:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
     924:	90 93 27 08 	sts	0x0827, r25	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
     928:	65 e0       	ldi	r22, 0x05	; 5
     92a:	80 e0       	ldi	r24, 0x00	; 0
     92c:	98 e0       	ldi	r25, 0x08	; 8
     92e:	0e 94 90 01 	call	0x320	; 0x320 <TC0_ConfigClockSource>
     932:	61 e0       	ldi	r22, 0x01	; 1
     934:	80 e0       	ldi	r24, 0x00	; 0
     936:	98 e0       	ldi	r25, 0x08	; 8
     938:	0e 94 9c 01 	call	0x338	; 0x338 <TC0_SetOverflowIntLevel>
     93c:	a0 91 78 2c 	lds	r26, 0x2C78	; 0x802c78 <pxCurrentTCB>
     940:	b0 91 79 2c 	lds	r27, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
     944:	0d 90       	ld	r0, X+
     946:	0d be       	out	0x3d, r0	; 61
     948:	0d 90       	ld	r0, X+
     94a:	0e be       	out	0x3e, r0	; 62
     94c:	ef 91       	pop	r30
     94e:	df 91       	pop	r29
     950:	cf 91       	pop	r28
     952:	bf 91       	pop	r27
     954:	af 91       	pop	r26
     956:	9f 91       	pop	r25
     958:	8f 91       	pop	r24
     95a:	7f 91       	pop	r23
     95c:	6f 91       	pop	r22
     95e:	5f 91       	pop	r21
     960:	4f 91       	pop	r20
     962:	3f 91       	pop	r19
     964:	2f 91       	pop	r18
     966:	1f 91       	pop	r17
     968:	0f 91       	pop	r16
     96a:	ff 90       	pop	r15
     96c:	ef 90       	pop	r14
     96e:	df 90       	pop	r13
     970:	cf 90       	pop	r12
     972:	bf 90       	pop	r11
     974:	af 90       	pop	r10
     976:	9f 90       	pop	r9
     978:	8f 90       	pop	r8
     97a:	7f 90       	pop	r7
     97c:	6f 90       	pop	r6
     97e:	5f 90       	pop	r5
     980:	4f 90       	pop	r4
     982:	3f 90       	pop	r3
     984:	2f 90       	pop	r2
     986:	1f 90       	pop	r1
     988:	0f 90       	pop	r0
     98a:	ff 91       	pop	r31
     98c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     990:	ff 91       	pop	r31
     992:	ff bf       	out	0x3f, r31	; 63
     994:	ff 91       	pop	r31
     996:	08 95       	ret
     998:	81 e0       	ldi	r24, 0x01	; 1
     99a:	08 95       	ret

0000099c <vPortYield>:
// 
//
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     99c:	ff 93       	push	r31
     99e:	ff b7       	in	r31, 0x3f	; 63
     9a0:	ff 93       	push	r31
     9a2:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     9a6:	ff 93       	push	r31
     9a8:	f8 7f       	andi	r31, 0xF8	; 248
     9aa:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     9ae:	0f 92       	push	r0
     9b0:	1f 92       	push	r1
     9b2:	11 24       	eor	r1, r1
     9b4:	2f 92       	push	r2
     9b6:	3f 92       	push	r3
     9b8:	4f 92       	push	r4
     9ba:	5f 92       	push	r5
     9bc:	6f 92       	push	r6
     9be:	7f 92       	push	r7
     9c0:	8f 92       	push	r8
     9c2:	9f 92       	push	r9
     9c4:	af 92       	push	r10
     9c6:	bf 92       	push	r11
     9c8:	cf 92       	push	r12
     9ca:	df 92       	push	r13
     9cc:	ef 92       	push	r14
     9ce:	ff 92       	push	r15
     9d0:	0f 93       	push	r16
     9d2:	1f 93       	push	r17
     9d4:	2f 93       	push	r18
     9d6:	3f 93       	push	r19
     9d8:	4f 93       	push	r20
     9da:	5f 93       	push	r21
     9dc:	6f 93       	push	r22
     9de:	7f 93       	push	r23
     9e0:	8f 93       	push	r24
     9e2:	9f 93       	push	r25
     9e4:	af 93       	push	r26
     9e6:	bf 93       	push	r27
     9e8:	cf 93       	push	r28
     9ea:	df 93       	push	r29
     9ec:	ef 93       	push	r30
     9ee:	a0 91 78 2c 	lds	r26, 0x2C78	; 0x802c78 <pxCurrentTCB>
     9f2:	b0 91 79 2c 	lds	r27, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
     9f6:	0d b6       	in	r0, 0x3d	; 61
     9f8:	0d 92       	st	X+, r0
     9fa:	0e b6       	in	r0, 0x3e	; 62
     9fc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     9fe:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     a02:	a0 91 78 2c 	lds	r26, 0x2C78	; 0x802c78 <pxCurrentTCB>
     a06:	b0 91 79 2c 	lds	r27, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
     a0a:	0d 90       	ld	r0, X+
     a0c:	0d be       	out	0x3d, r0	; 61
     a0e:	0d 90       	ld	r0, X+
     a10:	0e be       	out	0x3e, r0	; 62
     a12:	ef 91       	pop	r30
     a14:	df 91       	pop	r29
     a16:	cf 91       	pop	r28
     a18:	bf 91       	pop	r27
     a1a:	af 91       	pop	r26
     a1c:	9f 91       	pop	r25
     a1e:	8f 91       	pop	r24
     a20:	7f 91       	pop	r23
     a22:	6f 91       	pop	r22
     a24:	5f 91       	pop	r21
     a26:	4f 91       	pop	r20
     a28:	3f 91       	pop	r19
     a2a:	2f 91       	pop	r18
     a2c:	1f 91       	pop	r17
     a2e:	0f 91       	pop	r16
     a30:	ff 90       	pop	r15
     a32:	ef 90       	pop	r14
     a34:	df 90       	pop	r13
     a36:	cf 90       	pop	r12
     a38:	bf 90       	pop	r11
     a3a:	af 90       	pop	r10
     a3c:	9f 90       	pop	r9
     a3e:	8f 90       	pop	r8
     a40:	7f 90       	pop	r7
     a42:	6f 90       	pop	r6
     a44:	5f 90       	pop	r5
     a46:	4f 90       	pop	r4
     a48:	3f 90       	pop	r3
     a4a:	2f 90       	pop	r2
     a4c:	1f 90       	pop	r1
     a4e:	0f 90       	pop	r0
     a50:	ff 91       	pop	r31
     a52:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     a56:	ff 91       	pop	r31
     a58:	ff bf       	out	0x3f, r31	; 63
     a5a:	ff 91       	pop	r31
	asm volatile ( "ret" );
     a5c:	08 95       	ret

00000a5e <portTaskSwitchContext>:
	//-----------------------------------------------------------
	//
	// The task switch is deferred until there is no more nesting.
	//
	void portTaskSwitchContext(signed portBASE_TYPE xSwitchRequired)
	{
     a5e:	cf 93       	push	r28
		intTaskSwitchPending |= xSwitchRequired;					
     a60:	90 91 cc 2c 	lds	r25, 0x2CCC	; 0x802ccc <intTaskSwitchPending>
     a64:	89 2b       	or	r24, r25
     a66:	80 93 cc 2c 	sts	0x2CCC, r24	; 0x802ccc <intTaskSwitchPending>
																
		if(NOT_NESTING() && intTaskSwitchPending)					
     a6a:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     a6e:	91 30       	cpi	r25, 0x01	; 1
     a70:	41 f0       	breq	.+16     	; 0xa82 <portTaskSwitchContext+0x24>
     a72:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     a76:	92 30       	cpi	r25, 0x02	; 2
     a78:	21 f0       	breq	.+8      	; 0xa82 <portTaskSwitchContext+0x24>
     a7a:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     a7e:	94 30       	cpi	r25, 0x04	; 4
     a80:	59 f4       	brne	.+22     	; 0xa98 <portTaskSwitchContext+0x3a>
     a82:	88 23       	and	r24, r24
     a84:	49 f0       	breq	.+18     	; 0xa98 <portTaskSwitchContext+0x3a>
		{															
			register unsigned portBASE_TYPE uxSavedPmicCtrlReg; 				
			extern void vTaskSwitchContext(void);   				
																
			// Critical section used, because vTaskSwitchContext handles FreeRTOS internal data structures.
 			uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR(); 
     a86:	0e 94 0a 04 	call	0x814	; 0x814 <_portSetInterruptMaskFromIsr>
     a8a:	c8 2f       	mov	r28, r24
			intTaskSwitchPending = 0;								
     a8c:	10 92 cc 2c 	sts	0x2CCC, r1	; 0x802ccc <intTaskSwitchPending>
			vTaskSwitchContext();                   				
     a90:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <vTaskSwitchContext>
			portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedPmicCtrlReg);
     a94:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		}                                          					
	}
     a98:	cf 91       	pop	r28
     a9a:	08 95       	ret

00000a9c <__vector_14>:
	// the context is saved at the start of vPortYieldFromTick().  The tick
	// count is incremented after the context is saved.
	//
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
     a9c:	ff 93       	push	r31
     a9e:	ff b7       	in	r31, 0x3f	; 63
     aa0:	ff 93       	push	r31
     aa2:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     aa6:	ff 93       	push	r31
     aa8:	f8 7f       	andi	r31, 0xF8	; 248
     aaa:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     aae:	0f 92       	push	r0
     ab0:	1f 92       	push	r1
     ab2:	11 24       	eor	r1, r1
     ab4:	2f 92       	push	r2
     ab6:	3f 92       	push	r3
     ab8:	4f 92       	push	r4
     aba:	5f 92       	push	r5
     abc:	6f 92       	push	r6
     abe:	7f 92       	push	r7
     ac0:	8f 92       	push	r8
     ac2:	9f 92       	push	r9
     ac4:	af 92       	push	r10
     ac6:	bf 92       	push	r11
     ac8:	cf 92       	push	r12
     aca:	df 92       	push	r13
     acc:	ef 92       	push	r14
     ace:	ff 92       	push	r15
     ad0:	0f 93       	push	r16
     ad2:	1f 93       	push	r17
     ad4:	2f 93       	push	r18
     ad6:	3f 93       	push	r19
     ad8:	4f 93       	push	r20
     ada:	5f 93       	push	r21
     adc:	6f 93       	push	r22
     ade:	7f 93       	push	r23
     ae0:	8f 93       	push	r24
     ae2:	9f 93       	push	r25
     ae4:	af 93       	push	r26
     ae6:	bf 93       	push	r27
     ae8:	cf 93       	push	r28
     aea:	df 93       	push	r29
     aec:	ef 93       	push	r30
     aee:	a0 91 78 2c 	lds	r26, 0x2C78	; 0x802c78 <pxCurrentTCB>
     af2:	b0 91 79 2c 	lds	r27, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
     af6:	0d b6       	in	r0, 0x3d	; 61
     af8:	0d 92       	st	X+, r0
     afa:	0e b6       	in	r0, 0x3e	; 62
     afc:	0d 92       	st	X+, r0
	//
	static void portTaskIncrementTick( void )
	{
		register unsigned portBASE_TYPE uxSavedPmicCtrlReg;

 		uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR();
     afe:	0e 94 0a 04 	call	0x814	; 0x814 <_portSetInterruptMaskFromIsr>
     b02:	c8 2f       	mov	r28, r24
		xTaskIncrementTick();
     b04:	0e 94 ef 0b 	call	0x17de	; 0x17de <xTaskIncrementTick>
 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedPmicCtrlReg );
     b08:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
		portTaskIncrementTick();
		//always try a task switch, but only if on kernel interrupt level
		portEND_SWITCHING_ISR(pdTRUE); 
     b0c:	81 e0       	ldi	r24, 0x01	; 1
     b0e:	0e 94 2f 05 	call	0xa5e	; 0xa5e <portTaskSwitchContext>
     b12:	a0 91 78 2c 	lds	r26, 0x2C78	; 0x802c78 <pxCurrentTCB>
     b16:	b0 91 79 2c 	lds	r27, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
     b1a:	0d 90       	ld	r0, X+
     b1c:	0d be       	out	0x3d, r0	; 61
     b1e:	0d 90       	ld	r0, X+
     b20:	0e be       	out	0x3e, r0	; 62
     b22:	ef 91       	pop	r30
     b24:	df 91       	pop	r29
     b26:	cf 91       	pop	r28
     b28:	bf 91       	pop	r27
     b2a:	af 91       	pop	r26
     b2c:	9f 91       	pop	r25
     b2e:	8f 91       	pop	r24
     b30:	7f 91       	pop	r23
     b32:	6f 91       	pop	r22
     b34:	5f 91       	pop	r21
     b36:	4f 91       	pop	r20
     b38:	3f 91       	pop	r19
     b3a:	2f 91       	pop	r18
     b3c:	1f 91       	pop	r17
     b3e:	0f 91       	pop	r16
     b40:	ff 90       	pop	r15
     b42:	ef 90       	pop	r14
     b44:	df 90       	pop	r13
     b46:	cf 90       	pop	r12
     b48:	bf 90       	pop	r11
     b4a:	af 90       	pop	r10
     b4c:	9f 90       	pop	r9
     b4e:	8f 90       	pop	r8
     b50:	7f 90       	pop	r7
     b52:	6f 90       	pop	r6
     b54:	5f 90       	pop	r5
     b56:	4f 90       	pop	r4
     b58:	3f 90       	pop	r3
     b5a:	2f 90       	pop	r2
     b5c:	1f 90       	pop	r1
     b5e:	0f 90       	pop	r0
     b60:	ff 91       	pop	r31
     b62:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b66:	ff 91       	pop	r31
     b68:	ff bf       	out	0x3f, r31	; 63
     b6a:	ff 91       	pop	r31
     b6c:	18 95       	reti

00000b6e <prvIsQueueEmpty>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
     b6e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b72:	ff 93       	push	r31
     b74:	f8 7f       	andi	r31, 0xF8	; 248
     b76:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b7a:	fc 01       	movw	r30, r24
     b7c:	96 8d       	ldd	r25, Z+30	; 0x1e
     b7e:	ff 91       	pop	r31
     b80:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b84:	81 e0       	ldi	r24, 0x01	; 1
     b86:	91 11       	cpse	r25, r1
     b88:	80 e0       	ldi	r24, 0x00	; 0
     b8a:	08 95       	ret

00000b8c <prvIsQueueFull>:
     b8c:	dc 01       	movw	r26, r24
     b8e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b92:	ff 93       	push	r31
     b94:	f8 7f       	andi	r31, 0xF8	; 248
     b96:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b9a:	5e 96       	adiw	r26, 0x1e	; 30
     b9c:	9c 91       	ld	r25, X
     b9e:	5e 97       	sbiw	r26, 0x1e	; 30
     ba0:	ff 91       	pop	r31
     ba2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ba6:	81 e0       	ldi	r24, 0x01	; 1
     ba8:	5f 96       	adiw	r26, 0x1f	; 31
     baa:	2c 91       	ld	r18, X
     bac:	29 13       	cpse	r18, r25
     bae:	80 e0       	ldi	r24, 0x00	; 0
     bb0:	08 95       	ret

00000bb2 <prvCopyDataToQueue>:
     bb2:	0f 93       	push	r16
     bb4:	1f 93       	push	r17
     bb6:	cf 93       	push	r28
     bb8:	df 93       	push	r29
     bba:	ec 01       	movw	r28, r24
     bbc:	04 2f       	mov	r16, r20
     bbe:	1e 8d       	ldd	r17, Y+30	; 0x1e
     bc0:	48 a1       	ldd	r20, Y+32	; 0x20
     bc2:	41 11       	cpse	r20, r1
     bc4:	0c c0       	rjmp	.+24     	; 0xbde <prvCopyDataToQueue+0x2c>
     bc6:	88 81       	ld	r24, Y
     bc8:	99 81       	ldd	r25, Y+1	; 0x01
     bca:	89 2b       	or	r24, r25
     bcc:	09 f0       	breq	.+2      	; 0xbd0 <prvCopyDataToQueue+0x1e>
     bce:	42 c0       	rjmp	.+132    	; 0xc54 <prvCopyDataToQueue+0xa2>
     bd0:	8a 81       	ldd	r24, Y+2	; 0x02
     bd2:	9b 81       	ldd	r25, Y+3	; 0x03
     bd4:	0e 94 b1 0f 	call	0x1f62	; 0x1f62 <xTaskPriorityDisinherit>
     bd8:	1a 82       	std	Y+2, r1	; 0x02
     bda:	1b 82       	std	Y+3, r1	; 0x03
     bdc:	42 c0       	rjmp	.+132    	; 0xc62 <prvCopyDataToQueue+0xb0>
     bde:	01 11       	cpse	r16, r1
     be0:	17 c0       	rjmp	.+46     	; 0xc10 <prvCopyDataToQueue+0x5e>
     be2:	50 e0       	ldi	r21, 0x00	; 0
     be4:	8c 81       	ldd	r24, Y+4	; 0x04
     be6:	9d 81       	ldd	r25, Y+5	; 0x05
     be8:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <memcpy>
     bec:	28 a1       	ldd	r18, Y+32	; 0x20
     bee:	8c 81       	ldd	r24, Y+4	; 0x04
     bf0:	9d 81       	ldd	r25, Y+5	; 0x05
     bf2:	82 0f       	add	r24, r18
     bf4:	91 1d       	adc	r25, r1
     bf6:	8c 83       	std	Y+4, r24	; 0x04
     bf8:	9d 83       	std	Y+5, r25	; 0x05
     bfa:	2a 81       	ldd	r18, Y+2	; 0x02
     bfc:	3b 81       	ldd	r19, Y+3	; 0x03
     bfe:	82 17       	cp	r24, r18
     c00:	93 07       	cpc	r25, r19
     c02:	50 f1       	brcs	.+84     	; 0xc58 <prvCopyDataToQueue+0xa6>
     c04:	88 81       	ld	r24, Y
     c06:	99 81       	ldd	r25, Y+1	; 0x01
     c08:	8c 83       	std	Y+4, r24	; 0x04
     c0a:	9d 83       	std	Y+5, r25	; 0x05
     c0c:	80 e0       	ldi	r24, 0x00	; 0
     c0e:	29 c0       	rjmp	.+82     	; 0xc62 <prvCopyDataToQueue+0xb0>
     c10:	50 e0       	ldi	r21, 0x00	; 0
     c12:	8e 81       	ldd	r24, Y+6	; 0x06
     c14:	9f 81       	ldd	r25, Y+7	; 0x07
     c16:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <memcpy>
     c1a:	88 a1       	ldd	r24, Y+32	; 0x20
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	91 95       	neg	r25
     c20:	81 95       	neg	r24
     c22:	91 09       	sbc	r25, r1
     c24:	2e 81       	ldd	r18, Y+6	; 0x06
     c26:	3f 81       	ldd	r19, Y+7	; 0x07
     c28:	28 0f       	add	r18, r24
     c2a:	39 1f       	adc	r19, r25
     c2c:	2e 83       	std	Y+6, r18	; 0x06
     c2e:	3f 83       	std	Y+7, r19	; 0x07
     c30:	48 81       	ld	r20, Y
     c32:	59 81       	ldd	r21, Y+1	; 0x01
     c34:	24 17       	cp	r18, r20
     c36:	35 07       	cpc	r19, r21
     c38:	30 f4       	brcc	.+12     	; 0xc46 <prvCopyDataToQueue+0x94>
     c3a:	2a 81       	ldd	r18, Y+2	; 0x02
     c3c:	3b 81       	ldd	r19, Y+3	; 0x03
     c3e:	82 0f       	add	r24, r18
     c40:	93 1f       	adc	r25, r19
     c42:	8e 83       	std	Y+6, r24	; 0x06
     c44:	9f 83       	std	Y+7, r25	; 0x07
     c46:	02 30       	cpi	r16, 0x02	; 2
     c48:	49 f4       	brne	.+18     	; 0xc5c <prvCopyDataToQueue+0xaa>
     c4a:	11 23       	and	r17, r17
     c4c:	49 f0       	breq	.+18     	; 0xc60 <prvCopyDataToQueue+0xae>
     c4e:	11 50       	subi	r17, 0x01	; 1
     c50:	80 e0       	ldi	r24, 0x00	; 0
     c52:	07 c0       	rjmp	.+14     	; 0xc62 <prvCopyDataToQueue+0xb0>
     c54:	80 e0       	ldi	r24, 0x00	; 0
     c56:	05 c0       	rjmp	.+10     	; 0xc62 <prvCopyDataToQueue+0xb0>
     c58:	80 e0       	ldi	r24, 0x00	; 0
     c5a:	03 c0       	rjmp	.+6      	; 0xc62 <prvCopyDataToQueue+0xb0>
     c5c:	80 e0       	ldi	r24, 0x00	; 0
     c5e:	01 c0       	rjmp	.+2      	; 0xc62 <prvCopyDataToQueue+0xb0>
     c60:	80 e0       	ldi	r24, 0x00	; 0
     c62:	1f 5f       	subi	r17, 0xFF	; 255
     c64:	1e 8f       	std	Y+30, r17	; 0x1e
     c66:	df 91       	pop	r29
     c68:	cf 91       	pop	r28
     c6a:	1f 91       	pop	r17
     c6c:	0f 91       	pop	r16
     c6e:	08 95       	ret

00000c70 <prvCopyDataFromQueue>:
     c70:	fc 01       	movw	r30, r24
     c72:	40 a1       	ldd	r20, Z+32	; 0x20
     c74:	44 23       	and	r20, r20
     c76:	a9 f0       	breq	.+42     	; 0xca2 <prvCopyDataFromQueue+0x32>
     c78:	50 e0       	ldi	r21, 0x00	; 0
     c7a:	26 81       	ldd	r18, Z+6	; 0x06
     c7c:	37 81       	ldd	r19, Z+7	; 0x07
     c7e:	24 0f       	add	r18, r20
     c80:	35 1f       	adc	r19, r21
     c82:	26 83       	std	Z+6, r18	; 0x06
     c84:	37 83       	std	Z+7, r19	; 0x07
     c86:	82 81       	ldd	r24, Z+2	; 0x02
     c88:	93 81       	ldd	r25, Z+3	; 0x03
     c8a:	28 17       	cp	r18, r24
     c8c:	39 07       	cpc	r19, r25
     c8e:	20 f0       	brcs	.+8      	; 0xc98 <prvCopyDataFromQueue+0x28>
     c90:	80 81       	ld	r24, Z
     c92:	91 81       	ldd	r25, Z+1	; 0x01
     c94:	86 83       	std	Z+6, r24	; 0x06
     c96:	97 83       	std	Z+7, r25	; 0x07
     c98:	cb 01       	movw	r24, r22
     c9a:	66 81       	ldd	r22, Z+6	; 0x06
     c9c:	77 81       	ldd	r23, Z+7	; 0x07
     c9e:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <memcpy>
     ca2:	08 95       	ret

00000ca4 <prvUnlockQueue>:
     ca4:	ef 92       	push	r14
     ca6:	ff 92       	push	r15
     ca8:	0f 93       	push	r16
     caa:	1f 93       	push	r17
     cac:	cf 93       	push	r28
     cae:	8c 01       	movw	r16, r24
     cb0:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     cb4:	ff 93       	push	r31
     cb6:	f8 7f       	andi	r31, 0xF8	; 248
     cb8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     cbc:	fc 01       	movw	r30, r24
     cbe:	c2 a1       	ldd	r28, Z+34	; 0x22
     cc0:	1c 16       	cp	r1, r28
     cc2:	ac f4       	brge	.+42     	; 0xcee <prvUnlockQueue+0x4a>
     cc4:	83 89       	ldd	r24, Z+19	; 0x13
     cc6:	81 11       	cpse	r24, r1
     cc8:	06 c0       	rjmp	.+12     	; 0xcd6 <prvUnlockQueue+0x32>
     cca:	11 c0       	rjmp	.+34     	; 0xcee <prvUnlockQueue+0x4a>
     ccc:	f8 01       	movw	r30, r16
     cce:	83 89       	ldd	r24, Z+19	; 0x13
     cd0:	81 11       	cpse	r24, r1
     cd2:	05 c0       	rjmp	.+10     	; 0xcde <prvUnlockQueue+0x3a>
     cd4:	0c c0       	rjmp	.+24     	; 0xcee <prvUnlockQueue+0x4a>
     cd6:	78 01       	movw	r14, r16
     cd8:	f3 e1       	ldi	r31, 0x13	; 19
     cda:	ef 0e       	add	r14, r31
     cdc:	f1 1c       	adc	r15, r1
     cde:	c7 01       	movw	r24, r14
     ce0:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <xTaskRemoveFromEventList>
     ce4:	81 11       	cpse	r24, r1
     ce6:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <vTaskMissedYield>
     cea:	c1 50       	subi	r28, 0x01	; 1
     cec:	79 f7       	brne	.-34     	; 0xccc <prvUnlockQueue+0x28>
     cee:	8f ef       	ldi	r24, 0xFF	; 255
     cf0:	f8 01       	movw	r30, r16
     cf2:	82 a3       	std	Z+34, r24	; 0x22
     cf4:	ff 91       	pop	r31
     cf6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     cfa:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     cfe:	ff 93       	push	r31
     d00:	f8 7f       	andi	r31, 0xF8	; 248
     d02:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d06:	f8 01       	movw	r30, r16
     d08:	c1 a1       	ldd	r28, Z+33	; 0x21
     d0a:	1c 16       	cp	r1, r28
     d0c:	ac f4       	brge	.+42     	; 0xd38 <prvUnlockQueue+0x94>
     d0e:	80 85       	ldd	r24, Z+8	; 0x08
     d10:	81 11       	cpse	r24, r1
     d12:	06 c0       	rjmp	.+12     	; 0xd20 <prvUnlockQueue+0x7c>
     d14:	11 c0       	rjmp	.+34     	; 0xd38 <prvUnlockQueue+0x94>
     d16:	f8 01       	movw	r30, r16
     d18:	80 85       	ldd	r24, Z+8	; 0x08
     d1a:	81 11       	cpse	r24, r1
     d1c:	05 c0       	rjmp	.+10     	; 0xd28 <prvUnlockQueue+0x84>
     d1e:	0c c0       	rjmp	.+24     	; 0xd38 <prvUnlockQueue+0x94>
     d20:	78 01       	movw	r14, r16
     d22:	f8 e0       	ldi	r31, 0x08	; 8
     d24:	ef 0e       	add	r14, r31
     d26:	f1 1c       	adc	r15, r1
     d28:	c7 01       	movw	r24, r14
     d2a:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <xTaskRemoveFromEventList>
     d2e:	81 11       	cpse	r24, r1
     d30:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <vTaskMissedYield>
     d34:	c1 50       	subi	r28, 0x01	; 1
     d36:	79 f7       	brne	.-34     	; 0xd16 <prvUnlockQueue+0x72>
     d38:	8f ef       	ldi	r24, 0xFF	; 255
     d3a:	f8 01       	movw	r30, r16
     d3c:	81 a3       	std	Z+33, r24	; 0x21
     d3e:	ff 91       	pop	r31
     d40:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d44:	cf 91       	pop	r28
     d46:	1f 91       	pop	r17
     d48:	0f 91       	pop	r16
     d4a:	ff 90       	pop	r15
     d4c:	ef 90       	pop	r14
     d4e:	08 95       	ret

00000d50 <xQueueGenericReset>:
     d50:	cf 93       	push	r28
     d52:	df 93       	push	r29
     d54:	ec 01       	movw	r28, r24
     d56:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d5a:	ff 93       	push	r31
     d5c:	f8 7f       	andi	r31, 0xF8	; 248
     d5e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d62:	48 81       	ld	r20, Y
     d64:	59 81       	ldd	r21, Y+1	; 0x01
     d66:	28 a1       	ldd	r18, Y+32	; 0x20
     d68:	30 e0       	ldi	r19, 0x00	; 0
     d6a:	7f 8d       	ldd	r23, Y+31	; 0x1f
     d6c:	72 9f       	mul	r23, r18
     d6e:	c0 01       	movw	r24, r0
     d70:	73 9f       	mul	r23, r19
     d72:	90 0d       	add	r25, r0
     d74:	11 24       	eor	r1, r1
     d76:	fa 01       	movw	r30, r20
     d78:	e8 0f       	add	r30, r24
     d7a:	f9 1f       	adc	r31, r25
     d7c:	ea 83       	std	Y+2, r30	; 0x02
     d7e:	fb 83       	std	Y+3, r31	; 0x03
     d80:	1e 8e       	std	Y+30, r1	; 0x1e
     d82:	4c 83       	std	Y+4, r20	; 0x04
     d84:	5d 83       	std	Y+5, r21	; 0x05
     d86:	82 1b       	sub	r24, r18
     d88:	93 0b       	sbc	r25, r19
     d8a:	84 0f       	add	r24, r20
     d8c:	95 1f       	adc	r25, r21
     d8e:	8e 83       	std	Y+6, r24	; 0x06
     d90:	9f 83       	std	Y+7, r25	; 0x07
     d92:	8f ef       	ldi	r24, 0xFF	; 255
     d94:	89 a3       	std	Y+33, r24	; 0x21
     d96:	8a a3       	std	Y+34, r24	; 0x22
     d98:	61 11       	cpse	r22, r1
     d9a:	0c c0       	rjmp	.+24     	; 0xdb4 <xQueueGenericReset+0x64>
     d9c:	88 85       	ldd	r24, Y+8	; 0x08
     d9e:	88 23       	and	r24, r24
     da0:	89 f0       	breq	.+34     	; 0xdc4 <xQueueGenericReset+0x74>
     da2:	ce 01       	movw	r24, r28
     da4:	08 96       	adiw	r24, 0x08	; 8
     da6:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <xTaskRemoveFromEventList>
     daa:	88 23       	and	r24, r24
     dac:	59 f0       	breq	.+22     	; 0xdc4 <xQueueGenericReset+0x74>
     dae:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
     db2:	08 c0       	rjmp	.+16     	; 0xdc4 <xQueueGenericReset+0x74>
     db4:	ce 01       	movw	r24, r28
     db6:	08 96       	adiw	r24, 0x08	; 8
     db8:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
     dbc:	ce 01       	movw	r24, r28
     dbe:	43 96       	adiw	r24, 0x13	; 19
     dc0:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
     dc4:	ff 91       	pop	r31
     dc6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     dca:	81 e0       	ldi	r24, 0x01	; 1
     dcc:	df 91       	pop	r29
     dce:	cf 91       	pop	r28
     dd0:	08 95       	ret

00000dd2 <xQueueGenericCreate>:
     dd2:	ff 92       	push	r15
     dd4:	0f 93       	push	r16
     dd6:	1f 93       	push	r17
     dd8:	cf 93       	push	r28
     dda:	df 93       	push	r29
     ddc:	08 2f       	mov	r16, r24
     dde:	16 2f       	mov	r17, r22
     de0:	f4 2e       	mov	r15, r20
     de2:	66 23       	and	r22, r22
     de4:	c9 f0       	breq	.+50     	; 0xe18 <xQueueGenericCreate+0x46>
     de6:	86 9f       	mul	r24, r22
     de8:	c0 01       	movw	r24, r0
     dea:	11 24       	eor	r1, r1
     dec:	85 96       	adiw	r24, 0x25	; 37
     dee:	0e 94 49 03 	call	0x692	; 0x692 <pvPortMalloc>
     df2:	ec 01       	movw	r28, r24
     df4:	00 97       	sbiw	r24, 0x00	; 0
     df6:	49 f4       	brne	.+18     	; 0xe0a <xQueueGenericCreate+0x38>
     df8:	16 c0       	rjmp	.+44     	; 0xe26 <xQueueGenericCreate+0x54>
     dfa:	0f 8f       	std	Y+31, r16	; 0x1f
     dfc:	18 a3       	std	Y+32, r17	; 0x20
     dfe:	61 e0       	ldi	r22, 0x01	; 1
     e00:	ce 01       	movw	r24, r28
     e02:	0e 94 a8 06 	call	0xd50	; 0xd50 <xQueueGenericReset>
     e06:	fc a2       	std	Y+36, r15	; 0x24
     e08:	0e c0       	rjmp	.+28     	; 0xe26 <xQueueGenericCreate+0x54>
     e0a:	85 96       	adiw	r24, 0x25	; 37
     e0c:	88 83       	st	Y, r24
     e0e:	99 83       	std	Y+1, r25	; 0x01
     e10:	f4 cf       	rjmp	.-24     	; 0xdfa <xQueueGenericCreate+0x28>
     e12:	c8 83       	st	Y, r28
     e14:	d9 83       	std	Y+1, r29	; 0x01
     e16:	f1 cf       	rjmp	.-30     	; 0xdfa <xQueueGenericCreate+0x28>
     e18:	85 e2       	ldi	r24, 0x25	; 37
     e1a:	90 e0       	ldi	r25, 0x00	; 0
     e1c:	0e 94 49 03 	call	0x692	; 0x692 <pvPortMalloc>
     e20:	ec 01       	movw	r28, r24
     e22:	89 2b       	or	r24, r25
     e24:	b1 f7       	brne	.-20     	; 0xe12 <xQueueGenericCreate+0x40>
     e26:	ce 01       	movw	r24, r28
     e28:	df 91       	pop	r29
     e2a:	cf 91       	pop	r28
     e2c:	1f 91       	pop	r17
     e2e:	0f 91       	pop	r16
     e30:	ff 90       	pop	r15
     e32:	08 95       	ret

00000e34 <xQueueGenericSend>:
     e34:	af 92       	push	r10
     e36:	bf 92       	push	r11
     e38:	cf 92       	push	r12
     e3a:	df 92       	push	r13
     e3c:	ef 92       	push	r14
     e3e:	ff 92       	push	r15
     e40:	0f 93       	push	r16
     e42:	1f 93       	push	r17
     e44:	cf 93       	push	r28
     e46:	df 93       	push	r29
     e48:	cd b7       	in	r28, 0x3d	; 61
     e4a:	de b7       	in	r29, 0x3e	; 62
     e4c:	29 97       	sbiw	r28, 0x09	; 9
     e4e:	cd bf       	out	0x3d, r28	; 61
     e50:	de bf       	out	0x3e, r29	; 62
     e52:	7c 01       	movw	r14, r24
     e54:	5b 01       	movw	r10, r22
     e56:	2e 83       	std	Y+6, r18	; 0x06
     e58:	3f 83       	std	Y+7, r19	; 0x07
     e5a:	48 87       	std	Y+8, r20	; 0x08
     e5c:	59 87       	std	Y+9, r21	; 0x09
     e5e:	10 e0       	ldi	r17, 0x00	; 0
     e60:	6c 01       	movw	r12, r24
     e62:	88 e0       	ldi	r24, 0x08	; 8
     e64:	c8 0e       	add	r12, r24
     e66:	d1 1c       	adc	r13, r1
     e68:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e6c:	ff 93       	push	r31
     e6e:	f8 7f       	andi	r31, 0xF8	; 248
     e70:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e74:	f7 01       	movw	r30, r14
     e76:	96 8d       	ldd	r25, Z+30	; 0x1e
     e78:	87 8d       	ldd	r24, Z+31	; 0x1f
     e7a:	98 17       	cp	r25, r24
     e7c:	10 f0       	brcs	.+4      	; 0xe82 <xQueueGenericSend+0x4e>
     e7e:	02 30       	cpi	r16, 0x02	; 2
     e80:	d1 f4       	brne	.+52     	; 0xeb6 <xQueueGenericSend+0x82>
     e82:	40 2f       	mov	r20, r16
     e84:	b5 01       	movw	r22, r10
     e86:	c7 01       	movw	r24, r14
     e88:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <prvCopyDataToQueue>
     e8c:	f7 01       	movw	r30, r14
     e8e:	93 89       	ldd	r25, Z+19	; 0x13
     e90:	99 23       	and	r25, r25
     e92:	49 f0       	breq	.+18     	; 0xea6 <xQueueGenericSend+0x72>
     e94:	c7 01       	movw	r24, r14
     e96:	43 96       	adiw	r24, 0x13	; 19
     e98:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <xTaskRemoveFromEventList>
     e9c:	88 23       	and	r24, r24
     e9e:	31 f0       	breq	.+12     	; 0xeac <xQueueGenericSend+0x78>
     ea0:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
     ea4:	03 c0       	rjmp	.+6      	; 0xeac <xQueueGenericSend+0x78>
     ea6:	81 11       	cpse	r24, r1
     ea8:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
     eac:	ff 91       	pop	r31
     eae:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     eb2:	81 e0       	ldi	r24, 0x01	; 1
     eb4:	57 c0       	rjmp	.+174    	; 0xf64 <xQueueGenericSend+0x130>
     eb6:	8e 81       	ldd	r24, Y+6	; 0x06
     eb8:	9f 81       	ldd	r25, Y+7	; 0x07
     eba:	a8 85       	ldd	r26, Y+8	; 0x08
     ebc:	b9 85       	ldd	r27, Y+9	; 0x09
     ebe:	89 2b       	or	r24, r25
     ec0:	8a 2b       	or	r24, r26
     ec2:	8b 2b       	or	r24, r27
     ec4:	29 f4       	brne	.+10     	; 0xed0 <xQueueGenericSend+0x9c>
     ec6:	ff 91       	pop	r31
     ec8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ecc:	80 e0       	ldi	r24, 0x00	; 0
     ece:	4a c0       	rjmp	.+148    	; 0xf64 <xQueueGenericSend+0x130>
     ed0:	11 11       	cpse	r17, r1
     ed2:	05 c0       	rjmp	.+10     	; 0xede <xQueueGenericSend+0xaa>
     ed4:	ce 01       	movw	r24, r28
     ed6:	01 96       	adiw	r24, 0x01	; 1
     ed8:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <vTaskInternalSetTimeOutState>
     edc:	11 e0       	ldi	r17, 0x01	; 1
     ede:	ff 91       	pop	r31
     ee0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ee4:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <vTaskSuspendAll>
     ee8:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     eec:	ff 93       	push	r31
     eee:	f8 7f       	andi	r31, 0xF8	; 248
     ef0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ef4:	f7 01       	movw	r30, r14
     ef6:	81 a1       	ldd	r24, Z+33	; 0x21
     ef8:	8f 3f       	cpi	r24, 0xFF	; 255
     efa:	09 f4       	brne	.+2      	; 0xefe <xQueueGenericSend+0xca>
     efc:	11 a2       	std	Z+33, r1	; 0x21
     efe:	f7 01       	movw	r30, r14
     f00:	82 a1       	ldd	r24, Z+34	; 0x22
     f02:	8f 3f       	cpi	r24, 0xFF	; 255
     f04:	09 f4       	brne	.+2      	; 0xf08 <xQueueGenericSend+0xd4>
     f06:	12 a2       	std	Z+34, r1	; 0x22
     f08:	ff 91       	pop	r31
     f0a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f0e:	be 01       	movw	r22, r28
     f10:	6a 5f       	subi	r22, 0xFA	; 250
     f12:	7f 4f       	sbci	r23, 0xFF	; 255
     f14:	ce 01       	movw	r24, r28
     f16:	01 96       	adiw	r24, 0x01	; 1
     f18:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <xTaskCheckForTimeOut>
     f1c:	81 11       	cpse	r24, r1
     f1e:	1c c0       	rjmp	.+56     	; 0xf58 <xQueueGenericSend+0x124>
     f20:	c7 01       	movw	r24, r14
     f22:	0e 94 c6 05 	call	0xb8c	; 0xb8c <prvIsQueueFull>
     f26:	88 23       	and	r24, r24
     f28:	89 f0       	breq	.+34     	; 0xf4c <xQueueGenericSend+0x118>
     f2a:	4e 81       	ldd	r20, Y+6	; 0x06
     f2c:	5f 81       	ldd	r21, Y+7	; 0x07
     f2e:	68 85       	ldd	r22, Y+8	; 0x08
     f30:	79 85       	ldd	r23, Y+9	; 0x09
     f32:	c6 01       	movw	r24, r12
     f34:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vTaskPlaceOnEventList>
     f38:	c7 01       	movw	r24, r14
     f3a:	0e 94 52 06 	call	0xca4	; 0xca4 <prvUnlockQueue>
     f3e:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
     f42:	81 11       	cpse	r24, r1
     f44:	91 cf       	rjmp	.-222    	; 0xe68 <xQueueGenericSend+0x34>
     f46:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
     f4a:	8e cf       	rjmp	.-228    	; 0xe68 <xQueueGenericSend+0x34>
     f4c:	c7 01       	movw	r24, r14
     f4e:	0e 94 52 06 	call	0xca4	; 0xca4 <prvUnlockQueue>
     f52:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
     f56:	88 cf       	rjmp	.-240    	; 0xe68 <xQueueGenericSend+0x34>
     f58:	c7 01       	movw	r24, r14
     f5a:	0e 94 52 06 	call	0xca4	; 0xca4 <prvUnlockQueue>
     f5e:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
     f62:	80 e0       	ldi	r24, 0x00	; 0
     f64:	29 96       	adiw	r28, 0x09	; 9
     f66:	cd bf       	out	0x3d, r28	; 61
     f68:	de bf       	out	0x3e, r29	; 62
     f6a:	df 91       	pop	r29
     f6c:	cf 91       	pop	r28
     f6e:	1f 91       	pop	r17
     f70:	0f 91       	pop	r16
     f72:	ff 90       	pop	r15
     f74:	ef 90       	pop	r14
     f76:	df 90       	pop	r13
     f78:	cf 90       	pop	r12
     f7a:	bf 90       	pop	r11
     f7c:	af 90       	pop	r10
     f7e:	08 95       	ret

00000f80 <xQueueCreateMutex>:
     f80:	0f 93       	push	r16
     f82:	cf 93       	push	r28
     f84:	df 93       	push	r29
     f86:	48 2f       	mov	r20, r24
     f88:	60 e0       	ldi	r22, 0x00	; 0
     f8a:	81 e0       	ldi	r24, 0x01	; 1
     f8c:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <xQueueGenericCreate>
     f90:	ec 01       	movw	r28, r24
     f92:	00 97       	sbiw	r24, 0x00	; 0
     f94:	69 f0       	breq	.+26     	; 0xfb0 <xQueueCreateMutex+0x30>
     f96:	1a 82       	std	Y+2, r1	; 0x02
     f98:	1b 82       	std	Y+3, r1	; 0x03
     f9a:	18 82       	st	Y, r1
     f9c:	19 82       	std	Y+1, r1	; 0x01
     f9e:	1e 82       	std	Y+6, r1	; 0x06
     fa0:	00 e0       	ldi	r16, 0x00	; 0
     fa2:	20 e0       	ldi	r18, 0x00	; 0
     fa4:	30 e0       	ldi	r19, 0x00	; 0
     fa6:	a9 01       	movw	r20, r18
     fa8:	60 e0       	ldi	r22, 0x00	; 0
     faa:	70 e0       	ldi	r23, 0x00	; 0
     fac:	0e 94 1a 07 	call	0xe34	; 0xe34 <xQueueGenericSend>
     fb0:	ce 01       	movw	r24, r28
     fb2:	df 91       	pop	r29
     fb4:	cf 91       	pop	r28
     fb6:	0f 91       	pop	r16
     fb8:	08 95       	ret

00000fba <xQueueGenericSendFromISR>:
     fba:	af 92       	push	r10
     fbc:	bf 92       	push	r11
     fbe:	cf 92       	push	r12
     fc0:	df 92       	push	r13
     fc2:	ff 92       	push	r15
     fc4:	0f 93       	push	r16
     fc6:	1f 93       	push	r17
     fc8:	cf 93       	push	r28
     fca:	df 93       	push	r29
     fcc:	ec 01       	movw	r28, r24
     fce:	6b 01       	movw	r12, r22
     fd0:	5a 01       	movw	r10, r20
     fd2:	02 2f       	mov	r16, r18
     fd4:	0e 94 0a 04 	call	0x814	; 0x814 <_portSetInterruptMaskFromIsr>
     fd8:	f8 2e       	mov	r15, r24
     fda:	9e 8d       	ldd	r25, Y+30	; 0x1e
     fdc:	8f 8d       	ldd	r24, Y+31	; 0x1f
     fde:	98 17       	cp	r25, r24
     fe0:	10 f0       	brcs	.+4      	; 0xfe6 <xQueueGenericSendFromISR+0x2c>
     fe2:	02 30       	cpi	r16, 0x02	; 2
     fe4:	e1 f4       	brne	.+56     	; 0x101e <xQueueGenericSendFromISR+0x64>
     fe6:	1a a1       	ldd	r17, Y+34	; 0x22
     fe8:	40 2f       	mov	r20, r16
     fea:	b6 01       	movw	r22, r12
     fec:	ce 01       	movw	r24, r28
     fee:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <prvCopyDataToQueue>
     ff2:	1f 3f       	cpi	r17, 0xFF	; 255
     ff4:	81 f4       	brne	.+32     	; 0x1016 <xQueueGenericSendFromISR+0x5c>
     ff6:	8b 89       	ldd	r24, Y+19	; 0x13
     ff8:	88 23       	and	r24, r24
     ffa:	99 f0       	breq	.+38     	; 0x1022 <xQueueGenericSendFromISR+0x68>
     ffc:	ce 01       	movw	r24, r28
     ffe:	43 96       	adiw	r24, 0x13	; 19
    1000:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <xTaskRemoveFromEventList>
    1004:	88 23       	and	r24, r24
    1006:	79 f0       	breq	.+30     	; 0x1026 <xQueueGenericSendFromISR+0x6c>
    1008:	a1 14       	cp	r10, r1
    100a:	b1 04       	cpc	r11, r1
    100c:	71 f0       	breq	.+28     	; 0x102a <xQueueGenericSendFromISR+0x70>
    100e:	81 e0       	ldi	r24, 0x01	; 1
    1010:	f5 01       	movw	r30, r10
    1012:	80 83       	st	Z, r24
    1014:	0b c0       	rjmp	.+22     	; 0x102c <xQueueGenericSendFromISR+0x72>
    1016:	1f 5f       	subi	r17, 0xFF	; 255
    1018:	1a a3       	std	Y+34, r17	; 0x22
    101a:	81 e0       	ldi	r24, 0x01	; 1
    101c:	07 c0       	rjmp	.+14     	; 0x102c <xQueueGenericSendFromISR+0x72>
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	05 c0       	rjmp	.+10     	; 0x102c <xQueueGenericSendFromISR+0x72>
    1022:	81 e0       	ldi	r24, 0x01	; 1
    1024:	03 c0       	rjmp	.+6      	; 0x102c <xQueueGenericSendFromISR+0x72>
    1026:	81 e0       	ldi	r24, 0x01	; 1
    1028:	01 c0       	rjmp	.+2      	; 0x102c <xQueueGenericSendFromISR+0x72>
    102a:	81 e0       	ldi	r24, 0x01	; 1
    102c:	f0 92 a2 00 	sts	0x00A2, r15	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1030:	df 91       	pop	r29
    1032:	cf 91       	pop	r28
    1034:	1f 91       	pop	r17
    1036:	0f 91       	pop	r16
    1038:	ff 90       	pop	r15
    103a:	df 90       	pop	r13
    103c:	cf 90       	pop	r12
    103e:	bf 90       	pop	r11
    1040:	af 90       	pop	r10
    1042:	08 95       	ret

00001044 <xQueueReceive>:
    1044:	af 92       	push	r10
    1046:	bf 92       	push	r11
    1048:	cf 92       	push	r12
    104a:	df 92       	push	r13
    104c:	ef 92       	push	r14
    104e:	ff 92       	push	r15
    1050:	0f 93       	push	r16
    1052:	1f 93       	push	r17
    1054:	cf 93       	push	r28
    1056:	df 93       	push	r29
    1058:	cd b7       	in	r28, 0x3d	; 61
    105a:	de b7       	in	r29, 0x3e	; 62
    105c:	29 97       	sbiw	r28, 0x09	; 9
    105e:	cd bf       	out	0x3d, r28	; 61
    1060:	de bf       	out	0x3e, r29	; 62
    1062:	8c 01       	movw	r16, r24
    1064:	5b 01       	movw	r10, r22
    1066:	2e 83       	std	Y+6, r18	; 0x06
    1068:	3f 83       	std	Y+7, r19	; 0x07
    106a:	48 87       	std	Y+8, r20	; 0x08
    106c:	59 87       	std	Y+9, r21	; 0x09
    106e:	e1 2c       	mov	r14, r1
    1070:	6c 01       	movw	r12, r24
    1072:	83 e1       	ldi	r24, 0x13	; 19
    1074:	c8 0e       	add	r12, r24
    1076:	d1 1c       	adc	r13, r1
    1078:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    107c:	ff 93       	push	r31
    107e:	f8 7f       	andi	r31, 0xF8	; 248
    1080:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1084:	f8 01       	movw	r30, r16
    1086:	f6 8c       	ldd	r15, Z+30	; 0x1e
    1088:	ff 20       	and	r15, r15
    108a:	b1 f0       	breq	.+44     	; 0x10b8 <xQueueReceive+0x74>
    108c:	b5 01       	movw	r22, r10
    108e:	c8 01       	movw	r24, r16
    1090:	0e 94 38 06 	call	0xc70	; 0xc70 <prvCopyDataFromQueue>
    1094:	fa 94       	dec	r15
    1096:	f8 01       	movw	r30, r16
    1098:	f6 8e       	std	Z+30, r15	; 0x1e
    109a:	80 85       	ldd	r24, Z+8	; 0x08
    109c:	88 23       	and	r24, r24
    109e:	39 f0       	breq	.+14     	; 0x10ae <xQueueReceive+0x6a>
    10a0:	c8 01       	movw	r24, r16
    10a2:	08 96       	adiw	r24, 0x08	; 8
    10a4:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <xTaskRemoveFromEventList>
    10a8:	81 11       	cpse	r24, r1
    10aa:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
    10ae:	ff 91       	pop	r31
    10b0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10b4:	81 e0       	ldi	r24, 0x01	; 1
    10b6:	5e c0       	rjmp	.+188    	; 0x1174 <xQueueReceive+0x130>
    10b8:	8e 81       	ldd	r24, Y+6	; 0x06
    10ba:	9f 81       	ldd	r25, Y+7	; 0x07
    10bc:	a8 85       	ldd	r26, Y+8	; 0x08
    10be:	b9 85       	ldd	r27, Y+9	; 0x09
    10c0:	89 2b       	or	r24, r25
    10c2:	8a 2b       	or	r24, r26
    10c4:	8b 2b       	or	r24, r27
    10c6:	29 f4       	brne	.+10     	; 0x10d2 <xQueueReceive+0x8e>
    10c8:	ff 91       	pop	r31
    10ca:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10ce:	80 e0       	ldi	r24, 0x00	; 0
    10d0:	51 c0       	rjmp	.+162    	; 0x1174 <xQueueReceive+0x130>
    10d2:	e1 10       	cpse	r14, r1
    10d4:	06 c0       	rjmp	.+12     	; 0x10e2 <xQueueReceive+0x9e>
    10d6:	ce 01       	movw	r24, r28
    10d8:	01 96       	adiw	r24, 0x01	; 1
    10da:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <vTaskInternalSetTimeOutState>
    10de:	ee 24       	eor	r14, r14
    10e0:	e3 94       	inc	r14
    10e2:	ff 91       	pop	r31
    10e4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10e8:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <vTaskSuspendAll>
    10ec:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10f0:	ff 93       	push	r31
    10f2:	f8 7f       	andi	r31, 0xF8	; 248
    10f4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10f8:	f8 01       	movw	r30, r16
    10fa:	81 a1       	ldd	r24, Z+33	; 0x21
    10fc:	8f 3f       	cpi	r24, 0xFF	; 255
    10fe:	09 f4       	brne	.+2      	; 0x1102 <xQueueReceive+0xbe>
    1100:	11 a2       	std	Z+33, r1	; 0x21
    1102:	f8 01       	movw	r30, r16
    1104:	82 a1       	ldd	r24, Z+34	; 0x22
    1106:	8f 3f       	cpi	r24, 0xFF	; 255
    1108:	09 f4       	brne	.+2      	; 0x110c <xQueueReceive+0xc8>
    110a:	12 a2       	std	Z+34, r1	; 0x22
    110c:	ff 91       	pop	r31
    110e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1112:	be 01       	movw	r22, r28
    1114:	6a 5f       	subi	r22, 0xFA	; 250
    1116:	7f 4f       	sbci	r23, 0xFF	; 255
    1118:	ce 01       	movw	r24, r28
    111a:	01 96       	adiw	r24, 0x01	; 1
    111c:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <xTaskCheckForTimeOut>
    1120:	81 11       	cpse	r24, r1
    1122:	1c c0       	rjmp	.+56     	; 0x115c <xQueueReceive+0x118>
    1124:	c8 01       	movw	r24, r16
    1126:	0e 94 b7 05 	call	0xb6e	; 0xb6e <prvIsQueueEmpty>
    112a:	88 23       	and	r24, r24
    112c:	89 f0       	breq	.+34     	; 0x1150 <xQueueReceive+0x10c>
    112e:	4e 81       	ldd	r20, Y+6	; 0x06
    1130:	5f 81       	ldd	r21, Y+7	; 0x07
    1132:	68 85       	ldd	r22, Y+8	; 0x08
    1134:	79 85       	ldd	r23, Y+9	; 0x09
    1136:	c6 01       	movw	r24, r12
    1138:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vTaskPlaceOnEventList>
    113c:	c8 01       	movw	r24, r16
    113e:	0e 94 52 06 	call	0xca4	; 0xca4 <prvUnlockQueue>
    1142:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
    1146:	81 11       	cpse	r24, r1
    1148:	97 cf       	rjmp	.-210    	; 0x1078 <xQueueReceive+0x34>
    114a:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
    114e:	94 cf       	rjmp	.-216    	; 0x1078 <xQueueReceive+0x34>
    1150:	c8 01       	movw	r24, r16
    1152:	0e 94 52 06 	call	0xca4	; 0xca4 <prvUnlockQueue>
    1156:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
    115a:	8e cf       	rjmp	.-228    	; 0x1078 <xQueueReceive+0x34>
    115c:	c8 01       	movw	r24, r16
    115e:	0e 94 52 06 	call	0xca4	; 0xca4 <prvUnlockQueue>
    1162:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
    1166:	c8 01       	movw	r24, r16
    1168:	0e 94 b7 05 	call	0xb6e	; 0xb6e <prvIsQueueEmpty>
    116c:	88 23       	and	r24, r24
    116e:	09 f4       	brne	.+2      	; 0x1172 <xQueueReceive+0x12e>
    1170:	83 cf       	rjmp	.-250    	; 0x1078 <xQueueReceive+0x34>
    1172:	80 e0       	ldi	r24, 0x00	; 0
    1174:	29 96       	adiw	r28, 0x09	; 9
    1176:	cd bf       	out	0x3d, r28	; 61
    1178:	de bf       	out	0x3e, r29	; 62
    117a:	df 91       	pop	r29
    117c:	cf 91       	pop	r28
    117e:	1f 91       	pop	r17
    1180:	0f 91       	pop	r16
    1182:	ff 90       	pop	r15
    1184:	ef 90       	pop	r14
    1186:	df 90       	pop	r13
    1188:	cf 90       	pop	r12
    118a:	bf 90       	pop	r11
    118c:	af 90       	pop	r10
    118e:	08 95       	ret

00001190 <xQueueSemaphoreTake>:
    1190:	cf 92       	push	r12
    1192:	df 92       	push	r13
    1194:	ef 92       	push	r14
    1196:	ff 92       	push	r15
    1198:	0f 93       	push	r16
    119a:	1f 93       	push	r17
    119c:	cf 93       	push	r28
    119e:	df 93       	push	r29
    11a0:	cd b7       	in	r28, 0x3d	; 61
    11a2:	de b7       	in	r29, 0x3e	; 62
    11a4:	29 97       	sbiw	r28, 0x09	; 9
    11a6:	cd bf       	out	0x3d, r28	; 61
    11a8:	de bf       	out	0x3e, r29	; 62
    11aa:	8c 01       	movw	r16, r24
    11ac:	4e 83       	std	Y+6, r20	; 0x06
    11ae:	5f 83       	std	Y+7, r21	; 0x07
    11b0:	68 87       	std	Y+8, r22	; 0x08
    11b2:	79 87       	std	Y+9, r23	; 0x09
    11b4:	c1 2c       	mov	r12, r1
    11b6:	d1 2c       	mov	r13, r1
    11b8:	7c 01       	movw	r14, r24
    11ba:	83 e1       	ldi	r24, 0x13	; 19
    11bc:	e8 0e       	add	r14, r24
    11be:	f1 1c       	adc	r15, r1
    11c0:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11c4:	ff 93       	push	r31
    11c6:	f8 7f       	andi	r31, 0xF8	; 248
    11c8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11cc:	d8 01       	movw	r26, r16
    11ce:	5e 96       	adiw	r26, 0x1e	; 30
    11d0:	8c 91       	ld	r24, X
    11d2:	5e 97       	sbiw	r26, 0x1e	; 30
    11d4:	88 23       	and	r24, r24
    11d6:	f1 f0       	breq	.+60     	; 0x1214 <xQueueSemaphoreTake+0x84>
    11d8:	81 50       	subi	r24, 0x01	; 1
    11da:	5e 96       	adiw	r26, 0x1e	; 30
    11dc:	8c 93       	st	X, r24
    11de:	5e 97       	sbiw	r26, 0x1e	; 30
    11e0:	8d 91       	ld	r24, X+
    11e2:	9c 91       	ld	r25, X
    11e4:	89 2b       	or	r24, r25
    11e6:	29 f4       	brne	.+10     	; 0x11f2 <xQueueSemaphoreTake+0x62>
    11e8:	0e 94 65 10 	call	0x20ca	; 0x20ca <pvTaskIncrementMutexHeldCount>
    11ec:	f8 01       	movw	r30, r16
    11ee:	82 83       	std	Z+2, r24	; 0x02
    11f0:	93 83       	std	Z+3, r25	; 0x03
    11f2:	d8 01       	movw	r26, r16
    11f4:	18 96       	adiw	r26, 0x08	; 8
    11f6:	8c 91       	ld	r24, X
    11f8:	88 23       	and	r24, r24
    11fa:	39 f0       	breq	.+14     	; 0x120a <xQueueSemaphoreTake+0x7a>
    11fc:	c8 01       	movw	r24, r16
    11fe:	08 96       	adiw	r24, 0x08	; 8
    1200:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <xTaskRemoveFromEventList>
    1204:	81 11       	cpse	r24, r1
    1206:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
    120a:	ff 91       	pop	r31
    120c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1210:	81 e0       	ldi	r24, 0x01	; 1
    1212:	97 c0       	rjmp	.+302    	; 0x1342 <xQueueSemaphoreTake+0x1b2>
    1214:	8e 81       	ldd	r24, Y+6	; 0x06
    1216:	9f 81       	ldd	r25, Y+7	; 0x07
    1218:	a8 85       	ldd	r26, Y+8	; 0x08
    121a:	b9 85       	ldd	r27, Y+9	; 0x09
    121c:	89 2b       	or	r24, r25
    121e:	8a 2b       	or	r24, r26
    1220:	8b 2b       	or	r24, r27
    1222:	29 f4       	brne	.+10     	; 0x122e <xQueueSemaphoreTake+0x9e>
    1224:	ff 91       	pop	r31
    1226:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    122a:	80 e0       	ldi	r24, 0x00	; 0
    122c:	8a c0       	rjmp	.+276    	; 0x1342 <xQueueSemaphoreTake+0x1b2>
    122e:	d1 10       	cpse	r13, r1
    1230:	06 c0       	rjmp	.+12     	; 0x123e <xQueueSemaphoreTake+0xae>
    1232:	ce 01       	movw	r24, r28
    1234:	01 96       	adiw	r24, 0x01	; 1
    1236:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <vTaskInternalSetTimeOutState>
    123a:	dd 24       	eor	r13, r13
    123c:	d3 94       	inc	r13
    123e:	ff 91       	pop	r31
    1240:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1244:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <vTaskSuspendAll>
    1248:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    124c:	ff 93       	push	r31
    124e:	f8 7f       	andi	r31, 0xF8	; 248
    1250:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1254:	f8 01       	movw	r30, r16
    1256:	81 a1       	ldd	r24, Z+33	; 0x21
    1258:	8f 3f       	cpi	r24, 0xFF	; 255
    125a:	09 f4       	brne	.+2      	; 0x125e <xQueueSemaphoreTake+0xce>
    125c:	11 a2       	std	Z+33, r1	; 0x21
    125e:	d8 01       	movw	r26, r16
    1260:	92 96       	adiw	r26, 0x22	; 34
    1262:	8c 91       	ld	r24, X
    1264:	92 97       	sbiw	r26, 0x22	; 34
    1266:	8f 3f       	cpi	r24, 0xFF	; 255
    1268:	11 f4       	brne	.+4      	; 0x126e <xQueueSemaphoreTake+0xde>
    126a:	92 96       	adiw	r26, 0x22	; 34
    126c:	1c 92       	st	X, r1
    126e:	ff 91       	pop	r31
    1270:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1274:	be 01       	movw	r22, r28
    1276:	6a 5f       	subi	r22, 0xFA	; 250
    1278:	7f 4f       	sbci	r23, 0xFF	; 255
    127a:	ce 01       	movw	r24, r28
    127c:	01 96       	adiw	r24, 0x01	; 1
    127e:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <xTaskCheckForTimeOut>
    1282:	81 11       	cpse	r24, r1
    1284:	32 c0       	rjmp	.+100    	; 0x12ea <xQueueSemaphoreTake+0x15a>
    1286:	c8 01       	movw	r24, r16
    1288:	0e 94 b7 05 	call	0xb6e	; 0xb6e <prvIsQueueEmpty>
    128c:	88 23       	and	r24, r24
    128e:	39 f1       	breq	.+78     	; 0x12de <xQueueSemaphoreTake+0x14e>
    1290:	f8 01       	movw	r30, r16
    1292:	80 81       	ld	r24, Z
    1294:	91 81       	ldd	r25, Z+1	; 0x01
    1296:	89 2b       	or	r24, r25
    1298:	89 f4       	brne	.+34     	; 0x12bc <xQueueSemaphoreTake+0x12c>
    129a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    129e:	ff 93       	push	r31
    12a0:	f8 7f       	andi	r31, 0xF8	; 248
    12a2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12a6:	d8 01       	movw	r26, r16
    12a8:	12 96       	adiw	r26, 0x02	; 2
    12aa:	8d 91       	ld	r24, X+
    12ac:	9c 91       	ld	r25, X
    12ae:	13 97       	sbiw	r26, 0x03	; 3
    12b0:	0e 94 43 0f 	call	0x1e86	; 0x1e86 <xTaskPriorityInherit>
    12b4:	c8 2e       	mov	r12, r24
    12b6:	ff 91       	pop	r31
    12b8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12bc:	4e 81       	ldd	r20, Y+6	; 0x06
    12be:	5f 81       	ldd	r21, Y+7	; 0x07
    12c0:	68 85       	ldd	r22, Y+8	; 0x08
    12c2:	79 85       	ldd	r23, Y+9	; 0x09
    12c4:	c7 01       	movw	r24, r14
    12c6:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vTaskPlaceOnEventList>
    12ca:	c8 01       	movw	r24, r16
    12cc:	0e 94 52 06 	call	0xca4	; 0xca4 <prvUnlockQueue>
    12d0:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
    12d4:	81 11       	cpse	r24, r1
    12d6:	74 cf       	rjmp	.-280    	; 0x11c0 <xQueueSemaphoreTake+0x30>
    12d8:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
    12dc:	71 cf       	rjmp	.-286    	; 0x11c0 <xQueueSemaphoreTake+0x30>
    12de:	c8 01       	movw	r24, r16
    12e0:	0e 94 52 06 	call	0xca4	; 0xca4 <prvUnlockQueue>
    12e4:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
    12e8:	6b cf       	rjmp	.-298    	; 0x11c0 <xQueueSemaphoreTake+0x30>
    12ea:	c8 01       	movw	r24, r16
    12ec:	0e 94 52 06 	call	0xca4	; 0xca4 <prvUnlockQueue>
    12f0:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
    12f4:	c8 01       	movw	r24, r16
    12f6:	0e 94 b7 05 	call	0xb6e	; 0xb6e <prvIsQueueEmpty>
    12fa:	88 23       	and	r24, r24
    12fc:	09 f4       	brne	.+2      	; 0x1300 <xQueueSemaphoreTake+0x170>
    12fe:	60 cf       	rjmp	.-320    	; 0x11c0 <xQueueSemaphoreTake+0x30>
    1300:	cc 20       	and	r12, r12
    1302:	f1 f0       	breq	.+60     	; 0x1340 <xQueueSemaphoreTake+0x1b0>
    1304:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1308:	ff 93       	push	r31
    130a:	f8 7f       	andi	r31, 0xF8	; 248
    130c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1310:	f8 01       	movw	r30, r16
    1312:	83 89       	ldd	r24, Z+19	; 0x13
    1314:	88 23       	and	r24, r24
    1316:	39 f0       	breq	.+14     	; 0x1326 <xQueueSemaphoreTake+0x196>
    1318:	02 8c       	ldd	r0, Z+26	; 0x1a
    131a:	f3 8d       	ldd	r31, Z+27	; 0x1b
    131c:	e0 2d       	mov	r30, r0
    131e:	80 81       	ld	r24, Z
    1320:	64 e0       	ldi	r22, 0x04	; 4
    1322:	68 1b       	sub	r22, r24
    1324:	01 c0       	rjmp	.+2      	; 0x1328 <xQueueSemaphoreTake+0x198>
    1326:	60 e0       	ldi	r22, 0x00	; 0
    1328:	d8 01       	movw	r26, r16
    132a:	12 96       	adiw	r26, 0x02	; 2
    132c:	8d 91       	ld	r24, X+
    132e:	9c 91       	ld	r25, X
    1330:	13 97       	sbiw	r26, 0x03	; 3
    1332:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <vTaskPriorityDisinheritAfterTimeout>
    1336:	ff 91       	pop	r31
    1338:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    133c:	80 e0       	ldi	r24, 0x00	; 0
    133e:	01 c0       	rjmp	.+2      	; 0x1342 <xQueueSemaphoreTake+0x1b2>
    1340:	80 e0       	ldi	r24, 0x00	; 0
    1342:	29 96       	adiw	r28, 0x09	; 9
    1344:	cd bf       	out	0x3d, r28	; 61
    1346:	de bf       	out	0x3e, r29	; 62
    1348:	df 91       	pop	r29
    134a:	cf 91       	pop	r28
    134c:	1f 91       	pop	r17
    134e:	0f 91       	pop	r16
    1350:	ff 90       	pop	r15
    1352:	ef 90       	pop	r14
    1354:	df 90       	pop	r13
    1356:	cf 90       	pop	r12
    1358:	08 95       	ret

0000135a <uxQueueMessagesWaiting>:
    135a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    135e:	ff 93       	push	r31
    1360:	f8 7f       	andi	r31, 0xF8	; 248
    1362:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1366:	fc 01       	movw	r30, r24
    1368:	86 8d       	ldd	r24, Z+30	; 0x1e
    136a:	ff 91       	pop	r31
    136c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1370:	08 95       	ret

00001372 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    1372:	cf 93       	push	r28
    1374:	df 93       	push	r29
    1376:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1378:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    137c:	ff 93       	push	r31
    137e:	f8 7f       	andi	r31, 0xF8	; 248
    1380:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1384:	89 a1       	ldd	r24, Y+33	; 0x21
    1386:	8f 3f       	cpi	r24, 0xFF	; 255
    1388:	09 f4       	brne	.+2      	; 0x138c <vQueueWaitForMessageRestricted+0x1a>
    138a:	19 a2       	std	Y+33, r1	; 0x21
    138c:	8a a1       	ldd	r24, Y+34	; 0x22
    138e:	8f 3f       	cpi	r24, 0xFF	; 255
    1390:	09 f4       	brne	.+2      	; 0x1394 <vQueueWaitForMessageRestricted+0x22>
    1392:	1a a2       	std	Y+34, r1	; 0x22
    1394:	ff 91       	pop	r31
    1396:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    139a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    139c:	81 11       	cpse	r24, r1
    139e:	04 c0       	rjmp	.+8      	; 0x13a8 <vQueueWaitForMessageRestricted+0x36>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    13a0:	ce 01       	movw	r24, r28
    13a2:	43 96       	adiw	r24, 0x13	; 19
    13a4:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    13a8:	ce 01       	movw	r24, r28
    13aa:	0e 94 52 06 	call	0xca4	; 0xca4 <prvUnlockQueue>
	}
    13ae:	df 91       	pop	r29
    13b0:	cf 91       	pop	r28
    13b2:	08 95       	ret

000013b4 <prvResetNextTaskUnblockTime>:
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
    13b4:	e0 91 34 2c 	lds	r30, 0x2C34	; 0x802c34 <pxDelayedTaskList>
    13b8:	f0 91 35 2c 	lds	r31, 0x2C35	; 0x802c35 <pxDelayedTaskList+0x1>
    13bc:	80 81       	ld	r24, Z
    13be:	81 11       	cpse	r24, r1
    13c0:	0c c0       	rjmp	.+24     	; 0x13da <prvResetNextTaskUnblockTime+0x26>
    13c2:	8f ef       	ldi	r24, 0xFF	; 255
    13c4:	9f ef       	ldi	r25, 0xFF	; 255
    13c6:	dc 01       	movw	r26, r24
    13c8:	80 93 0d 2c 	sts	0x2C0D, r24	; 0x802c0d <xNextTaskUnblockTime>
    13cc:	90 93 0e 2c 	sts	0x2C0E, r25	; 0x802c0e <xNextTaskUnblockTime+0x1>
    13d0:	a0 93 0f 2c 	sts	0x2C0F, r26	; 0x802c0f <xNextTaskUnblockTime+0x2>
    13d4:	b0 93 10 2c 	sts	0x2C10, r27	; 0x802c10 <xNextTaskUnblockTime+0x3>
    13d8:	08 95       	ret
    13da:	e0 91 34 2c 	lds	r30, 0x2C34	; 0x802c34 <pxDelayedTaskList>
    13de:	f0 91 35 2c 	lds	r31, 0x2C35	; 0x802c35 <pxDelayedTaskList+0x1>
    13e2:	07 80       	ldd	r0, Z+7	; 0x07
    13e4:	f0 85       	ldd	r31, Z+8	; 0x08
    13e6:	e0 2d       	mov	r30, r0
    13e8:	00 84       	ldd	r0, Z+8	; 0x08
    13ea:	f1 85       	ldd	r31, Z+9	; 0x09
    13ec:	e0 2d       	mov	r30, r0
    13ee:	82 81       	ldd	r24, Z+2	; 0x02
    13f0:	93 81       	ldd	r25, Z+3	; 0x03
    13f2:	a4 81       	ldd	r26, Z+4	; 0x04
    13f4:	b5 81       	ldd	r27, Z+5	; 0x05
    13f6:	80 93 0d 2c 	sts	0x2C0D, r24	; 0x802c0d <xNextTaskUnblockTime>
    13fa:	90 93 0e 2c 	sts	0x2C0E, r25	; 0x802c0e <xNextTaskUnblockTime+0x1>
    13fe:	a0 93 0f 2c 	sts	0x2C0F, r26	; 0x802c0f <xNextTaskUnblockTime+0x2>
    1402:	b0 93 10 2c 	sts	0x2C10, r27	; 0x802c10 <xNextTaskUnblockTime+0x3>
    1406:	08 95       	ret

00001408 <prvAddCurrentTaskToDelayedList>:
    1408:	8f 92       	push	r8
    140a:	9f 92       	push	r9
    140c:	af 92       	push	r10
    140e:	bf 92       	push	r11
    1410:	cf 92       	push	r12
    1412:	df 92       	push	r13
    1414:	ef 92       	push	r14
    1416:	ff 92       	push	r15
    1418:	cf 93       	push	r28
    141a:	6b 01       	movw	r12, r22
    141c:	7c 01       	movw	r14, r24
    141e:	c4 2f       	mov	r28, r20
    1420:	80 90 17 2c 	lds	r8, 0x2C17	; 0x802c17 <xTickCount>
    1424:	90 90 18 2c 	lds	r9, 0x2C18	; 0x802c18 <xTickCount+0x1>
    1428:	a0 90 19 2c 	lds	r10, 0x2C19	; 0x802c19 <xTickCount+0x2>
    142c:	b0 90 1a 2c 	lds	r11, 0x2C1A	; 0x802c1a <xTickCount+0x3>
    1430:	80 91 78 2c 	lds	r24, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1434:	90 91 79 2c 	lds	r25, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1438:	02 96       	adiw	r24, 0x02	; 2
    143a:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
    143e:	8f ef       	ldi	r24, 0xFF	; 255
    1440:	c8 16       	cp	r12, r24
    1442:	d8 06       	cpc	r13, r24
    1444:	e8 06       	cpc	r14, r24
    1446:	f8 06       	cpc	r15, r24
    1448:	69 f4       	brne	.+26     	; 0x1464 <prvAddCurrentTaskToDelayedList+0x5c>
    144a:	cc 23       	and	r28, r28
    144c:	59 f0       	breq	.+22     	; 0x1464 <prvAddCurrentTaskToDelayedList+0x5c>
    144e:	60 91 78 2c 	lds	r22, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1452:	70 91 79 2c 	lds	r23, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1456:	6e 5f       	subi	r22, 0xFE	; 254
    1458:	7f 4f       	sbci	r23, 0xFF	; 255
    145a:	8c e1       	ldi	r24, 0x1C	; 28
    145c:	9c e2       	ldi	r25, 0x2C	; 44
    145e:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsertEnd>
    1462:	3f c0       	rjmp	.+126    	; 0x14e2 <prvAddCurrentTaskToDelayedList+0xda>
    1464:	c8 0c       	add	r12, r8
    1466:	d9 1c       	adc	r13, r9
    1468:	ea 1c       	adc	r14, r10
    146a:	fb 1c       	adc	r15, r11
    146c:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1470:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1474:	c2 82       	std	Z+2, r12	; 0x02
    1476:	d3 82       	std	Z+3, r13	; 0x03
    1478:	e4 82       	std	Z+4, r14	; 0x04
    147a:	f5 82       	std	Z+5, r15	; 0x05
    147c:	c8 14       	cp	r12, r8
    147e:	d9 04       	cpc	r13, r9
    1480:	ea 04       	cpc	r14, r10
    1482:	fb 04       	cpc	r15, r11
    1484:	68 f4       	brcc	.+26     	; 0x14a0 <prvAddCurrentTaskToDelayedList+0x98>
    1486:	60 91 78 2c 	lds	r22, 0x2C78	; 0x802c78 <pxCurrentTCB>
    148a:	70 91 79 2c 	lds	r23, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    148e:	80 91 32 2c 	lds	r24, 0x2C32	; 0x802c32 <pxOverflowDelayedTaskList>
    1492:	90 91 33 2c 	lds	r25, 0x2C33	; 0x802c33 <pxOverflowDelayedTaskList+0x1>
    1496:	6e 5f       	subi	r22, 0xFE	; 254
    1498:	7f 4f       	sbci	r23, 0xFF	; 255
    149a:	0e 94 a6 03 	call	0x74c	; 0x74c <vListInsert>
    149e:	21 c0       	rjmp	.+66     	; 0x14e2 <prvAddCurrentTaskToDelayedList+0xda>
    14a0:	60 91 78 2c 	lds	r22, 0x2C78	; 0x802c78 <pxCurrentTCB>
    14a4:	70 91 79 2c 	lds	r23, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    14a8:	80 91 34 2c 	lds	r24, 0x2C34	; 0x802c34 <pxDelayedTaskList>
    14ac:	90 91 35 2c 	lds	r25, 0x2C35	; 0x802c35 <pxDelayedTaskList+0x1>
    14b0:	6e 5f       	subi	r22, 0xFE	; 254
    14b2:	7f 4f       	sbci	r23, 0xFF	; 255
    14b4:	0e 94 a6 03 	call	0x74c	; 0x74c <vListInsert>
    14b8:	80 91 0d 2c 	lds	r24, 0x2C0D	; 0x802c0d <xNextTaskUnblockTime>
    14bc:	90 91 0e 2c 	lds	r25, 0x2C0E	; 0x802c0e <xNextTaskUnblockTime+0x1>
    14c0:	a0 91 0f 2c 	lds	r26, 0x2C0F	; 0x802c0f <xNextTaskUnblockTime+0x2>
    14c4:	b0 91 10 2c 	lds	r27, 0x2C10	; 0x802c10 <xNextTaskUnblockTime+0x3>
    14c8:	c8 16       	cp	r12, r24
    14ca:	d9 06       	cpc	r13, r25
    14cc:	ea 06       	cpc	r14, r26
    14ce:	fb 06       	cpc	r15, r27
    14d0:	40 f4       	brcc	.+16     	; 0x14e2 <prvAddCurrentTaskToDelayedList+0xda>
    14d2:	c0 92 0d 2c 	sts	0x2C0D, r12	; 0x802c0d <xNextTaskUnblockTime>
    14d6:	d0 92 0e 2c 	sts	0x2C0E, r13	; 0x802c0e <xNextTaskUnblockTime+0x1>
    14da:	e0 92 0f 2c 	sts	0x2C0F, r14	; 0x802c0f <xNextTaskUnblockTime+0x2>
    14de:	f0 92 10 2c 	sts	0x2C10, r15	; 0x802c10 <xNextTaskUnblockTime+0x3>
    14e2:	cf 91       	pop	r28
    14e4:	ff 90       	pop	r15
    14e6:	ef 90       	pop	r14
    14e8:	df 90       	pop	r13
    14ea:	cf 90       	pop	r12
    14ec:	bf 90       	pop	r11
    14ee:	af 90       	pop	r10
    14f0:	9f 90       	pop	r9
    14f2:	8f 90       	pop	r8
    14f4:	08 95       	ret

000014f6 <prvIdleTask>:
    14f6:	cc e4       	ldi	r28, 0x4C	; 76
    14f8:	dc e2       	ldi	r29, 0x2C	; 44
    14fa:	88 81       	ld	r24, Y
    14fc:	82 30       	cpi	r24, 0x02	; 2
    14fe:	10 f0       	brcs	.+4      	; 0x1504 <prvIdleTask+0xe>
    1500:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
    1504:	0e 94 c5 14 	call	0x298a	; 0x298a <vApplicationIdleHook>
    1508:	f8 cf       	rjmp	.-16     	; 0x14fa <prvIdleTask+0x4>

0000150a <xTaskCreate>:
    150a:	4f 92       	push	r4
    150c:	5f 92       	push	r5
    150e:	6f 92       	push	r6
    1510:	7f 92       	push	r7
    1512:	8f 92       	push	r8
    1514:	9f 92       	push	r9
    1516:	af 92       	push	r10
    1518:	bf 92       	push	r11
    151a:	cf 92       	push	r12
    151c:	df 92       	push	r13
    151e:	ef 92       	push	r14
    1520:	ff 92       	push	r15
    1522:	0f 93       	push	r16
    1524:	cf 93       	push	r28
    1526:	df 93       	push	r29
    1528:	4c 01       	movw	r8, r24
    152a:	6b 01       	movw	r12, r22
    152c:	5a 01       	movw	r10, r20
    152e:	29 01       	movw	r4, r18
    1530:	ca 01       	movw	r24, r20
    1532:	0e 94 49 03 	call	0x692	; 0x692 <pvPortMalloc>
    1536:	3c 01       	movw	r6, r24
    1538:	89 2b       	or	r24, r25
    153a:	09 f4       	brne	.+2      	; 0x153e <xTaskCreate+0x34>
    153c:	ec c0       	rjmp	.+472    	; 0x1716 <xTaskCreate+0x20c>
    153e:	8e e2       	ldi	r24, 0x2E	; 46
    1540:	90 e0       	ldi	r25, 0x00	; 0
    1542:	0e 94 49 03 	call	0x692	; 0x692 <pvPortMalloc>
    1546:	ec 01       	movw	r28, r24
    1548:	89 2b       	or	r24, r25
    154a:	b1 f0       	breq	.+44     	; 0x1578 <xTaskCreate+0x6e>
    154c:	6b 8e       	std	Y+27, r6	; 0x1b
    154e:	7c 8e       	std	Y+28, r7	; 0x1c
    1550:	a5 01       	movw	r20, r10
    1552:	65 ea       	ldi	r22, 0xA5	; 165
    1554:	70 e0       	ldi	r23, 0x00	; 0
    1556:	c3 01       	movw	r24, r6
    1558:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <memset>
    155c:	21 e0       	ldi	r18, 0x01	; 1
    155e:	a2 1a       	sub	r10, r18
    1560:	b1 08       	sbc	r11, r1
    1562:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1564:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1566:	a8 0e       	add	r10, r24
    1568:	b9 1e       	adc	r11, r25
    156a:	d6 01       	movw	r26, r12
    156c:	8c 91       	ld	r24, X
    156e:	8d 8f       	std	Y+29, r24	; 0x1d
    1570:	8c 91       	ld	r24, X
    1572:	81 11       	cpse	r24, r1
    1574:	05 c0       	rjmp	.+10     	; 0x1580 <xTaskCreate+0x76>
    1576:	18 c0       	rjmp	.+48     	; 0x15a8 <xTaskCreate+0x9e>
    1578:	c3 01       	movw	r24, r6
    157a:	0e 94 6f 03 	call	0x6de	; 0x6de <vPortFree>
    157e:	cb c0       	rjmp	.+406    	; 0x1716 <xTaskCreate+0x20c>
    1580:	ae 01       	movw	r20, r28
    1582:	42 5e       	subi	r20, 0xE2	; 226
    1584:	5f 4f       	sbci	r21, 0xFF	; 255
    1586:	f6 01       	movw	r30, r12
    1588:	31 96       	adiw	r30, 0x01	; 1
    158a:	b8 e0       	ldi	r27, 0x08	; 8
    158c:	cb 0e       	add	r12, r27
    158e:	d1 1c       	adc	r13, r1
    1590:	cf 01       	movw	r24, r30
    1592:	21 91       	ld	r18, Z+
    1594:	da 01       	movw	r26, r20
    1596:	2d 93       	st	X+, r18
    1598:	ad 01       	movw	r20, r26
    159a:	dc 01       	movw	r26, r24
    159c:	8c 91       	ld	r24, X
    159e:	88 23       	and	r24, r24
    15a0:	19 f0       	breq	.+6      	; 0x15a8 <xTaskCreate+0x9e>
    15a2:	ec 15       	cp	r30, r12
    15a4:	fd 05       	cpc	r31, r13
    15a6:	a1 f7       	brne	.-24     	; 0x1590 <xTaskCreate+0x86>
    15a8:	1c a2       	std	Y+36, r1	; 0x24
    15aa:	04 30       	cpi	r16, 0x04	; 4
    15ac:	08 f0       	brcs	.+2      	; 0x15b0 <xTaskCreate+0xa6>
    15ae:	03 e0       	ldi	r16, 0x03	; 3
    15b0:	0a 8f       	std	Y+26, r16	; 0x1a
    15b2:	0f a3       	std	Y+39, r16	; 0x27
    15b4:	18 a6       	std	Y+40, r1	; 0x28
    15b6:	6e 01       	movw	r12, r28
    15b8:	b2 e0       	ldi	r27, 0x02	; 2
    15ba:	cb 0e       	add	r12, r27
    15bc:	d1 1c       	adc	r13, r1
    15be:	c6 01       	movw	r24, r12
    15c0:	0e 94 81 03 	call	0x702	; 0x702 <vListInitialiseItem>
    15c4:	ce 01       	movw	r24, r28
    15c6:	0e 96       	adiw	r24, 0x0e	; 14
    15c8:	0e 94 81 03 	call	0x702	; 0x702 <vListInitialiseItem>
    15cc:	ca 87       	std	Y+10, r28	; 0x0a
    15ce:	db 87       	std	Y+11, r29	; 0x0b
    15d0:	84 e0       	ldi	r24, 0x04	; 4
    15d2:	90 e0       	ldi	r25, 0x00	; 0
    15d4:	a0 e0       	ldi	r26, 0x00	; 0
    15d6:	b0 e0       	ldi	r27, 0x00	; 0
    15d8:	80 1b       	sub	r24, r16
    15da:	91 09       	sbc	r25, r1
    15dc:	a1 09       	sbc	r26, r1
    15de:	b1 09       	sbc	r27, r1
    15e0:	8e 87       	std	Y+14, r24	; 0x0e
    15e2:	9f 87       	std	Y+15, r25	; 0x0f
    15e4:	a8 8b       	std	Y+16, r26	; 0x10
    15e6:	b9 8b       	std	Y+17, r27	; 0x11
    15e8:	ce 8b       	std	Y+22, r28	; 0x16
    15ea:	df 8b       	std	Y+23, r29	; 0x17
    15ec:	19 a6       	std	Y+41, r1	; 0x29
    15ee:	1a a6       	std	Y+42, r1	; 0x2a
    15f0:	1b a6       	std	Y+43, r1	; 0x2b
    15f2:	1c a6       	std	Y+44, r1	; 0x2c
    15f4:	1d a6       	std	Y+45, r1	; 0x2d
    15f6:	a2 01       	movw	r20, r4
    15f8:	b4 01       	movw	r22, r8
    15fa:	c5 01       	movw	r24, r10
    15fc:	0e 94 11 04 	call	0x822	; 0x822 <pxPortInitialiseStack>
    1600:	88 83       	st	Y, r24
    1602:	99 83       	std	Y+1, r25	; 0x01
    1604:	e1 14       	cp	r14, r1
    1606:	f1 04       	cpc	r15, r1
    1608:	19 f0       	breq	.+6      	; 0x1610 <xTaskCreate+0x106>
    160a:	f7 01       	movw	r30, r14
    160c:	c0 83       	st	Z, r28
    160e:	d1 83       	std	Z+1, r29	; 0x01
    1610:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1614:	ff 93       	push	r31
    1616:	f8 7f       	andi	r31, 0xF8	; 248
    1618:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    161c:	80 91 1b 2c 	lds	r24, 0x2C1B	; 0x802c1b <uxCurrentNumberOfTasks>
    1620:	8f 5f       	subi	r24, 0xFF	; 255
    1622:	80 93 1b 2c 	sts	0x2C1B, r24	; 0x802c1b <uxCurrentNumberOfTasks>
    1626:	80 91 78 2c 	lds	r24, 0x2C78	; 0x802c78 <pxCurrentTCB>
    162a:	90 91 79 2c 	lds	r25, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    162e:	89 2b       	or	r24, r25
    1630:	a9 f5       	brne	.+106    	; 0x169c <xTaskCreate+0x192>
    1632:	c0 93 78 2c 	sts	0x2C78, r28	; 0x802c78 <pxCurrentTCB>
    1636:	d0 93 79 2c 	sts	0x2C79, r29	; 0x802c79 <pxCurrentTCB+0x1>
    163a:	80 91 1b 2c 	lds	r24, 0x2C1B	; 0x802c1b <uxCurrentNumberOfTasks>
    163e:	81 30       	cpi	r24, 0x01	; 1
    1640:	e9 f5       	brne	.+122    	; 0x16bc <xTaskCreate+0x1b2>
    1642:	8c e4       	ldi	r24, 0x4C	; 76
    1644:	9c e2       	ldi	r25, 0x2C	; 44
    1646:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
    164a:	87 e5       	ldi	r24, 0x57	; 87
    164c:	9c e2       	ldi	r25, 0x2C	; 44
    164e:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
    1652:	82 e6       	ldi	r24, 0x62	; 98
    1654:	9c e2       	ldi	r25, 0x2C	; 44
    1656:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
    165a:	8d e6       	ldi	r24, 0x6D	; 109
    165c:	9c e2       	ldi	r25, 0x2C	; 44
    165e:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
    1662:	81 e4       	ldi	r24, 0x41	; 65
    1664:	9c e2       	ldi	r25, 0x2C	; 44
    1666:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
    166a:	86 e3       	ldi	r24, 0x36	; 54
    166c:	9c e2       	ldi	r25, 0x2C	; 44
    166e:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
    1672:	87 e2       	ldi	r24, 0x27	; 39
    1674:	9c e2       	ldi	r25, 0x2C	; 44
    1676:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
    167a:	8c e1       	ldi	r24, 0x1C	; 28
    167c:	9c e2       	ldi	r25, 0x2C	; 44
    167e:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
    1682:	81 e4       	ldi	r24, 0x41	; 65
    1684:	9c e2       	ldi	r25, 0x2C	; 44
    1686:	80 93 34 2c 	sts	0x2C34, r24	; 0x802c34 <pxDelayedTaskList>
    168a:	90 93 35 2c 	sts	0x2C35, r25	; 0x802c35 <pxDelayedTaskList+0x1>
    168e:	86 e3       	ldi	r24, 0x36	; 54
    1690:	9c e2       	ldi	r25, 0x2C	; 44
    1692:	80 93 32 2c 	sts	0x2C32, r24	; 0x802c32 <pxOverflowDelayedTaskList>
    1696:	90 93 33 2c 	sts	0x2C33, r25	; 0x802c33 <pxOverflowDelayedTaskList+0x1>
    169a:	10 c0       	rjmp	.+32     	; 0x16bc <xTaskCreate+0x1b2>
    169c:	80 91 15 2c 	lds	r24, 0x2C15	; 0x802c15 <xSchedulerRunning>
    16a0:	81 11       	cpse	r24, r1
    16a2:	0c c0       	rjmp	.+24     	; 0x16bc <xTaskCreate+0x1b2>
    16a4:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    16a8:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    16ac:	92 8d       	ldd	r25, Z+26	; 0x1a
    16ae:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16b0:	89 17       	cp	r24, r25
    16b2:	20 f0       	brcs	.+8      	; 0x16bc <xTaskCreate+0x1b2>
    16b4:	c0 93 78 2c 	sts	0x2C78, r28	; 0x802c78 <pxCurrentTCB>
    16b8:	d0 93 79 2c 	sts	0x2C79, r29	; 0x802c79 <pxCurrentTCB+0x1>
    16bc:	80 91 11 2c 	lds	r24, 0x2C11	; 0x802c11 <uxTaskNumber>
    16c0:	8f 5f       	subi	r24, 0xFF	; 255
    16c2:	80 93 11 2c 	sts	0x2C11, r24	; 0x802c11 <uxTaskNumber>
    16c6:	8d a3       	std	Y+37, r24	; 0x25
    16c8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16ca:	90 91 16 2c 	lds	r25, 0x2C16	; 0x802c16 <uxTopReadyPriority>
    16ce:	98 17       	cp	r25, r24
    16d0:	10 f4       	brcc	.+4      	; 0x16d6 <xTaskCreate+0x1cc>
    16d2:	80 93 16 2c 	sts	0x2C16, r24	; 0x802c16 <uxTopReadyPriority>
    16d6:	fb e0       	ldi	r31, 0x0B	; 11
    16d8:	8f 9f       	mul	r24, r31
    16da:	c0 01       	movw	r24, r0
    16dc:	11 24       	eor	r1, r1
    16de:	b6 01       	movw	r22, r12
    16e0:	84 5b       	subi	r24, 0xB4	; 180
    16e2:	93 4d       	sbci	r25, 0xD3	; 211
    16e4:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsertEnd>
    16e8:	ff 91       	pop	r31
    16ea:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    16ee:	80 91 15 2c 	lds	r24, 0x2C15	; 0x802c15 <xSchedulerRunning>
    16f2:	88 23       	and	r24, r24
    16f4:	61 f0       	breq	.+24     	; 0x170e <xTaskCreate+0x204>
    16f6:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    16fa:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    16fe:	92 8d       	ldd	r25, Z+26	; 0x1a
    1700:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1702:	98 17       	cp	r25, r24
    1704:	30 f4       	brcc	.+12     	; 0x1712 <xTaskCreate+0x208>
    1706:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
    170a:	81 e0       	ldi	r24, 0x01	; 1
    170c:	05 c0       	rjmp	.+10     	; 0x1718 <xTaskCreate+0x20e>
    170e:	81 e0       	ldi	r24, 0x01	; 1
    1710:	03 c0       	rjmp	.+6      	; 0x1718 <xTaskCreate+0x20e>
    1712:	81 e0       	ldi	r24, 0x01	; 1
    1714:	01 c0       	rjmp	.+2      	; 0x1718 <xTaskCreate+0x20e>
    1716:	8f ef       	ldi	r24, 0xFF	; 255
    1718:	df 91       	pop	r29
    171a:	cf 91       	pop	r28
    171c:	0f 91       	pop	r16
    171e:	ff 90       	pop	r15
    1720:	ef 90       	pop	r14
    1722:	df 90       	pop	r13
    1724:	cf 90       	pop	r12
    1726:	bf 90       	pop	r11
    1728:	af 90       	pop	r10
    172a:	9f 90       	pop	r9
    172c:	8f 90       	pop	r8
    172e:	7f 90       	pop	r7
    1730:	6f 90       	pop	r6
    1732:	5f 90       	pop	r5
    1734:	4f 90       	pop	r4
    1736:	08 95       	ret

00001738 <vTaskStartScheduler>:
    1738:	ef 92       	push	r14
    173a:	ff 92       	push	r15
    173c:	0f 93       	push	r16
    173e:	0f 2e       	mov	r0, r31
    1740:	fb e0       	ldi	r31, 0x0B	; 11
    1742:	ef 2e       	mov	r14, r31
    1744:	fc e2       	ldi	r31, 0x2C	; 44
    1746:	ff 2e       	mov	r15, r31
    1748:	f0 2d       	mov	r31, r0
    174a:	00 e0       	ldi	r16, 0x00	; 0
    174c:	20 e0       	ldi	r18, 0x00	; 0
    174e:	30 e0       	ldi	r19, 0x00	; 0
    1750:	48 ec       	ldi	r20, 0xC8	; 200
    1752:	50 e0       	ldi	r21, 0x00	; 0
    1754:	60 e0       	ldi	r22, 0x00	; 0
    1756:	70 e2       	ldi	r23, 0x20	; 32
    1758:	8b e7       	ldi	r24, 0x7B	; 123
    175a:	9a e0       	ldi	r25, 0x0A	; 10
    175c:	0e 94 85 0a 	call	0x150a	; 0x150a <xTaskCreate>
    1760:	81 30       	cpi	r24, 0x01	; 1
    1762:	09 f5       	brne	.+66     	; 0x17a6 <vTaskStartScheduler+0x6e>
    1764:	0e 94 ed 10 	call	0x21da	; 0x21da <xTimerCreateTimerTask>
    1768:	81 30       	cpi	r24, 0x01	; 1
    176a:	e9 f4       	brne	.+58     	; 0x17a6 <vTaskStartScheduler+0x6e>
    176c:	e0 ea       	ldi	r30, 0xA0	; 160
    176e:	f0 e0       	ldi	r31, 0x00	; 0
    1770:	82 81       	ldd	r24, Z+2	; 0x02
    1772:	88 7f       	andi	r24, 0xF8	; 248
    1774:	82 83       	std	Z+2, r24	; 0x02
    1776:	8f ef       	ldi	r24, 0xFF	; 255
    1778:	9f ef       	ldi	r25, 0xFF	; 255
    177a:	dc 01       	movw	r26, r24
    177c:	80 93 0d 2c 	sts	0x2C0D, r24	; 0x802c0d <xNextTaskUnblockTime>
    1780:	90 93 0e 2c 	sts	0x2C0E, r25	; 0x802c0e <xNextTaskUnblockTime+0x1>
    1784:	a0 93 0f 2c 	sts	0x2C0F, r26	; 0x802c0f <xNextTaskUnblockTime+0x2>
    1788:	b0 93 10 2c 	sts	0x2C10, r27	; 0x802c10 <xNextTaskUnblockTime+0x3>
    178c:	81 e0       	ldi	r24, 0x01	; 1
    178e:	80 93 15 2c 	sts	0x2C15, r24	; 0x802c15 <xSchedulerRunning>
    1792:	10 92 17 2c 	sts	0x2C17, r1	; 0x802c17 <xTickCount>
    1796:	10 92 18 2c 	sts	0x2C18, r1	; 0x802c18 <xTickCount+0x1>
    179a:	10 92 19 2c 	sts	0x2C19, r1	; 0x802c19 <xTickCount+0x2>
    179e:	10 92 1a 2c 	sts	0x2C1A, r1	; 0x802c1a <xTickCount+0x3>
    17a2:	0e 94 8e 04 	call	0x91c	; 0x91c <xPortStartScheduler>
    17a6:	0f 91       	pop	r16
    17a8:	ff 90       	pop	r15
    17aa:	ef 90       	pop	r14
    17ac:	08 95       	ret

000017ae <vTaskSuspendAll>:
    17ae:	80 91 0a 2c 	lds	r24, 0x2C0A	; 0x802c0a <uxSchedulerSuspended>
    17b2:	8f 5f       	subi	r24, 0xFF	; 255
    17b4:	80 93 0a 2c 	sts	0x2C0A, r24	; 0x802c0a <uxSchedulerSuspended>
    17b8:	08 95       	ret

000017ba <xTaskGetTickCount>:
    17ba:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    17be:	ff 93       	push	r31
    17c0:	f8 7f       	andi	r31, 0xF8	; 248
    17c2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    17c6:	60 91 17 2c 	lds	r22, 0x2C17	; 0x802c17 <xTickCount>
    17ca:	70 91 18 2c 	lds	r23, 0x2C18	; 0x802c18 <xTickCount+0x1>
    17ce:	80 91 19 2c 	lds	r24, 0x2C19	; 0x802c19 <xTickCount+0x2>
    17d2:	90 91 1a 2c 	lds	r25, 0x2C1A	; 0x802c1a <xTickCount+0x3>
    17d6:	ff 91       	pop	r31
    17d8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    17dc:	08 95       	ret

000017de <xTaskIncrementTick>:
    17de:	af 92       	push	r10
    17e0:	bf 92       	push	r11
    17e2:	cf 92       	push	r12
    17e4:	df 92       	push	r13
    17e6:	ef 92       	push	r14
    17e8:	ff 92       	push	r15
    17ea:	0f 93       	push	r16
    17ec:	1f 93       	push	r17
    17ee:	cf 93       	push	r28
    17f0:	df 93       	push	r29
    17f2:	80 91 0a 2c 	lds	r24, 0x2C0A	; 0x802c0a <uxSchedulerSuspended>
    17f6:	81 11       	cpse	r24, r1
    17f8:	ad c0       	rjmp	.+346    	; 0x1954 <xTaskIncrementTick+0x176>
    17fa:	c0 90 17 2c 	lds	r12, 0x2C17	; 0x802c17 <xTickCount>
    17fe:	d0 90 18 2c 	lds	r13, 0x2C18	; 0x802c18 <xTickCount+0x1>
    1802:	e0 90 19 2c 	lds	r14, 0x2C19	; 0x802c19 <xTickCount+0x2>
    1806:	f0 90 1a 2c 	lds	r15, 0x2C1A	; 0x802c1a <xTickCount+0x3>
    180a:	8f ef       	ldi	r24, 0xFF	; 255
    180c:	c8 1a       	sub	r12, r24
    180e:	d8 0a       	sbc	r13, r24
    1810:	e8 0a       	sbc	r14, r24
    1812:	f8 0a       	sbc	r15, r24
    1814:	c0 92 17 2c 	sts	0x2C17, r12	; 0x802c17 <xTickCount>
    1818:	d0 92 18 2c 	sts	0x2C18, r13	; 0x802c18 <xTickCount+0x1>
    181c:	e0 92 19 2c 	sts	0x2C19, r14	; 0x802c19 <xTickCount+0x2>
    1820:	f0 92 1a 2c 	sts	0x2C1A, r15	; 0x802c1a <xTickCount+0x3>
    1824:	c1 14       	cp	r12, r1
    1826:	d1 04       	cpc	r13, r1
    1828:	e1 04       	cpc	r14, r1
    182a:	f1 04       	cpc	r15, r1
    182c:	b9 f4       	brne	.+46     	; 0x185c <xTaskIncrementTick+0x7e>
    182e:	80 91 34 2c 	lds	r24, 0x2C34	; 0x802c34 <pxDelayedTaskList>
    1832:	90 91 35 2c 	lds	r25, 0x2C35	; 0x802c35 <pxDelayedTaskList+0x1>
    1836:	20 91 32 2c 	lds	r18, 0x2C32	; 0x802c32 <pxOverflowDelayedTaskList>
    183a:	30 91 33 2c 	lds	r19, 0x2C33	; 0x802c33 <pxOverflowDelayedTaskList+0x1>
    183e:	20 93 34 2c 	sts	0x2C34, r18	; 0x802c34 <pxDelayedTaskList>
    1842:	30 93 35 2c 	sts	0x2C35, r19	; 0x802c35 <pxDelayedTaskList+0x1>
    1846:	80 93 32 2c 	sts	0x2C32, r24	; 0x802c32 <pxOverflowDelayedTaskList>
    184a:	90 93 33 2c 	sts	0x2C33, r25	; 0x802c33 <pxOverflowDelayedTaskList+0x1>
    184e:	80 91 12 2c 	lds	r24, 0x2C12	; 0x802c12 <xNumOfOverflows>
    1852:	8f 5f       	subi	r24, 0xFF	; 255
    1854:	80 93 12 2c 	sts	0x2C12, r24	; 0x802c12 <xNumOfOverflows>
    1858:	0e 94 da 09 	call	0x13b4	; 0x13b4 <prvResetNextTaskUnblockTime>
    185c:	80 91 0d 2c 	lds	r24, 0x2C0D	; 0x802c0d <xNextTaskUnblockTime>
    1860:	90 91 0e 2c 	lds	r25, 0x2C0E	; 0x802c0e <xNextTaskUnblockTime+0x1>
    1864:	a0 91 0f 2c 	lds	r26, 0x2C0F	; 0x802c0f <xNextTaskUnblockTime+0x2>
    1868:	b0 91 10 2c 	lds	r27, 0x2C10	; 0x802c10 <xNextTaskUnblockTime+0x3>
    186c:	c8 16       	cp	r12, r24
    186e:	d9 06       	cpc	r13, r25
    1870:	ea 06       	cpc	r14, r26
    1872:	fb 06       	cpc	r15, r27
    1874:	10 f4       	brcc	.+4      	; 0x187a <xTaskIncrementTick+0x9c>
    1876:	b1 2c       	mov	r11, r1
    1878:	5c c0       	rjmp	.+184    	; 0x1932 <xTaskIncrementTick+0x154>
    187a:	b1 2c       	mov	r11, r1
    187c:	0f 2e       	mov	r0, r31
    187e:	fb e0       	ldi	r31, 0x0B	; 11
    1880:	af 2e       	mov	r10, r31
    1882:	f0 2d       	mov	r31, r0
    1884:	e0 91 34 2c 	lds	r30, 0x2C34	; 0x802c34 <pxDelayedTaskList>
    1888:	f0 91 35 2c 	lds	r31, 0x2C35	; 0x802c35 <pxDelayedTaskList+0x1>
    188c:	80 81       	ld	r24, Z
    188e:	81 11       	cpse	r24, r1
    1890:	0c c0       	rjmp	.+24     	; 0x18aa <xTaskIncrementTick+0xcc>
    1892:	8f ef       	ldi	r24, 0xFF	; 255
    1894:	9f ef       	ldi	r25, 0xFF	; 255
    1896:	dc 01       	movw	r26, r24
    1898:	80 93 0d 2c 	sts	0x2C0D, r24	; 0x802c0d <xNextTaskUnblockTime>
    189c:	90 93 0e 2c 	sts	0x2C0E, r25	; 0x802c0e <xNextTaskUnblockTime+0x1>
    18a0:	a0 93 0f 2c 	sts	0x2C0F, r26	; 0x802c0f <xNextTaskUnblockTime+0x2>
    18a4:	b0 93 10 2c 	sts	0x2C10, r27	; 0x802c10 <xNextTaskUnblockTime+0x3>
    18a8:	44 c0       	rjmp	.+136    	; 0x1932 <xTaskIncrementTick+0x154>
    18aa:	e0 91 34 2c 	lds	r30, 0x2C34	; 0x802c34 <pxDelayedTaskList>
    18ae:	f0 91 35 2c 	lds	r31, 0x2C35	; 0x802c35 <pxDelayedTaskList+0x1>
    18b2:	07 80       	ldd	r0, Z+7	; 0x07
    18b4:	f0 85       	ldd	r31, Z+8	; 0x08
    18b6:	e0 2d       	mov	r30, r0
    18b8:	c0 85       	ldd	r28, Z+8	; 0x08
    18ba:	d1 85       	ldd	r29, Z+9	; 0x09
    18bc:	8a 81       	ldd	r24, Y+2	; 0x02
    18be:	9b 81       	ldd	r25, Y+3	; 0x03
    18c0:	ac 81       	ldd	r26, Y+4	; 0x04
    18c2:	bd 81       	ldd	r27, Y+5	; 0x05
    18c4:	c8 16       	cp	r12, r24
    18c6:	d9 06       	cpc	r13, r25
    18c8:	ea 06       	cpc	r14, r26
    18ca:	fb 06       	cpc	r15, r27
    18cc:	48 f4       	brcc	.+18     	; 0x18e0 <xTaskIncrementTick+0x102>
    18ce:	80 93 0d 2c 	sts	0x2C0D, r24	; 0x802c0d <xNextTaskUnblockTime>
    18d2:	90 93 0e 2c 	sts	0x2C0E, r25	; 0x802c0e <xNextTaskUnblockTime+0x1>
    18d6:	a0 93 0f 2c 	sts	0x2C0F, r26	; 0x802c0f <xNextTaskUnblockTime+0x2>
    18da:	b0 93 10 2c 	sts	0x2C10, r27	; 0x802c10 <xNextTaskUnblockTime+0x3>
    18de:	29 c0       	rjmp	.+82     	; 0x1932 <xTaskIncrementTick+0x154>
    18e0:	8e 01       	movw	r16, r28
    18e2:	0e 5f       	subi	r16, 0xFE	; 254
    18e4:	1f 4f       	sbci	r17, 0xFF	; 255
    18e6:	c8 01       	movw	r24, r16
    18e8:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
    18ec:	88 8d       	ldd	r24, Y+24	; 0x18
    18ee:	99 8d       	ldd	r25, Y+25	; 0x19
    18f0:	89 2b       	or	r24, r25
    18f2:	21 f0       	breq	.+8      	; 0x18fc <xTaskIncrementTick+0x11e>
    18f4:	ce 01       	movw	r24, r28
    18f6:	0e 96       	adiw	r24, 0x0e	; 14
    18f8:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
    18fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    18fe:	90 91 16 2c 	lds	r25, 0x2C16	; 0x802c16 <uxTopReadyPriority>
    1902:	98 17       	cp	r25, r24
    1904:	10 f4       	brcc	.+4      	; 0x190a <xTaskIncrementTick+0x12c>
    1906:	80 93 16 2c 	sts	0x2C16, r24	; 0x802c16 <uxTopReadyPriority>
    190a:	a8 9e       	mul	r10, r24
    190c:	c0 01       	movw	r24, r0
    190e:	11 24       	eor	r1, r1
    1910:	b8 01       	movw	r22, r16
    1912:	84 5b       	subi	r24, 0xB4	; 180
    1914:	93 4d       	sbci	r25, 0xD3	; 211
    1916:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsertEnd>
    191a:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    191e:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1922:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1924:	82 8d       	ldd	r24, Z+26	; 0x1a
    1926:	98 17       	cp	r25, r24
    1928:	08 f4       	brcc	.+2      	; 0x192c <xTaskIncrementTick+0x14e>
    192a:	ac cf       	rjmp	.-168    	; 0x1884 <xTaskIncrementTick+0xa6>
    192c:	bb 24       	eor	r11, r11
    192e:	b3 94       	inc	r11
    1930:	a9 cf       	rjmp	.-174    	; 0x1884 <xTaskIncrementTick+0xa6>
    1932:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1936:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    193a:	e2 8d       	ldd	r30, Z+26	; 0x1a
    193c:	8b e0       	ldi	r24, 0x0B	; 11
    193e:	e8 9f       	mul	r30, r24
    1940:	f0 01       	movw	r30, r0
    1942:	11 24       	eor	r1, r1
    1944:	e4 5b       	subi	r30, 0xB4	; 180
    1946:	f3 4d       	sbci	r31, 0xD3	; 211
    1948:	80 81       	ld	r24, Z
    194a:	82 30       	cpi	r24, 0x02	; 2
    194c:	48 f0       	brcs	.+18     	; 0x1960 <xTaskIncrementTick+0x182>
    194e:	bb 24       	eor	r11, r11
    1950:	b3 94       	inc	r11
    1952:	06 c0       	rjmp	.+12     	; 0x1960 <xTaskIncrementTick+0x182>
    1954:	80 91 14 2c 	lds	r24, 0x2C14	; 0x802c14 <uxPendedTicks>
    1958:	8f 5f       	subi	r24, 0xFF	; 255
    195a:	80 93 14 2c 	sts	0x2C14, r24	; 0x802c14 <uxPendedTicks>
    195e:	b1 2c       	mov	r11, r1
    1960:	80 91 13 2c 	lds	r24, 0x2C13	; 0x802c13 <xYieldPending>
    1964:	88 23       	and	r24, r24
    1966:	11 f0       	breq	.+4      	; 0x196c <xTaskIncrementTick+0x18e>
    1968:	bb 24       	eor	r11, r11
    196a:	b3 94       	inc	r11
    196c:	8b 2d       	mov	r24, r11
    196e:	df 91       	pop	r29
    1970:	cf 91       	pop	r28
    1972:	1f 91       	pop	r17
    1974:	0f 91       	pop	r16
    1976:	ff 90       	pop	r15
    1978:	ef 90       	pop	r14
    197a:	df 90       	pop	r13
    197c:	cf 90       	pop	r12
    197e:	bf 90       	pop	r11
    1980:	af 90       	pop	r10
    1982:	08 95       	ret

00001984 <xTaskResumeAll>:
    1984:	cf 92       	push	r12
    1986:	df 92       	push	r13
    1988:	ef 92       	push	r14
    198a:	ff 92       	push	r15
    198c:	0f 93       	push	r16
    198e:	1f 93       	push	r17
    1990:	cf 93       	push	r28
    1992:	df 93       	push	r29
    1994:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1998:	ff 93       	push	r31
    199a:	f8 7f       	andi	r31, 0xF8	; 248
    199c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    19a0:	80 91 0a 2c 	lds	r24, 0x2C0A	; 0x802c0a <uxSchedulerSuspended>
    19a4:	81 50       	subi	r24, 0x01	; 1
    19a6:	80 93 0a 2c 	sts	0x2C0A, r24	; 0x802c0a <uxSchedulerSuspended>
    19aa:	80 91 0a 2c 	lds	r24, 0x2C0A	; 0x802c0a <uxSchedulerSuspended>
    19ae:	81 11       	cpse	r24, r1
    19b0:	5c c0       	rjmp	.+184    	; 0x1a6a <xTaskResumeAll+0xe6>
    19b2:	80 91 1b 2c 	lds	r24, 0x2C1B	; 0x802c1b <uxCurrentNumberOfTasks>
    19b6:	81 11       	cpse	r24, r1
    19b8:	2c c0       	rjmp	.+88     	; 0x1a12 <xTaskResumeAll+0x8e>
    19ba:	5a c0       	rjmp	.+180    	; 0x1a70 <xTaskResumeAll+0xec>
    19bc:	d7 01       	movw	r26, r14
    19be:	17 96       	adiw	r26, 0x07	; 7
    19c0:	ed 91       	ld	r30, X+
    19c2:	fc 91       	ld	r31, X
    19c4:	18 97       	sbiw	r26, 0x08	; 8
    19c6:	c0 85       	ldd	r28, Z+8	; 0x08
    19c8:	d1 85       	ldd	r29, Z+9	; 0x09
    19ca:	ce 01       	movw	r24, r28
    19cc:	0e 96       	adiw	r24, 0x0e	; 14
    19ce:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
    19d2:	8e 01       	movw	r16, r28
    19d4:	0e 5f       	subi	r16, 0xFE	; 254
    19d6:	1f 4f       	sbci	r17, 0xFF	; 255
    19d8:	c8 01       	movw	r24, r16
    19da:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
    19de:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19e0:	90 91 16 2c 	lds	r25, 0x2C16	; 0x802c16 <uxTopReadyPriority>
    19e4:	98 17       	cp	r25, r24
    19e6:	10 f4       	brcc	.+4      	; 0x19ec <xTaskResumeAll+0x68>
    19e8:	80 93 16 2c 	sts	0x2C16, r24	; 0x802c16 <uxTopReadyPriority>
    19ec:	d8 9e       	mul	r13, r24
    19ee:	c0 01       	movw	r24, r0
    19f0:	11 24       	eor	r1, r1
    19f2:	b8 01       	movw	r22, r16
    19f4:	84 5b       	subi	r24, 0xB4	; 180
    19f6:	93 4d       	sbci	r25, 0xD3	; 211
    19f8:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsertEnd>
    19fc:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1a00:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1a04:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a06:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a08:	98 17       	cp	r25, r24
    1a0a:	88 f0       	brcs	.+34     	; 0x1a2e <xTaskResumeAll+0xaa>
    1a0c:	c0 92 13 2c 	sts	0x2C13, r12	; 0x802c13 <xYieldPending>
    1a10:	0e c0       	rjmp	.+28     	; 0x1a2e <xTaskResumeAll+0xaa>
    1a12:	c0 e0       	ldi	r28, 0x00	; 0
    1a14:	d0 e0       	ldi	r29, 0x00	; 0
    1a16:	0f 2e       	mov	r0, r31
    1a18:	f7 e2       	ldi	r31, 0x27	; 39
    1a1a:	ef 2e       	mov	r14, r31
    1a1c:	fc e2       	ldi	r31, 0x2C	; 44
    1a1e:	ff 2e       	mov	r15, r31
    1a20:	f0 2d       	mov	r31, r0
    1a22:	0f 2e       	mov	r0, r31
    1a24:	fb e0       	ldi	r31, 0x0B	; 11
    1a26:	df 2e       	mov	r13, r31
    1a28:	f0 2d       	mov	r31, r0
    1a2a:	cc 24       	eor	r12, r12
    1a2c:	c3 94       	inc	r12
    1a2e:	f7 01       	movw	r30, r14
    1a30:	80 81       	ld	r24, Z
    1a32:	81 11       	cpse	r24, r1
    1a34:	c3 cf       	rjmp	.-122    	; 0x19bc <xTaskResumeAll+0x38>
    1a36:	cd 2b       	or	r28, r29
    1a38:	11 f0       	breq	.+4      	; 0x1a3e <xTaskResumeAll+0xba>
    1a3a:	0e 94 da 09 	call	0x13b4	; 0x13b4 <prvResetNextTaskUnblockTime>
    1a3e:	c0 91 14 2c 	lds	r28, 0x2C14	; 0x802c14 <uxPendedTicks>
    1a42:	cc 23       	and	r28, r28
    1a44:	51 f0       	breq	.+20     	; 0x1a5a <xTaskResumeAll+0xd6>
    1a46:	d1 e0       	ldi	r29, 0x01	; 1
    1a48:	0e 94 ef 0b 	call	0x17de	; 0x17de <xTaskIncrementTick>
    1a4c:	81 11       	cpse	r24, r1
    1a4e:	d0 93 13 2c 	sts	0x2C13, r29	; 0x802c13 <xYieldPending>
    1a52:	c1 50       	subi	r28, 0x01	; 1
    1a54:	c9 f7       	brne	.-14     	; 0x1a48 <xTaskResumeAll+0xc4>
    1a56:	10 92 14 2c 	sts	0x2C14, r1	; 0x802c14 <uxPendedTicks>
    1a5a:	80 91 13 2c 	lds	r24, 0x2C13	; 0x802c13 <xYieldPending>
    1a5e:	88 23       	and	r24, r24
    1a60:	31 f0       	breq	.+12     	; 0x1a6e <xTaskResumeAll+0xea>
    1a62:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
    1a66:	81 e0       	ldi	r24, 0x01	; 1
    1a68:	03 c0       	rjmp	.+6      	; 0x1a70 <xTaskResumeAll+0xec>
    1a6a:	80 e0       	ldi	r24, 0x00	; 0
    1a6c:	01 c0       	rjmp	.+2      	; 0x1a70 <xTaskResumeAll+0xec>
    1a6e:	80 e0       	ldi	r24, 0x00	; 0
    1a70:	ff 91       	pop	r31
    1a72:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1a76:	df 91       	pop	r29
    1a78:	cf 91       	pop	r28
    1a7a:	1f 91       	pop	r17
    1a7c:	0f 91       	pop	r16
    1a7e:	ff 90       	pop	r15
    1a80:	ef 90       	pop	r14
    1a82:	df 90       	pop	r13
    1a84:	cf 90       	pop	r12
    1a86:	08 95       	ret

00001a88 <vTaskDelay>:
    1a88:	cf 92       	push	r12
    1a8a:	df 92       	push	r13
    1a8c:	ef 92       	push	r14
    1a8e:	ff 92       	push	r15
    1a90:	6b 01       	movw	r12, r22
    1a92:	7c 01       	movw	r14, r24
    1a94:	67 2b       	or	r22, r23
    1a96:	68 2b       	or	r22, r24
    1a98:	69 2b       	or	r22, r25
    1a9a:	59 f0       	breq	.+22     	; 0x1ab2 <vTaskDelay+0x2a>
    1a9c:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <vTaskSuspendAll>
    1aa0:	40 e0       	ldi	r20, 0x00	; 0
    1aa2:	c7 01       	movw	r24, r14
    1aa4:	b6 01       	movw	r22, r12
    1aa6:	0e 94 04 0a 	call	0x1408	; 0x1408 <prvAddCurrentTaskToDelayedList>
    1aaa:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
    1aae:	81 11       	cpse	r24, r1
    1ab0:	02 c0       	rjmp	.+4      	; 0x1ab6 <vTaskDelay+0x2e>
    1ab2:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
    1ab6:	ff 90       	pop	r15
    1ab8:	ef 90       	pop	r14
    1aba:	df 90       	pop	r13
    1abc:	cf 90       	pop	r12
    1abe:	08 95       	ret

00001ac0 <vTaskSwitchContext>:
    1ac0:	80 91 0a 2c 	lds	r24, 0x2C0A	; 0x802c0a <uxSchedulerSuspended>
    1ac4:	88 23       	and	r24, r24
    1ac6:	21 f0       	breq	.+8      	; 0x1ad0 <vTaskSwitchContext+0x10>
    1ac8:	81 e0       	ldi	r24, 0x01	; 1
    1aca:	80 93 13 2c 	sts	0x2C13, r24	; 0x802c13 <xYieldPending>
    1ace:	08 95       	ret
    1ad0:	10 92 13 2c 	sts	0x2C13, r1	; 0x802c13 <xYieldPending>
    1ad4:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1ad8:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1adc:	03 8c       	ldd	r0, Z+27	; 0x1b
    1ade:	f4 8d       	ldd	r31, Z+28	; 0x1c
    1ae0:	e0 2d       	mov	r30, r0
    1ae2:	80 81       	ld	r24, Z
    1ae4:	91 81       	ldd	r25, Z+1	; 0x01
    1ae6:	a2 81       	ldd	r26, Z+2	; 0x02
    1ae8:	b3 81       	ldd	r27, Z+3	; 0x03
    1aea:	85 3a       	cpi	r24, 0xA5	; 165
    1aec:	95 4a       	sbci	r25, 0xA5	; 165
    1aee:	a5 4a       	sbci	r26, 0xA5	; 165
    1af0:	b5 4a       	sbci	r27, 0xA5	; 165
    1af2:	d9 f4       	brne	.+54     	; 0x1b2a <vTaskSwitchContext+0x6a>
    1af4:	84 81       	ldd	r24, Z+4	; 0x04
    1af6:	95 81       	ldd	r25, Z+5	; 0x05
    1af8:	a6 81       	ldd	r26, Z+6	; 0x06
    1afa:	b7 81       	ldd	r27, Z+7	; 0x07
    1afc:	85 3a       	cpi	r24, 0xA5	; 165
    1afe:	95 4a       	sbci	r25, 0xA5	; 165
    1b00:	a5 4a       	sbci	r26, 0xA5	; 165
    1b02:	b5 4a       	sbci	r27, 0xA5	; 165
    1b04:	91 f4       	brne	.+36     	; 0x1b2a <vTaskSwitchContext+0x6a>
    1b06:	80 85       	ldd	r24, Z+8	; 0x08
    1b08:	91 85       	ldd	r25, Z+9	; 0x09
    1b0a:	a2 85       	ldd	r26, Z+10	; 0x0a
    1b0c:	b3 85       	ldd	r27, Z+11	; 0x0b
    1b0e:	85 3a       	cpi	r24, 0xA5	; 165
    1b10:	95 4a       	sbci	r25, 0xA5	; 165
    1b12:	a5 4a       	sbci	r26, 0xA5	; 165
    1b14:	b5 4a       	sbci	r27, 0xA5	; 165
    1b16:	49 f4       	brne	.+18     	; 0x1b2a <vTaskSwitchContext+0x6a>
    1b18:	84 85       	ldd	r24, Z+12	; 0x0c
    1b1a:	95 85       	ldd	r25, Z+13	; 0x0d
    1b1c:	a6 85       	ldd	r26, Z+14	; 0x0e
    1b1e:	b7 85       	ldd	r27, Z+15	; 0x0f
    1b20:	85 3a       	cpi	r24, 0xA5	; 165
    1b22:	95 4a       	sbci	r25, 0xA5	; 165
    1b24:	a5 4a       	sbci	r26, 0xA5	; 165
    1b26:	b5 4a       	sbci	r27, 0xA5	; 165
    1b28:	61 f0       	breq	.+24     	; 0x1b42 <vTaskSwitchContext+0x82>
    1b2a:	60 91 78 2c 	lds	r22, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1b2e:	70 91 79 2c 	lds	r23, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1b32:	80 91 78 2c 	lds	r24, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1b36:	90 91 79 2c 	lds	r25, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1b3a:	63 5e       	subi	r22, 0xE3	; 227
    1b3c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b3e:	0e 94 a9 01 	call	0x352	; 0x352 <vApplicationStackOverflowHook>
    1b42:	80 91 16 2c 	lds	r24, 0x2C16	; 0x802c16 <uxTopReadyPriority>
    1b46:	28 2f       	mov	r18, r24
    1b48:	30 e0       	ldi	r19, 0x00	; 0
    1b4a:	9b e0       	ldi	r25, 0x0B	; 11
    1b4c:	89 9f       	mul	r24, r25
    1b4e:	f0 01       	movw	r30, r0
    1b50:	11 24       	eor	r1, r1
    1b52:	e4 5b       	subi	r30, 0xB4	; 180
    1b54:	f3 4d       	sbci	r31, 0xD3	; 211
    1b56:	90 81       	ld	r25, Z
    1b58:	91 11       	cpse	r25, r1
    1b5a:	0e c0       	rjmp	.+28     	; 0x1b78 <vTaskSwitchContext+0xb8>
    1b5c:	4b e0       	ldi	r20, 0x0B	; 11
    1b5e:	81 50       	subi	r24, 0x01	; 1
    1b60:	28 2f       	mov	r18, r24
    1b62:	30 e0       	ldi	r19, 0x00	; 0
    1b64:	42 9f       	mul	r20, r18
    1b66:	f0 01       	movw	r30, r0
    1b68:	43 9f       	mul	r20, r19
    1b6a:	f0 0d       	add	r31, r0
    1b6c:	11 24       	eor	r1, r1
    1b6e:	e4 5b       	subi	r30, 0xB4	; 180
    1b70:	f3 4d       	sbci	r31, 0xD3	; 211
    1b72:	90 81       	ld	r25, Z
    1b74:	99 23       	and	r25, r25
    1b76:	99 f3       	breq	.-26     	; 0x1b5e <vTaskSwitchContext+0x9e>
    1b78:	9b e0       	ldi	r25, 0x0B	; 11
    1b7a:	92 9f       	mul	r25, r18
    1b7c:	a0 01       	movw	r20, r0
    1b7e:	93 9f       	mul	r25, r19
    1b80:	50 0d       	add	r21, r0
    1b82:	11 24       	eor	r1, r1
    1b84:	da 01       	movw	r26, r20
    1b86:	a4 5b       	subi	r26, 0xB4	; 180
    1b88:	b3 4d       	sbci	r27, 0xD3	; 211
    1b8a:	11 96       	adiw	r26, 0x01	; 1
    1b8c:	ed 91       	ld	r30, X+
    1b8e:	fc 91       	ld	r31, X
    1b90:	12 97       	sbiw	r26, 0x02	; 2
    1b92:	04 80       	ldd	r0, Z+4	; 0x04
    1b94:	f5 81       	ldd	r31, Z+5	; 0x05
    1b96:	e0 2d       	mov	r30, r0
    1b98:	11 96       	adiw	r26, 0x01	; 1
    1b9a:	ed 93       	st	X+, r30
    1b9c:	fc 93       	st	X, r31
    1b9e:	12 97       	sbiw	r26, 0x02	; 2
    1ba0:	41 5b       	subi	r20, 0xB1	; 177
    1ba2:	53 4d       	sbci	r21, 0xD3	; 211
    1ba4:	e4 17       	cp	r30, r20
    1ba6:	f5 07       	cpc	r31, r21
    1ba8:	29 f4       	brne	.+10     	; 0x1bb4 <vTaskSwitchContext+0xf4>
    1baa:	44 81       	ldd	r20, Z+4	; 0x04
    1bac:	55 81       	ldd	r21, Z+5	; 0x05
    1bae:	fd 01       	movw	r30, r26
    1bb0:	41 83       	std	Z+1, r20	; 0x01
    1bb2:	52 83       	std	Z+2, r21	; 0x02
    1bb4:	9b e0       	ldi	r25, 0x0B	; 11
    1bb6:	92 9f       	mul	r25, r18
    1bb8:	f0 01       	movw	r30, r0
    1bba:	93 9f       	mul	r25, r19
    1bbc:	f0 0d       	add	r31, r0
    1bbe:	11 24       	eor	r1, r1
    1bc0:	e4 5b       	subi	r30, 0xB4	; 180
    1bc2:	f3 4d       	sbci	r31, 0xD3	; 211
    1bc4:	01 80       	ldd	r0, Z+1	; 0x01
    1bc6:	f2 81       	ldd	r31, Z+2	; 0x02
    1bc8:	e0 2d       	mov	r30, r0
    1bca:	20 85       	ldd	r18, Z+8	; 0x08
    1bcc:	31 85       	ldd	r19, Z+9	; 0x09
    1bce:	20 93 78 2c 	sts	0x2C78, r18	; 0x802c78 <pxCurrentTCB>
    1bd2:	30 93 79 2c 	sts	0x2C79, r19	; 0x802c79 <pxCurrentTCB+0x1>
    1bd6:	80 93 16 2c 	sts	0x2C16, r24	; 0x802c16 <uxTopReadyPriority>
    1bda:	08 95       	ret

00001bdc <vTaskPlaceOnEventList>:
    1bdc:	cf 92       	push	r12
    1bde:	df 92       	push	r13
    1be0:	ef 92       	push	r14
    1be2:	ff 92       	push	r15
    1be4:	6a 01       	movw	r12, r20
    1be6:	7b 01       	movw	r14, r22
    1be8:	60 91 78 2c 	lds	r22, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1bec:	70 91 79 2c 	lds	r23, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1bf0:	62 5f       	subi	r22, 0xF2	; 242
    1bf2:	7f 4f       	sbci	r23, 0xFF	; 255
    1bf4:	0e 94 a6 03 	call	0x74c	; 0x74c <vListInsert>
    1bf8:	41 e0       	ldi	r20, 0x01	; 1
    1bfa:	c7 01       	movw	r24, r14
    1bfc:	b6 01       	movw	r22, r12
    1bfe:	0e 94 04 0a 	call	0x1408	; 0x1408 <prvAddCurrentTaskToDelayedList>
    1c02:	ff 90       	pop	r15
    1c04:	ef 90       	pop	r14
    1c06:	df 90       	pop	r13
    1c08:	cf 90       	pop	r12
    1c0a:	08 95       	ret

00001c0c <vTaskPlaceOnUnorderedEventList>:
    1c0c:	cf 92       	push	r12
    1c0e:	df 92       	push	r13
    1c10:	ef 92       	push	r14
    1c12:	ff 92       	push	r15
    1c14:	0f 93       	push	r16
    1c16:	1f 93       	push	r17
    1c18:	68 01       	movw	r12, r16
    1c1a:	79 01       	movw	r14, r18
    1c1c:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1c20:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1c24:	70 68       	ori	r23, 0x80	; 128
    1c26:	46 87       	std	Z+14, r20	; 0x0e
    1c28:	57 87       	std	Z+15, r21	; 0x0f
    1c2a:	60 8b       	std	Z+16, r22	; 0x10
    1c2c:	71 8b       	std	Z+17, r23	; 0x11
    1c2e:	60 91 78 2c 	lds	r22, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1c32:	70 91 79 2c 	lds	r23, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1c36:	62 5f       	subi	r22, 0xF2	; 242
    1c38:	7f 4f       	sbci	r23, 0xFF	; 255
    1c3a:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsertEnd>
    1c3e:	41 e0       	ldi	r20, 0x01	; 1
    1c40:	c7 01       	movw	r24, r14
    1c42:	b6 01       	movw	r22, r12
    1c44:	0e 94 04 0a 	call	0x1408	; 0x1408 <prvAddCurrentTaskToDelayedList>
    1c48:	1f 91       	pop	r17
    1c4a:	0f 91       	pop	r16
    1c4c:	ff 90       	pop	r15
    1c4e:	ef 90       	pop	r14
    1c50:	df 90       	pop	r13
    1c52:	cf 90       	pop	r12
    1c54:	08 95       	ret

00001c56 <vTaskPlaceOnEventListRestricted>:
    1c56:	cf 92       	push	r12
    1c58:	df 92       	push	r13
    1c5a:	ef 92       	push	r14
    1c5c:	ff 92       	push	r15
    1c5e:	cf 93       	push	r28
    1c60:	6a 01       	movw	r12, r20
    1c62:	7b 01       	movw	r14, r22
    1c64:	c2 2f       	mov	r28, r18
    1c66:	60 91 78 2c 	lds	r22, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1c6a:	70 91 79 2c 	lds	r23, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1c6e:	62 5f       	subi	r22, 0xF2	; 242
    1c70:	7f 4f       	sbci	r23, 0xFF	; 255
    1c72:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsertEnd>
    1c76:	cc 23       	and	r28, r28
    1c78:	21 f0       	breq	.+8      	; 0x1c82 <vTaskPlaceOnEventListRestricted+0x2c>
    1c7a:	cc 24       	eor	r12, r12
    1c7c:	ca 94       	dec	r12
    1c7e:	dc 2c       	mov	r13, r12
    1c80:	76 01       	movw	r14, r12
    1c82:	4c 2f       	mov	r20, r28
    1c84:	c7 01       	movw	r24, r14
    1c86:	b6 01       	movw	r22, r12
    1c88:	0e 94 04 0a 	call	0x1408	; 0x1408 <prvAddCurrentTaskToDelayedList>
    1c8c:	cf 91       	pop	r28
    1c8e:	ff 90       	pop	r15
    1c90:	ef 90       	pop	r14
    1c92:	df 90       	pop	r13
    1c94:	cf 90       	pop	r12
    1c96:	08 95       	ret

00001c98 <xTaskRemoveFromEventList>:
    1c98:	0f 93       	push	r16
    1c9a:	1f 93       	push	r17
    1c9c:	cf 93       	push	r28
    1c9e:	df 93       	push	r29
    1ca0:	dc 01       	movw	r26, r24
    1ca2:	17 96       	adiw	r26, 0x07	; 7
    1ca4:	ed 91       	ld	r30, X+
    1ca6:	fc 91       	ld	r31, X
    1ca8:	18 97       	sbiw	r26, 0x08	; 8
    1caa:	c0 85       	ldd	r28, Z+8	; 0x08
    1cac:	d1 85       	ldd	r29, Z+9	; 0x09
    1cae:	8e 01       	movw	r16, r28
    1cb0:	02 5f       	subi	r16, 0xF2	; 242
    1cb2:	1f 4f       	sbci	r17, 0xFF	; 255
    1cb4:	c8 01       	movw	r24, r16
    1cb6:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
    1cba:	80 91 0a 2c 	lds	r24, 0x2C0A	; 0x802c0a <uxSchedulerSuspended>
    1cbe:	81 11       	cpse	r24, r1
    1cc0:	16 c0       	rjmp	.+44     	; 0x1cee <xTaskRemoveFromEventList+0x56>
    1cc2:	0c 50       	subi	r16, 0x0C	; 12
    1cc4:	11 09       	sbc	r17, r1
    1cc6:	c8 01       	movw	r24, r16
    1cc8:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
    1ccc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1cce:	90 91 16 2c 	lds	r25, 0x2C16	; 0x802c16 <uxTopReadyPriority>
    1cd2:	98 17       	cp	r25, r24
    1cd4:	10 f4       	brcc	.+4      	; 0x1cda <xTaskRemoveFromEventList+0x42>
    1cd6:	80 93 16 2c 	sts	0x2C16, r24	; 0x802c16 <uxTopReadyPriority>
    1cda:	bb e0       	ldi	r27, 0x0B	; 11
    1cdc:	8b 9f       	mul	r24, r27
    1cde:	c0 01       	movw	r24, r0
    1ce0:	11 24       	eor	r1, r1
    1ce2:	b8 01       	movw	r22, r16
    1ce4:	84 5b       	subi	r24, 0xB4	; 180
    1ce6:	93 4d       	sbci	r25, 0xD3	; 211
    1ce8:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsertEnd>
    1cec:	05 c0       	rjmp	.+10     	; 0x1cf8 <xTaskRemoveFromEventList+0x60>
    1cee:	b8 01       	movw	r22, r16
    1cf0:	87 e2       	ldi	r24, 0x27	; 39
    1cf2:	9c e2       	ldi	r25, 0x2C	; 44
    1cf4:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsertEnd>
    1cf8:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1cfc:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1d00:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1d02:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d04:	89 17       	cp	r24, r25
    1d06:	20 f4       	brcc	.+8      	; 0x1d10 <xTaskRemoveFromEventList+0x78>
    1d08:	81 e0       	ldi	r24, 0x01	; 1
    1d0a:	80 93 13 2c 	sts	0x2C13, r24	; 0x802c13 <xYieldPending>
    1d0e:	01 c0       	rjmp	.+2      	; 0x1d12 <xTaskRemoveFromEventList+0x7a>
    1d10:	80 e0       	ldi	r24, 0x00	; 0
    1d12:	df 91       	pop	r29
    1d14:	cf 91       	pop	r28
    1d16:	1f 91       	pop	r17
    1d18:	0f 91       	pop	r16
    1d1a:	08 95       	ret

00001d1c <vTaskRemoveFromUnorderedEventList>:
    1d1c:	0f 93       	push	r16
    1d1e:	1f 93       	push	r17
    1d20:	cf 93       	push	r28
    1d22:	df 93       	push	r29
    1d24:	70 68       	ori	r23, 0x80	; 128
    1d26:	fc 01       	movw	r30, r24
    1d28:	40 83       	st	Z, r20
    1d2a:	51 83       	std	Z+1, r21	; 0x01
    1d2c:	62 83       	std	Z+2, r22	; 0x02
    1d2e:	73 83       	std	Z+3, r23	; 0x03
    1d30:	c0 85       	ldd	r28, Z+8	; 0x08
    1d32:	d1 85       	ldd	r29, Z+9	; 0x09
    1d34:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
    1d38:	8e 01       	movw	r16, r28
    1d3a:	0e 5f       	subi	r16, 0xFE	; 254
    1d3c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d3e:	c8 01       	movw	r24, r16
    1d40:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
    1d44:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d46:	90 91 16 2c 	lds	r25, 0x2C16	; 0x802c16 <uxTopReadyPriority>
    1d4a:	98 17       	cp	r25, r24
    1d4c:	10 f4       	brcc	.+4      	; 0x1d52 <vTaskRemoveFromUnorderedEventList+0x36>
    1d4e:	80 93 16 2c 	sts	0x2C16, r24	; 0x802c16 <uxTopReadyPriority>
    1d52:	fb e0       	ldi	r31, 0x0B	; 11
    1d54:	8f 9f       	mul	r24, r31
    1d56:	c0 01       	movw	r24, r0
    1d58:	11 24       	eor	r1, r1
    1d5a:	b8 01       	movw	r22, r16
    1d5c:	84 5b       	subi	r24, 0xB4	; 180
    1d5e:	93 4d       	sbci	r25, 0xD3	; 211
    1d60:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsertEnd>
    1d64:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1d68:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1d6c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1d6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d70:	89 17       	cp	r24, r25
    1d72:	18 f4       	brcc	.+6      	; 0x1d7a <vTaskRemoveFromUnorderedEventList+0x5e>
    1d74:	81 e0       	ldi	r24, 0x01	; 1
    1d76:	80 93 13 2c 	sts	0x2C13, r24	; 0x802c13 <xYieldPending>
    1d7a:	df 91       	pop	r29
    1d7c:	cf 91       	pop	r28
    1d7e:	1f 91       	pop	r17
    1d80:	0f 91       	pop	r16
    1d82:	08 95       	ret

00001d84 <vTaskInternalSetTimeOutState>:
    1d84:	20 91 12 2c 	lds	r18, 0x2C12	; 0x802c12 <xNumOfOverflows>
    1d88:	fc 01       	movw	r30, r24
    1d8a:	20 83       	st	Z, r18
    1d8c:	40 91 17 2c 	lds	r20, 0x2C17	; 0x802c17 <xTickCount>
    1d90:	50 91 18 2c 	lds	r21, 0x2C18	; 0x802c18 <xTickCount+0x1>
    1d94:	60 91 19 2c 	lds	r22, 0x2C19	; 0x802c19 <xTickCount+0x2>
    1d98:	70 91 1a 2c 	lds	r23, 0x2C1A	; 0x802c1a <xTickCount+0x3>
    1d9c:	41 83       	std	Z+1, r20	; 0x01
    1d9e:	52 83       	std	Z+2, r21	; 0x02
    1da0:	63 83       	std	Z+3, r22	; 0x03
    1da2:	74 83       	std	Z+4, r23	; 0x04
    1da4:	08 95       	ret

00001da6 <xTaskCheckForTimeOut>:
    1da6:	cf 92       	push	r12
    1da8:	df 92       	push	r13
    1daa:	ef 92       	push	r14
    1dac:	ff 92       	push	r15
    1dae:	0f 93       	push	r16
    1db0:	1f 93       	push	r17
    1db2:	cf 93       	push	r28
    1db4:	df 93       	push	r29
    1db6:	db 01       	movw	r26, r22
    1db8:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1dbc:	ff 93       	push	r31
    1dbe:	f8 7f       	andi	r31, 0xF8	; 248
    1dc0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1dc4:	40 91 17 2c 	lds	r20, 0x2C17	; 0x802c17 <xTickCount>
    1dc8:	50 91 18 2c 	lds	r21, 0x2C18	; 0x802c18 <xTickCount+0x1>
    1dcc:	60 91 19 2c 	lds	r22, 0x2C19	; 0x802c19 <xTickCount+0x2>
    1dd0:	70 91 1a 2c 	lds	r23, 0x2C1A	; 0x802c1a <xTickCount+0x3>
    1dd4:	0d 91       	ld	r16, X+
    1dd6:	1d 91       	ld	r17, X+
    1dd8:	2d 91       	ld	r18, X+
    1dda:	3c 91       	ld	r19, X
    1ddc:	13 97       	sbiw	r26, 0x03	; 3
    1dde:	0f 3f       	cpi	r16, 0xFF	; 255
    1de0:	cf ef       	ldi	r28, 0xFF	; 255
    1de2:	1c 07       	cpc	r17, r28
    1de4:	2c 07       	cpc	r18, r28
    1de6:	3c 07       	cpc	r19, r28
    1de8:	69 f1       	breq	.+90     	; 0x1e44 <xTaskCheckForTimeOut+0x9e>
    1dea:	fc 01       	movw	r30, r24
    1dec:	c1 80       	ldd	r12, Z+1	; 0x01
    1dee:	d2 80       	ldd	r13, Z+2	; 0x02
    1df0:	e3 80       	ldd	r14, Z+3	; 0x03
    1df2:	f4 80       	ldd	r15, Z+4	; 0x04
    1df4:	e0 91 12 2c 	lds	r30, 0x2C12	; 0x802c12 <xNumOfOverflows>
    1df8:	ec 01       	movw	r28, r24
    1dfa:	f8 81       	ld	r31, Y
    1dfc:	fe 17       	cp	r31, r30
    1dfe:	29 f0       	breq	.+10     	; 0x1e0a <xTaskCheckForTimeOut+0x64>
    1e00:	4c 15       	cp	r20, r12
    1e02:	5d 05       	cpc	r21, r13
    1e04:	6e 05       	cpc	r22, r14
    1e06:	7f 05       	cpc	r23, r15
    1e08:	f8 f4       	brcc	.+62     	; 0x1e48 <xTaskCheckForTimeOut+0xa2>
    1e0a:	4c 19       	sub	r20, r12
    1e0c:	5d 09       	sbc	r21, r13
    1e0e:	6e 09       	sbc	r22, r14
    1e10:	7f 09       	sbc	r23, r15
    1e12:	40 17       	cp	r20, r16
    1e14:	51 07       	cpc	r21, r17
    1e16:	62 07       	cpc	r22, r18
    1e18:	73 07       	cpc	r23, r19
    1e1a:	68 f4       	brcc	.+26     	; 0x1e36 <xTaskCheckForTimeOut+0x90>
    1e1c:	fd 01       	movw	r30, r26
    1e1e:	04 1b       	sub	r16, r20
    1e20:	15 0b       	sbc	r17, r21
    1e22:	26 0b       	sbc	r18, r22
    1e24:	37 0b       	sbc	r19, r23
    1e26:	00 83       	st	Z, r16
    1e28:	11 83       	std	Z+1, r17	; 0x01
    1e2a:	22 83       	std	Z+2, r18	; 0x02
    1e2c:	33 83       	std	Z+3, r19	; 0x03
    1e2e:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <vTaskInternalSetTimeOutState>
    1e32:	80 e0       	ldi	r24, 0x00	; 0
    1e34:	0a c0       	rjmp	.+20     	; 0x1e4a <xTaskCheckForTimeOut+0xa4>
    1e36:	1d 92       	st	X+, r1
    1e38:	1d 92       	st	X+, r1
    1e3a:	1d 92       	st	X+, r1
    1e3c:	1c 92       	st	X, r1
    1e3e:	13 97       	sbiw	r26, 0x03	; 3
    1e40:	81 e0       	ldi	r24, 0x01	; 1
    1e42:	03 c0       	rjmp	.+6      	; 0x1e4a <xTaskCheckForTimeOut+0xa4>
    1e44:	80 e0       	ldi	r24, 0x00	; 0
    1e46:	01 c0       	rjmp	.+2      	; 0x1e4a <xTaskCheckForTimeOut+0xa4>
    1e48:	81 e0       	ldi	r24, 0x01	; 1
    1e4a:	ff 91       	pop	r31
    1e4c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1e50:	df 91       	pop	r29
    1e52:	cf 91       	pop	r28
    1e54:	1f 91       	pop	r17
    1e56:	0f 91       	pop	r16
    1e58:	ff 90       	pop	r15
    1e5a:	ef 90       	pop	r14
    1e5c:	df 90       	pop	r13
    1e5e:	cf 90       	pop	r12
    1e60:	08 95       	ret

00001e62 <vTaskMissedYield>:
    1e62:	81 e0       	ldi	r24, 0x01	; 1
    1e64:	80 93 13 2c 	sts	0x2C13, r24	; 0x802c13 <xYieldPending>
    1e68:	08 95       	ret

00001e6a <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    1e6a:	80 91 15 2c 	lds	r24, 0x2C15	; 0x802c15 <xSchedulerRunning>
    1e6e:	88 23       	and	r24, r24
    1e70:	31 f0       	breq	.+12     	; 0x1e7e <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1e72:	80 91 0a 2c 	lds	r24, 0x2C0A	; 0x802c0a <uxSchedulerSuspended>
    1e76:	88 23       	and	r24, r24
    1e78:	21 f0       	breq	.+8      	; 0x1e82 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    1e7a:	80 e0       	ldi	r24, 0x00	; 0
    1e7c:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    1e7e:	81 e0       	ldi	r24, 0x01	; 1
    1e80:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    1e82:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    1e84:	08 95       	ret

00001e86 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    1e86:	0f 93       	push	r16
    1e88:	1f 93       	push	r17
    1e8a:	cf 93       	push	r28
    1e8c:	df 93       	push	r29
    1e8e:	fc 01       	movw	r30, r24
	BaseType_t xReturn = pdFALSE;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    1e90:	89 2b       	or	r24, r25
    1e92:	09 f4       	brne	.+2      	; 0x1e96 <xTaskPriorityInherit+0x10>
    1e94:	60 c0       	rjmp	.+192    	; 0x1f56 <xTaskPriorityInherit+0xd0>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    1e96:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e98:	a0 91 78 2c 	lds	r26, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1e9c:	b0 91 79 2c 	lds	r27, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1ea0:	5a 96       	adiw	r26, 0x1a	; 26
    1ea2:	9c 91       	ld	r25, X
    1ea4:	89 17       	cp	r24, r25
    1ea6:	08 f0       	brcs	.+2      	; 0x1eaa <xTaskPriorityInherit+0x24>
    1ea8:	4a c0       	rjmp	.+148    	; 0x1f3e <xTaskPriorityInherit+0xb8>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1eaa:	46 85       	ldd	r20, Z+14	; 0x0e
    1eac:	57 85       	ldd	r21, Z+15	; 0x0f
    1eae:	60 89       	ldd	r22, Z+16	; 0x10
    1eb0:	71 89       	ldd	r23, Z+17	; 0x11
    1eb2:	77 23       	and	r23, r23
    1eb4:	94 f0       	brlt	.+36     	; 0x1eda <xTaskPriorityInherit+0x54>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1eb6:	a0 91 78 2c 	lds	r26, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1eba:	b0 91 79 2c 	lds	r27, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1ebe:	5a 96       	adiw	r26, 0x1a	; 26
    1ec0:	9c 91       	ld	r25, X
    1ec2:	44 e0       	ldi	r20, 0x04	; 4
    1ec4:	50 e0       	ldi	r21, 0x00	; 0
    1ec6:	60 e0       	ldi	r22, 0x00	; 0
    1ec8:	70 e0       	ldi	r23, 0x00	; 0
    1eca:	49 1b       	sub	r20, r25
    1ecc:	51 09       	sbc	r21, r1
    1ece:	61 09       	sbc	r22, r1
    1ed0:	71 09       	sbc	r23, r1
    1ed2:	46 87       	std	Z+14, r20	; 0x0e
    1ed4:	57 87       	std	Z+15, r21	; 0x0f
    1ed6:	60 8b       	std	Z+16, r22	; 0x10
    1ed8:	71 8b       	std	Z+17, r23	; 0x11
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    1eda:	2b e0       	ldi	r18, 0x0B	; 11
    1edc:	82 9f       	mul	r24, r18
    1ede:	c0 01       	movw	r24, r0
    1ee0:	11 24       	eor	r1, r1
    1ee2:	84 5b       	subi	r24, 0xB4	; 180
    1ee4:	93 4d       	sbci	r25, 0xD3	; 211
    1ee6:	24 85       	ldd	r18, Z+12	; 0x0c
    1ee8:	35 85       	ldd	r19, Z+13	; 0x0d
    1eea:	28 17       	cp	r18, r24
    1eec:	39 07       	cpc	r19, r25
    1eee:	f1 f4       	brne	.+60     	; 0x1f2c <xTaskPriorityInherit+0xa6>
    1ef0:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1ef2:	ef 01       	movw	r28, r30
    1ef4:	22 96       	adiw	r28, 0x02	; 2
    1ef6:	ce 01       	movw	r24, r28
    1ef8:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    1efc:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1f00:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1f04:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f06:	f8 01       	movw	r30, r16
    1f08:	82 8f       	std	Z+26, r24	; 0x1a
					prvAddTaskToReadyList( pxMutexHolderTCB );
    1f0a:	90 91 16 2c 	lds	r25, 0x2C16	; 0x802c16 <uxTopReadyPriority>
    1f0e:	98 17       	cp	r25, r24
    1f10:	10 f4       	brcc	.+4      	; 0x1f16 <xTaskPriorityInherit+0x90>
    1f12:	80 93 16 2c 	sts	0x2C16, r24	; 0x802c16 <uxTopReadyPriority>
    1f16:	fb e0       	ldi	r31, 0x0B	; 11
    1f18:	8f 9f       	mul	r24, r31
    1f1a:	c0 01       	movw	r24, r0
    1f1c:	11 24       	eor	r1, r1
    1f1e:	be 01       	movw	r22, r28
    1f20:	84 5b       	subi	r24, 0xB4	; 180
    1f22:	93 4d       	sbci	r25, 0xD3	; 211
    1f24:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsertEnd>
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    1f28:	81 e0       	ldi	r24, 0x01	; 1
    1f2a:	16 c0       	rjmp	.+44     	; 0x1f58 <xTaskPriorityInherit+0xd2>
					prvAddTaskToReadyList( pxMutexHolderTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    1f2c:	a0 91 78 2c 	lds	r26, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1f30:	b0 91 79 2c 	lds	r27, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    1f34:	5a 96       	adiw	r26, 0x1a	; 26
    1f36:	8c 91       	ld	r24, X
    1f38:	82 8f       	std	Z+26, r24	; 0x1a
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    1f3a:	81 e0       	ldi	r24, 0x01	; 1
    1f3c:	0d c0       	rjmp	.+26     	; 0x1f58 <xTaskPriorityInherit+0xd2>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    1f3e:	a0 91 78 2c 	lds	r26, 0x2C78	; 0x802c78 <pxCurrentTCB>
    1f42:	b0 91 79 2c 	lds	r27, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    1f46:	81 e0       	ldi	r24, 0x01	; 1
    1f48:	27 a1       	ldd	r18, Z+39	; 0x27
    1f4a:	5a 96       	adiw	r26, 0x1a	; 26
    1f4c:	9c 91       	ld	r25, X
    1f4e:	29 17       	cp	r18, r25
    1f50:	18 f0       	brcs	.+6      	; 0x1f58 <xTaskPriorityInherit+0xd2>
    1f52:	80 e0       	ldi	r24, 0x00	; 0
    1f54:	01 c0       	rjmp	.+2      	; 0x1f58 <xTaskPriorityInherit+0xd2>
    1f56:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    1f58:	df 91       	pop	r29
    1f5a:	cf 91       	pop	r28
    1f5c:	1f 91       	pop	r17
    1f5e:	0f 91       	pop	r16
    1f60:	08 95       	ret

00001f62 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    1f62:	0f 93       	push	r16
    1f64:	1f 93       	push	r17
    1f66:	cf 93       	push	r28
    1f68:	df 93       	push	r29
    1f6a:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    1f6c:	89 2b       	or	r24, r25
    1f6e:	79 f1       	breq	.+94     	; 0x1fce <xTaskPriorityDisinherit+0x6c>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    1f70:	80 a5       	ldd	r24, Z+40	; 0x28
    1f72:	81 50       	subi	r24, 0x01	; 1
    1f74:	80 a7       	std	Z+40, r24	; 0x28

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1f76:	22 8d       	ldd	r18, Z+26	; 0x1a
    1f78:	97 a1       	ldd	r25, Z+39	; 0x27
    1f7a:	29 17       	cp	r18, r25
    1f7c:	51 f1       	breq	.+84     	; 0x1fd2 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1f7e:	81 11       	cpse	r24, r1
    1f80:	2a c0       	rjmp	.+84     	; 0x1fd6 <xTaskPriorityDisinherit+0x74>
    1f82:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1f84:	8f 01       	movw	r16, r30
    1f86:	0e 5f       	subi	r16, 0xFE	; 254
    1f88:	1f 4f       	sbci	r17, 0xFF	; 255
    1f8a:	c8 01       	movw	r24, r16
    1f8c:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1f90:	8f a1       	ldd	r24, Y+39	; 0x27
    1f92:	8a 8f       	std	Y+26, r24	; 0x1a

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f94:	44 e0       	ldi	r20, 0x04	; 4
    1f96:	50 e0       	ldi	r21, 0x00	; 0
    1f98:	60 e0       	ldi	r22, 0x00	; 0
    1f9a:	70 e0       	ldi	r23, 0x00	; 0
    1f9c:	48 1b       	sub	r20, r24
    1f9e:	51 09       	sbc	r21, r1
    1fa0:	61 09       	sbc	r22, r1
    1fa2:	71 09       	sbc	r23, r1
    1fa4:	4e 87       	std	Y+14, r20	; 0x0e
    1fa6:	5f 87       	std	Y+15, r21	; 0x0f
    1fa8:	68 8b       	std	Y+16, r22	; 0x10
    1faa:	79 8b       	std	Y+17, r23	; 0x11
					prvAddTaskToReadyList( pxTCB );
    1fac:	90 91 16 2c 	lds	r25, 0x2C16	; 0x802c16 <uxTopReadyPriority>
    1fb0:	98 17       	cp	r25, r24
    1fb2:	10 f4       	brcc	.+4      	; 0x1fb8 <xTaskPriorityDisinherit+0x56>
    1fb4:	80 93 16 2c 	sts	0x2C16, r24	; 0x802c16 <uxTopReadyPriority>
    1fb8:	2b e0       	ldi	r18, 0x0B	; 11
    1fba:	82 9f       	mul	r24, r18
    1fbc:	c0 01       	movw	r24, r0
    1fbe:	11 24       	eor	r1, r1
    1fc0:	b8 01       	movw	r22, r16
    1fc2:	84 5b       	subi	r24, 0xB4	; 180
    1fc4:	93 4d       	sbci	r25, 0xD3	; 211
    1fc6:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    1fca:	81 e0       	ldi	r24, 0x01	; 1
    1fcc:	05 c0       	rjmp	.+10     	; 0x1fd8 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    1fce:	80 e0       	ldi	r24, 0x00	; 0
    1fd0:	03 c0       	rjmp	.+6      	; 0x1fd8 <xTaskPriorityDisinherit+0x76>
    1fd2:	80 e0       	ldi	r24, 0x00	; 0
    1fd4:	01 c0       	rjmp	.+2      	; 0x1fd8 <xTaskPriorityDisinherit+0x76>
    1fd6:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    1fd8:	df 91       	pop	r29
    1fda:	cf 91       	pop	r28
    1fdc:	1f 91       	pop	r17
    1fde:	0f 91       	pop	r16
    1fe0:	08 95       	ret

00001fe2 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    1fe2:	0f 93       	push	r16
    1fe4:	1f 93       	push	r17
    1fe6:	cf 93       	push	r28
    1fe8:	df 93       	push	r29
    1fea:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

		if( pxMutexHolder != NULL )
    1fec:	89 2b       	or	r24, r25
    1fee:	09 f4       	brne	.+2      	; 0x1ff2 <vTaskPriorityDisinheritAfterTimeout+0x10>
    1ff0:	3f c0       	rjmp	.+126    	; 0x2070 <vTaskPriorityDisinheritAfterTimeout+0x8e>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    1ff2:	87 a1       	ldd	r24, Z+39	; 0x27
    1ff4:	86 17       	cp	r24, r22
    1ff6:	08 f4       	brcc	.+2      	; 0x1ffa <vTaskPriorityDisinheritAfterTimeout+0x18>
    1ff8:	86 2f       	mov	r24, r22
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    1ffa:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ffc:	98 17       	cp	r25, r24
    1ffe:	c1 f1       	breq	.+112    	; 0x2070 <vTaskPriorityDisinheritAfterTimeout+0x8e>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    2000:	20 a5       	ldd	r18, Z+40	; 0x28
    2002:	21 30       	cpi	r18, 0x01	; 1
    2004:	a9 f5       	brne	.+106    	; 0x2070 <vTaskPriorityDisinheritAfterTimeout+0x8e>
					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
					pxTCB->uxPriority = uxPriorityToUse;
    2006:	82 8f       	std	Z+26, r24	; 0x1a

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2008:	46 85       	ldd	r20, Z+14	; 0x0e
    200a:	57 85       	ldd	r21, Z+15	; 0x0f
    200c:	60 89       	ldd	r22, Z+16	; 0x10
    200e:	71 89       	ldd	r23, Z+17	; 0x11
    2010:	77 23       	and	r23, r23
    2012:	64 f0       	brlt	.+24     	; 0x202c <vTaskPriorityDisinheritAfterTimeout+0x4a>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2014:	44 e0       	ldi	r20, 0x04	; 4
    2016:	50 e0       	ldi	r21, 0x00	; 0
    2018:	60 e0       	ldi	r22, 0x00	; 0
    201a:	70 e0       	ldi	r23, 0x00	; 0
    201c:	48 1b       	sub	r20, r24
    201e:	51 09       	sbc	r21, r1
    2020:	61 09       	sbc	r22, r1
    2022:	71 09       	sbc	r23, r1
    2024:	46 87       	std	Z+14, r20	; 0x0e
    2026:	57 87       	std	Z+15, r21	; 0x0f
    2028:	60 8b       	std	Z+16, r22	; 0x10
    202a:	71 8b       	std	Z+17, r23	; 0x11
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    202c:	2b e0       	ldi	r18, 0x0B	; 11
    202e:	92 9f       	mul	r25, r18
    2030:	c0 01       	movw	r24, r0
    2032:	11 24       	eor	r1, r1
    2034:	84 5b       	subi	r24, 0xB4	; 180
    2036:	93 4d       	sbci	r25, 0xD3	; 211
    2038:	24 85       	ldd	r18, Z+12	; 0x0c
    203a:	35 85       	ldd	r19, Z+13	; 0x0d
    203c:	28 17       	cp	r18, r24
    203e:	39 07       	cpc	r19, r25
    2040:	b9 f4       	brne	.+46     	; 0x2070 <vTaskPriorityDisinheritAfterTimeout+0x8e>
    2042:	ef 01       	movw	r28, r30
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2044:	8f 01       	movw	r16, r30
    2046:	0e 5f       	subi	r16, 0xFE	; 254
    2048:	1f 4f       	sbci	r17, 0xFF	; 255
    204a:	c8 01       	movw	r24, r16
    204c:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    2050:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2052:	90 91 16 2c 	lds	r25, 0x2C16	; 0x802c16 <uxTopReadyPriority>
    2056:	98 17       	cp	r25, r24
    2058:	10 f4       	brcc	.+4      	; 0x205e <vTaskPriorityDisinheritAfterTimeout+0x7c>
    205a:	80 93 16 2c 	sts	0x2C16, r24	; 0x802c16 <uxTopReadyPriority>
    205e:	2b e0       	ldi	r18, 0x0B	; 11
    2060:	82 9f       	mul	r24, r18
    2062:	c0 01       	movw	r24, r0
    2064:	11 24       	eor	r1, r1
    2066:	b8 01       	movw	r22, r16
    2068:	84 5b       	subi	r24, 0xB4	; 180
    206a:	93 4d       	sbci	r25, 0xD3	; 211
    206c:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2070:	df 91       	pop	r29
    2072:	cf 91       	pop	r28
    2074:	1f 91       	pop	r17
    2076:	0f 91       	pop	r16
    2078:	08 95       	ret

0000207a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    207a:	cf 92       	push	r12
    207c:	df 92       	push	r13
    207e:	ef 92       	push	r14
    2080:	ff 92       	push	r15
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2082:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    2086:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    208a:	66 85       	ldd	r22, Z+14	; 0x0e
    208c:	77 85       	ldd	r23, Z+15	; 0x0f
    208e:	80 89       	ldd	r24, Z+16	; 0x10
    2090:	91 89       	ldd	r25, Z+17	; 0x11

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2092:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    2096:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    209a:	a0 91 78 2c 	lds	r26, 0x2C78	; 0x802c78 <pxCurrentTCB>
    209e:	b0 91 79 2c 	lds	r27, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    20a2:	5a 96       	adiw	r26, 0x1a	; 26
    20a4:	2c 91       	ld	r18, X
    20a6:	c1 2c       	mov	r12, r1
    20a8:	d1 2c       	mov	r13, r1
    20aa:	76 01       	movw	r14, r12
    20ac:	68 94       	set
    20ae:	c2 f8       	bld	r12, 2
    20b0:	c2 1a       	sub	r12, r18
    20b2:	d1 08       	sbc	r13, r1
    20b4:	e1 08       	sbc	r14, r1
    20b6:	f1 08       	sbc	r15, r1
    20b8:	c6 86       	std	Z+14, r12	; 0x0e
    20ba:	d7 86       	std	Z+15, r13	; 0x0f
    20bc:	e0 8a       	std	Z+16, r14	; 0x10
    20be:	f1 8a       	std	Z+17, r15	; 0x11

	return uxReturn;
}
    20c0:	ff 90       	pop	r15
    20c2:	ef 90       	pop	r14
    20c4:	df 90       	pop	r13
    20c6:	cf 90       	pop	r12
    20c8:	08 95       	ret

000020ca <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    20ca:	80 91 78 2c 	lds	r24, 0x2C78	; 0x802c78 <pxCurrentTCB>
    20ce:	90 91 79 2c 	lds	r25, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    20d2:	89 2b       	or	r24, r25
    20d4:	39 f0       	breq	.+14     	; 0x20e4 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    20d6:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTCB>
    20da:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
    20de:	80 a5       	ldd	r24, Z+40	; 0x28
    20e0:	8f 5f       	subi	r24, 0xFF	; 255
    20e2:	80 a7       	std	Z+40, r24	; 0x28
		}

		return pxCurrentTCB;
    20e4:	80 91 78 2c 	lds	r24, 0x2C78	; 0x802c78 <pxCurrentTCB>
    20e8:	90 91 79 2c 	lds	r25, 0x2C79	; 0x802c79 <pxCurrentTCB+0x1>
	}
    20ec:	08 95       	ret

000020ee <prvInsertTimerInActiveList>:

	taskENTER_CRITICAL();
	{
		pxTimer->pvTimerID = pvNewID;
	}
	taskEXIT_CRITICAL();
    20ee:	cf 92       	push	r12
    20f0:	df 92       	push	r13
    20f2:	ef 92       	push	r14
    20f4:	ff 92       	push	r15
    20f6:	0f 93       	push	r16
    20f8:	1f 93       	push	r17
    20fa:	fc 01       	movw	r30, r24
    20fc:	42 83       	std	Z+2, r20	; 0x02
    20fe:	53 83       	std	Z+3, r21	; 0x03
    2100:	64 83       	std	Z+4, r22	; 0x04
    2102:	75 83       	std	Z+5, r23	; 0x05
    2104:	82 87       	std	Z+10, r24	; 0x0a
    2106:	93 87       	std	Z+11, r25	; 0x0b
    2108:	04 17       	cp	r16, r20
    210a:	15 07       	cpc	r17, r21
    210c:	26 07       	cpc	r18, r22
    210e:	37 07       	cpc	r19, r23
    2110:	c0 f0       	brcs	.+48     	; 0x2142 <prvInsertTimerInActiveList+0x54>
    2112:	0c 19       	sub	r16, r12
    2114:	1d 09       	sbc	r17, r13
    2116:	2e 09       	sbc	r18, r14
    2118:	3f 09       	sbc	r19, r15
    211a:	86 85       	ldd	r24, Z+14	; 0x0e
    211c:	97 85       	ldd	r25, Z+15	; 0x0f
    211e:	a0 89       	ldd	r26, Z+16	; 0x10
    2120:	b1 89       	ldd	r27, Z+17	; 0x11
    2122:	08 17       	cp	r16, r24
    2124:	19 07       	cpc	r17, r25
    2126:	2a 07       	cpc	r18, r26
    2128:	3b 07       	cpc	r19, r27
    212a:	00 f5       	brcc	.+64     	; 0x216c <prvInsertTimerInActiveList+0x7e>
    212c:	bf 01       	movw	r22, r30
    212e:	6e 5f       	subi	r22, 0xFE	; 254
    2130:	7f 4f       	sbci	r23, 0xFF	; 255
    2132:	80 91 82 2c 	lds	r24, 0x2C82	; 0x802c82 <pxOverflowTimerList>
    2136:	90 91 83 2c 	lds	r25, 0x2C83	; 0x802c83 <pxOverflowTimerList+0x1>
    213a:	0e 94 a6 03 	call	0x74c	; 0x74c <vListInsert>
    213e:	80 e0       	ldi	r24, 0x00	; 0
    2140:	18 c0       	rjmp	.+48     	; 0x2172 <prvInsertTimerInActiveList+0x84>
    2142:	0c 15       	cp	r16, r12
    2144:	1d 05       	cpc	r17, r13
    2146:	2e 05       	cpc	r18, r14
    2148:	3f 05       	cpc	r19, r15
    214a:	28 f4       	brcc	.+10     	; 0x2156 <prvInsertTimerInActiveList+0x68>
    214c:	4c 15       	cp	r20, r12
    214e:	5d 05       	cpc	r21, r13
    2150:	6e 05       	cpc	r22, r14
    2152:	7f 05       	cpc	r23, r15
    2154:	68 f4       	brcc	.+26     	; 0x2170 <prvInsertTimerInActiveList+0x82>
    2156:	bf 01       	movw	r22, r30
    2158:	6e 5f       	subi	r22, 0xFE	; 254
    215a:	7f 4f       	sbci	r23, 0xFF	; 255
    215c:	80 91 84 2c 	lds	r24, 0x2C84	; 0x802c84 <pxCurrentTimerList>
    2160:	90 91 85 2c 	lds	r25, 0x2C85	; 0x802c85 <pxCurrentTimerList+0x1>
    2164:	0e 94 a6 03 	call	0x74c	; 0x74c <vListInsert>
    2168:	80 e0       	ldi	r24, 0x00	; 0
    216a:	03 c0       	rjmp	.+6      	; 0x2172 <prvInsertTimerInActiveList+0x84>
    216c:	81 e0       	ldi	r24, 0x01	; 1
    216e:	01 c0       	rjmp	.+2      	; 0x2172 <prvInsertTimerInActiveList+0x84>
    2170:	81 e0       	ldi	r24, 0x01	; 1
    2172:	1f 91       	pop	r17
    2174:	0f 91       	pop	r16
    2176:	ff 90       	pop	r15
    2178:	ef 90       	pop	r14
    217a:	df 90       	pop	r13
    217c:	cf 90       	pop	r12
    217e:	08 95       	ret

00002180 <prvCheckForValidListAndQueue>:
    2180:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    2184:	ff 93       	push	r31
    2186:	f8 7f       	andi	r31, 0xF8	; 248
    2188:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    218c:	80 91 80 2c 	lds	r24, 0x2C80	; 0x802c80 <xTimerQueue>
    2190:	90 91 81 2c 	lds	r25, 0x2C81	; 0x802c81 <xTimerQueue+0x1>
    2194:	89 2b       	or	r24, r25
    2196:	e9 f4       	brne	.+58     	; 0x21d2 <prvCheckForValidListAndQueue+0x52>
    2198:	81 e9       	ldi	r24, 0x91	; 145
    219a:	9c e2       	ldi	r25, 0x2C	; 44
    219c:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
    21a0:	86 e8       	ldi	r24, 0x86	; 134
    21a2:	9c e2       	ldi	r25, 0x2C	; 44
    21a4:	0e 94 70 03 	call	0x6e0	; 0x6e0 <vListInitialise>
    21a8:	81 e9       	ldi	r24, 0x91	; 145
    21aa:	9c e2       	ldi	r25, 0x2C	; 44
    21ac:	80 93 84 2c 	sts	0x2C84, r24	; 0x802c84 <pxCurrentTimerList>
    21b0:	90 93 85 2c 	sts	0x2C85, r25	; 0x802c85 <pxCurrentTimerList+0x1>
    21b4:	86 e8       	ldi	r24, 0x86	; 134
    21b6:	9c e2       	ldi	r25, 0x2C	; 44
    21b8:	80 93 82 2c 	sts	0x2C82, r24	; 0x802c82 <pxOverflowTimerList>
    21bc:	90 93 83 2c 	sts	0x2C83, r25	; 0x802c83 <pxOverflowTimerList+0x1>
    21c0:	40 e0       	ldi	r20, 0x00	; 0
    21c2:	69 e0       	ldi	r22, 0x09	; 9
    21c4:	85 e0       	ldi	r24, 0x05	; 5
    21c6:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <xQueueGenericCreate>
    21ca:	80 93 80 2c 	sts	0x2C80, r24	; 0x802c80 <xTimerQueue>
    21ce:	90 93 81 2c 	sts	0x2C81, r25	; 0x802c81 <xTimerQueue+0x1>
    21d2:	ff 91       	pop	r31
    21d4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    21d8:	08 95       	ret

000021da <xTimerCreateTimerTask>:
    21da:	ef 92       	push	r14
    21dc:	ff 92       	push	r15
    21de:	0f 93       	push	r16
    21e0:	0e 94 c0 10 	call	0x2180	; 0x2180 <prvCheckForValidListAndQueue>
    21e4:	80 91 80 2c 	lds	r24, 0x2C80	; 0x802c80 <xTimerQueue>
    21e8:	90 91 81 2c 	lds	r25, 0x2C81	; 0x802c81 <xTimerQueue+0x1>
    21ec:	89 2b       	or	r24, r25
    21ee:	91 f0       	breq	.+36     	; 0x2214 <xTimerCreateTimerTask+0x3a>
    21f0:	0f 2e       	mov	r0, r31
    21f2:	fe e7       	ldi	r31, 0x7E	; 126
    21f4:	ef 2e       	mov	r14, r31
    21f6:	fc e2       	ldi	r31, 0x2C	; 44
    21f8:	ff 2e       	mov	r15, r31
    21fa:	f0 2d       	mov	r31, r0
    21fc:	03 e0       	ldi	r16, 0x03	; 3
    21fe:	20 e0       	ldi	r18, 0x00	; 0
    2200:	30 e0       	ldi	r19, 0x00	; 0
    2202:	48 ec       	ldi	r20, 0xC8	; 200
    2204:	50 e0       	ldi	r21, 0x00	; 0
    2206:	65 e0       	ldi	r22, 0x05	; 5
    2208:	70 e2       	ldi	r23, 0x20	; 32
    220a:	80 e0       	ldi	r24, 0x00	; 0
    220c:	92 e1       	ldi	r25, 0x12	; 18
    220e:	0e 94 85 0a 	call	0x150a	; 0x150a <xTaskCreate>
    2212:	01 c0       	rjmp	.+2      	; 0x2216 <xTimerCreateTimerTask+0x3c>
    2214:	80 e0       	ldi	r24, 0x00	; 0
    2216:	0f 91       	pop	r16
    2218:	ff 90       	pop	r15
    221a:	ef 90       	pop	r14
    221c:	08 95       	ret

0000221e <xTimerGenericCommand>:
    221e:	8f 92       	push	r8
    2220:	9f 92       	push	r9
    2222:	af 92       	push	r10
    2224:	bf 92       	push	r11
    2226:	cf 92       	push	r12
    2228:	df 92       	push	r13
    222a:	ef 92       	push	r14
    222c:	ff 92       	push	r15
    222e:	0f 93       	push	r16
    2230:	1f 93       	push	r17
    2232:	cf 93       	push	r28
    2234:	df 93       	push	r29
    2236:	cd b7       	in	r28, 0x3d	; 61
    2238:	de b7       	in	r29, 0x3e	; 62
    223a:	29 97       	sbiw	r28, 0x09	; 9
    223c:	cd bf       	out	0x3d, r28	; 61
    223e:	de bf       	out	0x3e, r29	; 62
    2240:	e0 91 80 2c 	lds	r30, 0x2C80	; 0x802c80 <xTimerQueue>
    2244:	f0 91 81 2c 	lds	r31, 0x2C81	; 0x802c81 <xTimerQueue+0x1>
    2248:	30 97       	sbiw	r30, 0x00	; 0
    224a:	89 f1       	breq	.+98     	; 0x22ae <xTimerGenericCommand+0x90>
    224c:	69 83       	std	Y+1, r22	; 0x01
    224e:	2a 83       	std	Y+2, r18	; 0x02
    2250:	3b 83       	std	Y+3, r19	; 0x03
    2252:	4c 83       	std	Y+4, r20	; 0x04
    2254:	5d 83       	std	Y+5, r21	; 0x05
    2256:	8e 83       	std	Y+6, r24	; 0x06
    2258:	9f 83       	std	Y+7, r25	; 0x07
    225a:	66 30       	cpi	r22, 0x06	; 6
    225c:	fc f4       	brge	.+62     	; 0x229c <xTimerGenericCommand+0x7e>
    225e:	0e 94 35 0f 	call	0x1e6a	; 0x1e6a <xTaskGetSchedulerState>
    2262:	82 30       	cpi	r24, 0x02	; 2
    2264:	69 f4       	brne	.+26     	; 0x2280 <xTimerGenericCommand+0x62>
    2266:	00 e0       	ldi	r16, 0x00	; 0
    2268:	a7 01       	movw	r20, r14
    226a:	96 01       	movw	r18, r12
    226c:	be 01       	movw	r22, r28
    226e:	6f 5f       	subi	r22, 0xFF	; 255
    2270:	7f 4f       	sbci	r23, 0xFF	; 255
    2272:	80 91 80 2c 	lds	r24, 0x2C80	; 0x802c80 <xTimerQueue>
    2276:	90 91 81 2c 	lds	r25, 0x2C81	; 0x802c81 <xTimerQueue+0x1>
    227a:	0e 94 1a 07 	call	0xe34	; 0xe34 <xQueueGenericSend>
    227e:	18 c0       	rjmp	.+48     	; 0x22b0 <xTimerGenericCommand+0x92>
    2280:	00 e0       	ldi	r16, 0x00	; 0
    2282:	20 e0       	ldi	r18, 0x00	; 0
    2284:	30 e0       	ldi	r19, 0x00	; 0
    2286:	a9 01       	movw	r20, r18
    2288:	be 01       	movw	r22, r28
    228a:	6f 5f       	subi	r22, 0xFF	; 255
    228c:	7f 4f       	sbci	r23, 0xFF	; 255
    228e:	80 91 80 2c 	lds	r24, 0x2C80	; 0x802c80 <xTimerQueue>
    2292:	90 91 81 2c 	lds	r25, 0x2C81	; 0x802c81 <xTimerQueue+0x1>
    2296:	0e 94 1a 07 	call	0xe34	; 0xe34 <xQueueGenericSend>
    229a:	0a c0       	rjmp	.+20     	; 0x22b0 <xTimerGenericCommand+0x92>
    229c:	20 e0       	ldi	r18, 0x00	; 0
    229e:	a8 01       	movw	r20, r16
    22a0:	be 01       	movw	r22, r28
    22a2:	6f 5f       	subi	r22, 0xFF	; 255
    22a4:	7f 4f       	sbci	r23, 0xFF	; 255
    22a6:	cf 01       	movw	r24, r30
    22a8:	0e 94 dd 07 	call	0xfba	; 0xfba <xQueueGenericSendFromISR>
    22ac:	01 c0       	rjmp	.+2      	; 0x22b0 <xTimerGenericCommand+0x92>
    22ae:	80 e0       	ldi	r24, 0x00	; 0
    22b0:	29 96       	adiw	r28, 0x09	; 9
    22b2:	cd bf       	out	0x3d, r28	; 61
    22b4:	de bf       	out	0x3e, r29	; 62
    22b6:	df 91       	pop	r29
    22b8:	cf 91       	pop	r28
    22ba:	1f 91       	pop	r17
    22bc:	0f 91       	pop	r16
    22be:	ff 90       	pop	r15
    22c0:	ef 90       	pop	r14
    22c2:	df 90       	pop	r13
    22c4:	cf 90       	pop	r12
    22c6:	bf 90       	pop	r11
    22c8:	af 90       	pop	r10
    22ca:	9f 90       	pop	r9
    22cc:	8f 90       	pop	r8
    22ce:	08 95       	ret

000022d0 <prvSampleTimeNow>:
    22d0:	2f 92       	push	r2
    22d2:	3f 92       	push	r3
    22d4:	4f 92       	push	r4
    22d6:	5f 92       	push	r5
    22d8:	6f 92       	push	r6
    22da:	7f 92       	push	r7
    22dc:	8f 92       	push	r8
    22de:	9f 92       	push	r9
    22e0:	af 92       	push	r10
    22e2:	bf 92       	push	r11
    22e4:	cf 92       	push	r12
    22e6:	df 92       	push	r13
    22e8:	ef 92       	push	r14
    22ea:	ff 92       	push	r15
    22ec:	0f 93       	push	r16
    22ee:	1f 93       	push	r17
    22f0:	cf 93       	push	r28
    22f2:	df 93       	push	r29
    22f4:	1c 01       	movw	r2, r24
    22f6:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <xTaskGetTickCount>
    22fa:	2b 01       	movw	r4, r22
    22fc:	3c 01       	movw	r6, r24
    22fe:	80 91 7a 2c 	lds	r24, 0x2C7A	; 0x802c7a <xLastTime.4746>
    2302:	90 91 7b 2c 	lds	r25, 0x2C7B	; 0x802c7b <xLastTime.4746+0x1>
    2306:	a0 91 7c 2c 	lds	r26, 0x2C7C	; 0x802c7c <xLastTime.4746+0x2>
    230a:	b0 91 7d 2c 	lds	r27, 0x2C7D	; 0x802c7d <xLastTime.4746+0x3>
    230e:	48 16       	cp	r4, r24
    2310:	59 06       	cpc	r5, r25
    2312:	6a 06       	cpc	r6, r26
    2314:	7b 06       	cpc	r7, r27
    2316:	08 f0       	brcs	.+2      	; 0x231a <prvSampleTimeNow+0x4a>
    2318:	54 c0       	rjmp	.+168    	; 0x23c2 <prvSampleTimeNow+0xf2>
    231a:	3c c0       	rjmp	.+120    	; 0x2394 <prvSampleTimeNow+0xc4>
    231c:	07 80       	ldd	r0, Z+7	; 0x07
    231e:	f0 85       	ldd	r31, Z+8	; 0x08
    2320:	e0 2d       	mov	r30, r0
    2322:	80 80       	ld	r8, Z
    2324:	91 80       	ldd	r9, Z+1	; 0x01
    2326:	a2 80       	ldd	r10, Z+2	; 0x02
    2328:	b3 80       	ldd	r11, Z+3	; 0x03
    232a:	c0 85       	ldd	r28, Z+8	; 0x08
    232c:	d1 85       	ldd	r29, Z+9	; 0x09
    232e:	8e 01       	movw	r16, r28
    2330:	0e 5f       	subi	r16, 0xFE	; 254
    2332:	1f 4f       	sbci	r17, 0xFF	; 255
    2334:	c8 01       	movw	r24, r16
    2336:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
    233a:	ed 89       	ldd	r30, Y+21	; 0x15
    233c:	fe 89       	ldd	r31, Y+22	; 0x16
    233e:	ce 01       	movw	r24, r28
    2340:	19 95       	eicall
    2342:	8a 89       	ldd	r24, Y+18	; 0x12
    2344:	81 30       	cpi	r24, 0x01	; 1
    2346:	31 f5       	brne	.+76     	; 0x2394 <prvSampleTimeNow+0xc4>
    2348:	8e 85       	ldd	r24, Y+14	; 0x0e
    234a:	9f 85       	ldd	r25, Y+15	; 0x0f
    234c:	a8 89       	ldd	r26, Y+16	; 0x10
    234e:	b9 89       	ldd	r27, Y+17	; 0x11
    2350:	88 0d       	add	r24, r8
    2352:	99 1d       	adc	r25, r9
    2354:	aa 1d       	adc	r26, r10
    2356:	bb 1d       	adc	r27, r11
    2358:	88 16       	cp	r8, r24
    235a:	99 06       	cpc	r9, r25
    235c:	aa 06       	cpc	r10, r26
    235e:	bb 06       	cpc	r11, r27
    2360:	70 f4       	brcc	.+28     	; 0x237e <prvSampleTimeNow+0xae>
    2362:	8a 83       	std	Y+2, r24	; 0x02
    2364:	9b 83       	std	Y+3, r25	; 0x03
    2366:	ac 83       	std	Y+4, r26	; 0x04
    2368:	bd 83       	std	Y+5, r27	; 0x05
    236a:	ca 87       	std	Y+10, r28	; 0x0a
    236c:	db 87       	std	Y+11, r29	; 0x0b
    236e:	b8 01       	movw	r22, r16
    2370:	80 91 84 2c 	lds	r24, 0x2C84	; 0x802c84 <pxCurrentTimerList>
    2374:	90 91 85 2c 	lds	r25, 0x2C85	; 0x802c85 <pxCurrentTimerList+0x1>
    2378:	0e 94 a6 03 	call	0x74c	; 0x74c <vListInsert>
    237c:	0b c0       	rjmp	.+22     	; 0x2394 <prvSampleTimeNow+0xc4>
    237e:	c1 2c       	mov	r12, r1
    2380:	d1 2c       	mov	r13, r1
    2382:	76 01       	movw	r14, r12
    2384:	00 e0       	ldi	r16, 0x00	; 0
    2386:	10 e0       	ldi	r17, 0x00	; 0
    2388:	a5 01       	movw	r20, r10
    238a:	94 01       	movw	r18, r8
    238c:	60 e0       	ldi	r22, 0x00	; 0
    238e:	ce 01       	movw	r24, r28
    2390:	0e 94 0f 11 	call	0x221e	; 0x221e <xTimerGenericCommand>
    2394:	e0 91 84 2c 	lds	r30, 0x2C84	; 0x802c84 <pxCurrentTimerList>
    2398:	f0 91 85 2c 	lds	r31, 0x2C85	; 0x802c85 <pxCurrentTimerList+0x1>
    239c:	80 81       	ld	r24, Z
    239e:	81 11       	cpse	r24, r1
    23a0:	bd cf       	rjmp	.-134    	; 0x231c <prvSampleTimeNow+0x4c>
    23a2:	80 91 82 2c 	lds	r24, 0x2C82	; 0x802c82 <pxOverflowTimerList>
    23a6:	90 91 83 2c 	lds	r25, 0x2C83	; 0x802c83 <pxOverflowTimerList+0x1>
    23aa:	80 93 84 2c 	sts	0x2C84, r24	; 0x802c84 <pxCurrentTimerList>
    23ae:	90 93 85 2c 	sts	0x2C85, r25	; 0x802c85 <pxCurrentTimerList+0x1>
    23b2:	e0 93 82 2c 	sts	0x2C82, r30	; 0x802c82 <pxOverflowTimerList>
    23b6:	f0 93 83 2c 	sts	0x2C83, r31	; 0x802c83 <pxOverflowTimerList+0x1>
    23ba:	81 e0       	ldi	r24, 0x01	; 1
    23bc:	f1 01       	movw	r30, r2
    23be:	80 83       	st	Z, r24
    23c0:	02 c0       	rjmp	.+4      	; 0x23c6 <prvSampleTimeNow+0xf6>
    23c2:	f1 01       	movw	r30, r2
    23c4:	10 82       	st	Z, r1
    23c6:	40 92 7a 2c 	sts	0x2C7A, r4	; 0x802c7a <xLastTime.4746>
    23ca:	50 92 7b 2c 	sts	0x2C7B, r5	; 0x802c7b <xLastTime.4746+0x1>
    23ce:	60 92 7c 2c 	sts	0x2C7C, r6	; 0x802c7c <xLastTime.4746+0x2>
    23d2:	70 92 7d 2c 	sts	0x2C7D, r7	; 0x802c7d <xLastTime.4746+0x3>
    23d6:	c3 01       	movw	r24, r6
    23d8:	b2 01       	movw	r22, r4
    23da:	df 91       	pop	r29
    23dc:	cf 91       	pop	r28
    23de:	1f 91       	pop	r17
    23e0:	0f 91       	pop	r16
    23e2:	ff 90       	pop	r15
    23e4:	ef 90       	pop	r14
    23e6:	df 90       	pop	r13
    23e8:	cf 90       	pop	r12
    23ea:	bf 90       	pop	r11
    23ec:	af 90       	pop	r10
    23ee:	9f 90       	pop	r9
    23f0:	8f 90       	pop	r8
    23f2:	7f 90       	pop	r7
    23f4:	6f 90       	pop	r6
    23f6:	5f 90       	pop	r5
    23f8:	4f 90       	pop	r4
    23fa:	3f 90       	pop	r3
    23fc:	2f 90       	pop	r2
    23fe:	08 95       	ret

00002400 <prvTimerTask>:
    2400:	cf 93       	push	r28
    2402:	df 93       	push	r29
    2404:	cd b7       	in	r28, 0x3d	; 61
    2406:	de b7       	in	r29, 0x3e	; 62
    2408:	2e 97       	sbiw	r28, 0x0e	; 14
    240a:	cd bf       	out	0x3d, r28	; 61
    240c:	de bf       	out	0x3e, r29	; 62
    240e:	ce 01       	movw	r24, r28
    2410:	01 96       	adiw	r24, 0x01	; 1
    2412:	1c 01       	movw	r2, r24
    2414:	a8 2e       	mov	r10, r24
    2416:	b3 2c       	mov	r11, r3
    2418:	e0 91 84 2c 	lds	r30, 0x2C84	; 0x802c84 <pxCurrentTimerList>
    241c:	f0 91 85 2c 	lds	r31, 0x2C85	; 0x802c85 <pxCurrentTimerList+0x1>
    2420:	80 81       	ld	r24, Z
    2422:	88 23       	and	r24, r24
    2424:	09 f4       	brne	.+2      	; 0x2428 <prvTimerTask+0x28>
    2426:	03 c1       	rjmp	.+518    	; 0x262e <prvTimerTask+0x22e>
    2428:	07 80       	ldd	r0, Z+7	; 0x07
    242a:	f0 85       	ldd	r31, Z+8	; 0x08
    242c:	e0 2d       	mov	r30, r0
    242e:	40 80       	ld	r4, Z
    2430:	51 80       	ldd	r5, Z+1	; 0x01
    2432:	62 80       	ldd	r6, Z+2	; 0x02
    2434:	73 80       	ldd	r7, Z+3	; 0x03
    2436:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <vTaskSuspendAll>
    243a:	c1 01       	movw	r24, r2
    243c:	0e 94 68 11 	call	0x22d0	; 0x22d0 <prvSampleTimeNow>
    2440:	6b 87       	std	Y+11, r22	; 0x0b
    2442:	7c 87       	std	Y+12, r23	; 0x0c
    2444:	8d 87       	std	Y+13, r24	; 0x0d
    2446:	9e 87       	std	Y+14, r25	; 0x0e
    2448:	89 81       	ldd	r24, Y+1	; 0x01
    244a:	81 11       	cpse	r24, r1
    244c:	5e c0       	rjmp	.+188    	; 0x250a <prvTimerTask+0x10a>
    244e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2450:	9c 85       	ldd	r25, Y+12	; 0x0c
    2452:	ad 85       	ldd	r26, Y+13	; 0x0d
    2454:	be 85       	ldd	r27, Y+14	; 0x0e
    2456:	84 15       	cp	r24, r4
    2458:	95 05       	cpc	r25, r5
    245a:	a6 05       	cpc	r26, r6
    245c:	b7 05       	cpc	r27, r7
    245e:	e8 f1       	brcs	.+122    	; 0x24da <prvTimerTask+0xda>
    2460:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
    2464:	e0 91 84 2c 	lds	r30, 0x2C84	; 0x802c84 <pxCurrentTimerList>
    2468:	f0 91 85 2c 	lds	r31, 0x2C85	; 0x802c85 <pxCurrentTimerList+0x1>
    246c:	07 80       	ldd	r0, Z+7	; 0x07
    246e:	f0 85       	ldd	r31, Z+8	; 0x08
    2470:	e0 2d       	mov	r30, r0
    2472:	80 84       	ldd	r8, Z+8	; 0x08
    2474:	91 84       	ldd	r9, Z+9	; 0x09
    2476:	c4 01       	movw	r24, r8
    2478:	02 96       	adiw	r24, 0x02	; 2
    247a:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
    247e:	d4 01       	movw	r26, r8
    2480:	52 96       	adiw	r26, 0x12	; 18
    2482:	8c 91       	ld	r24, X
    2484:	52 97       	sbiw	r26, 0x12	; 18
    2486:	81 30       	cpi	r24, 0x01	; 1
    2488:	01 f5       	brne	.+64     	; 0x24ca <prvTimerTask+0xca>
    248a:	1e 96       	adiw	r26, 0x0e	; 14
    248c:	4d 91       	ld	r20, X+
    248e:	5d 91       	ld	r21, X+
    2490:	6d 91       	ld	r22, X+
    2492:	7c 91       	ld	r23, X
    2494:	51 97       	sbiw	r26, 0x11	; 17
    2496:	44 0d       	add	r20, r4
    2498:	55 1d       	adc	r21, r5
    249a:	66 1d       	adc	r22, r6
    249c:	77 1d       	adc	r23, r7
    249e:	73 01       	movw	r14, r6
    24a0:	62 01       	movw	r12, r4
    24a2:	0b 85       	ldd	r16, Y+11	; 0x0b
    24a4:	1c 85       	ldd	r17, Y+12	; 0x0c
    24a6:	2d 85       	ldd	r18, Y+13	; 0x0d
    24a8:	3e 85       	ldd	r19, Y+14	; 0x0e
    24aa:	c4 01       	movw	r24, r8
    24ac:	0e 94 77 10 	call	0x20ee	; 0x20ee <prvInsertTimerInActiveList>
    24b0:	88 23       	and	r24, r24
    24b2:	59 f0       	breq	.+22     	; 0x24ca <prvTimerTask+0xca>
    24b4:	c1 2c       	mov	r12, r1
    24b6:	d1 2c       	mov	r13, r1
    24b8:	76 01       	movw	r14, r12
    24ba:	00 e0       	ldi	r16, 0x00	; 0
    24bc:	10 e0       	ldi	r17, 0x00	; 0
    24be:	a3 01       	movw	r20, r6
    24c0:	92 01       	movw	r18, r4
    24c2:	60 e0       	ldi	r22, 0x00	; 0
    24c4:	c4 01       	movw	r24, r8
    24c6:	0e 94 0f 11 	call	0x221e	; 0x221e <xTimerGenericCommand>
    24ca:	d4 01       	movw	r26, r8
    24cc:	55 96       	adiw	r26, 0x15	; 21
    24ce:	ed 91       	ld	r30, X+
    24d0:	fc 91       	ld	r31, X
    24d2:	56 97       	sbiw	r26, 0x16	; 22
    24d4:	c4 01       	movw	r24, r8
    24d6:	19 95       	eicall
    24d8:	9c c0       	rjmp	.+312    	; 0x2612 <prvTimerTask+0x212>
    24da:	20 e0       	ldi	r18, 0x00	; 0
    24dc:	b3 01       	movw	r22, r6
    24de:	a2 01       	movw	r20, r4
    24e0:	8b 85       	ldd	r24, Y+11	; 0x0b
    24e2:	9c 85       	ldd	r25, Y+12	; 0x0c
    24e4:	ad 85       	ldd	r26, Y+13	; 0x0d
    24e6:	be 85       	ldd	r27, Y+14	; 0x0e
    24e8:	48 1b       	sub	r20, r24
    24ea:	59 0b       	sbc	r21, r25
    24ec:	6a 0b       	sbc	r22, r26
    24ee:	7b 0b       	sbc	r23, r27
    24f0:	80 91 80 2c 	lds	r24, 0x2C80	; 0x802c80 <xTimerQueue>
    24f4:	90 91 81 2c 	lds	r25, 0x2C81	; 0x802c81 <xTimerQueue+0x1>
    24f8:	0e 94 b9 09 	call	0x1372	; 0x1372 <vQueueWaitForMessageRestricted>
    24fc:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
    2500:	81 11       	cpse	r24, r1
    2502:	87 c0       	rjmp	.+270    	; 0x2612 <prvTimerTask+0x212>
    2504:	0e 94 ce 04 	call	0x99c	; 0x99c <vPortYield>
    2508:	84 c0       	rjmp	.+264    	; 0x2612 <prvTimerTask+0x212>
    250a:	0e 94 c2 0c 	call	0x1984	; 0x1984 <xTaskResumeAll>
    250e:	81 c0       	rjmp	.+258    	; 0x2612 <prvTimerTask+0x212>
    2510:	89 81       	ldd	r24, Y+1	; 0x01
    2512:	88 23       	and	r24, r24
    2514:	6c f4       	brge	.+26     	; 0x2530 <prvTimerTask+0x130>
    2516:	4e 81       	ldd	r20, Y+6	; 0x06
    2518:	5f 81       	ldd	r21, Y+7	; 0x07
    251a:	68 85       	ldd	r22, Y+8	; 0x08
    251c:	79 85       	ldd	r23, Y+9	; 0x09
    251e:	ea 81       	ldd	r30, Y+2	; 0x02
    2520:	fb 81       	ldd	r31, Y+3	; 0x03
    2522:	8c 81       	ldd	r24, Y+4	; 0x04
    2524:	9d 81       	ldd	r25, Y+5	; 0x05
    2526:	19 95       	eicall
    2528:	89 81       	ldd	r24, Y+1	; 0x01
    252a:	88 23       	and	r24, r24
    252c:	0c f4       	brge	.+2      	; 0x2530 <prvTimerTask+0x130>
    252e:	71 c0       	rjmp	.+226    	; 0x2612 <prvTimerTask+0x212>
    2530:	8e 80       	ldd	r8, Y+6	; 0x06
    2532:	9f 80       	ldd	r9, Y+7	; 0x07
    2534:	d4 01       	movw	r26, r8
    2536:	1c 96       	adiw	r26, 0x0c	; 12
    2538:	8d 91       	ld	r24, X+
    253a:	9c 91       	ld	r25, X
    253c:	1d 97       	sbiw	r26, 0x0d	; 13
    253e:	89 2b       	or	r24, r25
    2540:	21 f0       	breq	.+8      	; 0x254a <prvTimerTask+0x14a>
    2542:	c4 01       	movw	r24, r8
    2544:	02 96       	adiw	r24, 0x02	; 2
    2546:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <uxListRemove>
    254a:	ce 01       	movw	r24, r28
    254c:	0a 96       	adiw	r24, 0x0a	; 10
    254e:	0e 94 68 11 	call	0x22d0	; 0x22d0 <prvSampleTimeNow>
    2552:	8b 01       	movw	r16, r22
    2554:	9c 01       	movw	r18, r24
    2556:	89 81       	ldd	r24, Y+1	; 0x01
    2558:	08 2e       	mov	r0, r24
    255a:	00 0c       	add	r0, r0
    255c:	99 0b       	sbc	r25, r25
    255e:	aa 0b       	sbc	r26, r26
    2560:	bb 0b       	sbc	r27, r27
    2562:	8a 30       	cpi	r24, 0x0A	; 10
    2564:	91 05       	cpc	r25, r1
    2566:	08 f0       	brcs	.+2      	; 0x256a <prvTimerTask+0x16a>
    2568:	54 c0       	rjmp	.+168    	; 0x2612 <prvTimerTask+0x212>
    256a:	fc 01       	movw	r30, r24
    256c:	88 27       	eor	r24, r24
    256e:	e2 50       	subi	r30, 0x02	; 2
    2570:	ff 4f       	sbci	r31, 0xFF	; 255
    2572:	8f 4f       	sbci	r24, 0xFF	; 255
    2574:	0c 94 90 1d 	jmp	0x3b20	; 0x3b20 <__tablejump2__>
    2578:	ca 80       	ldd	r12, Y+2	; 0x02
    257a:	db 80       	ldd	r13, Y+3	; 0x03
    257c:	ec 80       	ldd	r14, Y+4	; 0x04
    257e:	fd 80       	ldd	r15, Y+5	; 0x05
    2580:	f4 01       	movw	r30, r8
    2582:	46 85       	ldd	r20, Z+14	; 0x0e
    2584:	57 85       	ldd	r21, Z+15	; 0x0f
    2586:	60 89       	ldd	r22, Z+16	; 0x10
    2588:	71 89       	ldd	r23, Z+17	; 0x11
    258a:	4c 0d       	add	r20, r12
    258c:	5d 1d       	adc	r21, r13
    258e:	6e 1d       	adc	r22, r14
    2590:	7f 1d       	adc	r23, r15
    2592:	c4 01       	movw	r24, r8
    2594:	0e 94 77 10 	call	0x20ee	; 0x20ee <prvInsertTimerInActiveList>
    2598:	88 23       	and	r24, r24
    259a:	d9 f1       	breq	.+118    	; 0x2612 <prvTimerTask+0x212>
    259c:	d4 01       	movw	r26, r8
    259e:	55 96       	adiw	r26, 0x15	; 21
    25a0:	ed 91       	ld	r30, X+
    25a2:	fc 91       	ld	r31, X
    25a4:	56 97       	sbiw	r26, 0x16	; 22
    25a6:	c4 01       	movw	r24, r8
    25a8:	19 95       	eicall
    25aa:	f4 01       	movw	r30, r8
    25ac:	82 89       	ldd	r24, Z+18	; 0x12
    25ae:	81 30       	cpi	r24, 0x01	; 1
    25b0:	81 f5       	brne	.+96     	; 0x2612 <prvTimerTask+0x212>
    25b2:	4a 81       	ldd	r20, Y+2	; 0x02
    25b4:	5b 81       	ldd	r21, Y+3	; 0x03
    25b6:	6c 81       	ldd	r22, Y+4	; 0x04
    25b8:	7d 81       	ldd	r23, Y+5	; 0x05
    25ba:	86 85       	ldd	r24, Z+14	; 0x0e
    25bc:	97 85       	ldd	r25, Z+15	; 0x0f
    25be:	a0 89       	ldd	r26, Z+16	; 0x10
    25c0:	b1 89       	ldd	r27, Z+17	; 0x11
    25c2:	9a 01       	movw	r18, r20
    25c4:	ab 01       	movw	r20, r22
    25c6:	28 0f       	add	r18, r24
    25c8:	39 1f       	adc	r19, r25
    25ca:	4a 1f       	adc	r20, r26
    25cc:	5b 1f       	adc	r21, r27
    25ce:	c1 2c       	mov	r12, r1
    25d0:	d1 2c       	mov	r13, r1
    25d2:	76 01       	movw	r14, r12
    25d4:	00 e0       	ldi	r16, 0x00	; 0
    25d6:	10 e0       	ldi	r17, 0x00	; 0
    25d8:	60 e0       	ldi	r22, 0x00	; 0
    25da:	c4 01       	movw	r24, r8
    25dc:	0e 94 0f 11 	call	0x221e	; 0x221e <xTimerGenericCommand>
    25e0:	18 c0       	rjmp	.+48     	; 0x2612 <prvTimerTask+0x212>
    25e2:	4a 81       	ldd	r20, Y+2	; 0x02
    25e4:	5b 81       	ldd	r21, Y+3	; 0x03
    25e6:	6c 81       	ldd	r22, Y+4	; 0x04
    25e8:	7d 81       	ldd	r23, Y+5	; 0x05
    25ea:	d4 01       	movw	r26, r8
    25ec:	1e 96       	adiw	r26, 0x0e	; 14
    25ee:	4d 93       	st	X+, r20
    25f0:	5d 93       	st	X+, r21
    25f2:	6d 93       	st	X+, r22
    25f4:	7c 93       	st	X, r23
    25f6:	51 97       	sbiw	r26, 0x11	; 17
    25f8:	40 0f       	add	r20, r16
    25fa:	51 1f       	adc	r21, r17
    25fc:	62 1f       	adc	r22, r18
    25fe:	73 1f       	adc	r23, r19
    2600:	68 01       	movw	r12, r16
    2602:	79 01       	movw	r14, r18
    2604:	c4 01       	movw	r24, r8
    2606:	0e 94 77 10 	call	0x20ee	; 0x20ee <prvInsertTimerInActiveList>
    260a:	03 c0       	rjmp	.+6      	; 0x2612 <prvTimerTask+0x212>
    260c:	c4 01       	movw	r24, r8
    260e:	0e 94 6f 03 	call	0x6de	; 0x6de <vPortFree>
    2612:	20 e0       	ldi	r18, 0x00	; 0
    2614:	30 e0       	ldi	r19, 0x00	; 0
    2616:	a9 01       	movw	r20, r18
    2618:	6a 2d       	mov	r22, r10
    261a:	7b 2d       	mov	r23, r11
    261c:	80 91 80 2c 	lds	r24, 0x2C80	; 0x802c80 <xTimerQueue>
    2620:	90 91 81 2c 	lds	r25, 0x2C81	; 0x802c81 <xTimerQueue+0x1>
    2624:	0e 94 22 08 	call	0x1044	; 0x1044 <xQueueReceive>
    2628:	81 11       	cpse	r24, r1
    262a:	72 cf       	rjmp	.-284    	; 0x2510 <prvTimerTask+0x110>
    262c:	f5 ce       	rjmp	.-534    	; 0x2418 <prvTimerTask+0x18>
    262e:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <vTaskSuspendAll>
    2632:	c1 01       	movw	r24, r2
    2634:	0e 94 68 11 	call	0x22d0	; 0x22d0 <prvSampleTimeNow>
    2638:	6b 87       	std	Y+11, r22	; 0x0b
    263a:	7c 87       	std	Y+12, r23	; 0x0c
    263c:	8d 87       	std	Y+13, r24	; 0x0d
    263e:	9e 87       	std	Y+14, r25	; 0x0e
    2640:	89 81       	ldd	r24, Y+1	; 0x01
    2642:	81 11       	cpse	r24, r1
    2644:	62 cf       	rjmp	.-316    	; 0x250a <prvTimerTask+0x10a>
    2646:	e0 91 82 2c 	lds	r30, 0x2C82	; 0x802c82 <pxOverflowTimerList>
    264a:	f0 91 83 2c 	lds	r31, 0x2C83	; 0x802c83 <pxOverflowTimerList+0x1>
    264e:	80 81       	ld	r24, Z
    2650:	21 e0       	ldi	r18, 0x01	; 1
    2652:	81 11       	cpse	r24, r1
    2654:	20 e0       	ldi	r18, 0x00	; 0
    2656:	41 2c       	mov	r4, r1
    2658:	51 2c       	mov	r5, r1
    265a:	32 01       	movw	r6, r4
    265c:	3f cf       	rjmp	.-386    	; 0x24dc <prvTimerTask+0xdc>

0000265e <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
    265e:	0f 93       	push	r16
    2660:	1f 93       	push	r17
    2662:	cf 93       	push	r28
    2664:	df 93       	push	r29
    2666:	cd b7       	in	r28, 0x3d	; 61
    2668:	de b7       	in	r29, 0x3e	; 62
    266a:	29 97       	sbiw	r28, 0x09	; 9
    266c:	cd bf       	out	0x3d, r28	; 61
    266e:	de bf       	out	0x3e, r29	; 62
	DaemonTaskMessage_t xMessage;
	BaseType_t xReturn;

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
    2670:	ee ef       	ldi	r30, 0xFE	; 254
    2672:	e9 83       	std	Y+1, r30	; 0x01
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    2674:	8a 83       	std	Y+2, r24	; 0x02
    2676:	9b 83       	std	Y+3, r25	; 0x03
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    2678:	6c 83       	std	Y+4, r22	; 0x04
    267a:	7d 83       	std	Y+5, r23	; 0x05
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    267c:	2e 83       	std	Y+6, r18	; 0x06
    267e:	3f 83       	std	Y+7, r19	; 0x07
    2680:	48 87       	std	Y+8, r20	; 0x08
    2682:	59 87       	std	Y+9, r21	; 0x09

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2684:	20 e0       	ldi	r18, 0x00	; 0
    2686:	a8 01       	movw	r20, r16
    2688:	be 01       	movw	r22, r28
    268a:	6f 5f       	subi	r22, 0xFF	; 255
    268c:	7f 4f       	sbci	r23, 0xFF	; 255
    268e:	80 91 80 2c 	lds	r24, 0x2C80	; 0x802c80 <xTimerQueue>
    2692:	90 91 81 2c 	lds	r25, 0x2C81	; 0x802c81 <xTimerQueue+0x1>
    2696:	0e 94 dd 07 	call	0xfba	; 0xfba <xQueueGenericSendFromISR>

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
	}
    269a:	29 96       	adiw	r28, 0x09	; 9
    269c:	cd bf       	out	0x3d, r28	; 61
    269e:	de bf       	out	0x3e, r29	; 62
    26a0:	df 91       	pop	r29
    26a2:	cf 91       	pop	r28
    26a4:	1f 91       	pop	r17
    26a6:	0f 91       	pop	r16
    26a8:	08 95       	ret

000026aa <vInitClock>:
#include "clksys_driver.h"


void vInitClock(void)
{
	CLKSYS_Enable( OSC_RC2MEN_bm );
    26aa:	e0 e5       	ldi	r30, 0x50	; 80
    26ac:	f0 e0       	ldi	r31, 0x00	; 0
    26ae:	80 81       	ld	r24, Z
    26b0:	81 60       	ori	r24, 0x01	; 1
    26b2:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC2MRDY_bm ) == 0 );
    26b4:	81 81       	ldd	r24, Z+1	; 0x01
    26b6:	80 ff       	sbrs	r24, 0
    26b8:	fd cf       	rjmp	.-6      	; 0x26b4 <vInitClock+0xa>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC2M_gc );
    26ba:	80 e0       	ldi	r24, 0x00	; 0
    26bc:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC32KEN_bm | OSC_XOSCEN_bm | OSC_PLLEN_bm);
    26c0:	8e e1       	ldi	r24, 0x1E	; 30
    26c2:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <CLKSYS_Disable>
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    26c6:	60 e0       	ldi	r22, 0x00	; 0
    26c8:	80 e0       	ldi	r24, 0x00	; 0
    26ca:	0e 94 75 01 	call	0x2ea	; 0x2ea <CLKSYS_Prescalers_Config>
	CLKSYS_XOSC_Config( OSC_FRQRANGE_2TO9_gc,false,OSC_XOSCSEL_XTAL_256CLK_gc );
    26ce:	43 e0       	ldi	r20, 0x03	; 3
    26d0:	60 e0       	ldi	r22, 0x00	; 0
    26d2:	80 e4       	ldi	r24, 0x40	; 64
    26d4:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <CLKSYS_XOSC_Config>
	CLKSYS_Enable( OSC_XOSCEN_bm );
    26d8:	e0 e5       	ldi	r30, 0x50	; 80
    26da:	f0 e0       	ldi	r31, 0x00	; 0
    26dc:	80 81       	ld	r24, Z
    26de:	88 60       	ori	r24, 0x08	; 8
    26e0:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    26e2:	81 81       	ldd	r24, Z+1	; 0x01
    26e4:	83 ff       	sbrs	r24, 3
    26e6:	fd cf       	rjmp	.-6      	; 0x26e2 <vInitClock+0x38>
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 4 );
    26e8:	64 e0       	ldi	r22, 0x04	; 4
    26ea:	80 ec       	ldi	r24, 0xC0	; 192
    26ec:	0e 94 66 01 	call	0x2cc	; 0x2cc <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    26f0:	e0 e5       	ldi	r30, 0x50	; 80
    26f2:	f0 e0       	ldi	r31, 0x00	; 0
    26f4:	80 81       	ld	r24, Z
    26f6:	80 61       	ori	r24, 0x10	; 16
    26f8:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    26fa:	60 e0       	ldi	r22, 0x00	; 0
    26fc:	80 e0       	ldi	r24, 0x00	; 0
    26fe:	0e 94 75 01 	call	0x2ea	; 0x2ea <CLKSYS_Prescalers_Config>
	do {} while ( CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    2702:	e0 e5       	ldi	r30, 0x50	; 80
    2704:	f0 e0       	ldi	r31, 0x00	; 0
    2706:	81 81       	ldd	r24, Z+1	; 0x01
    2708:	84 ff       	sbrs	r24, 4
    270a:	fd cf       	rjmp	.-6      	; 0x2706 <vInitClock+0x5c>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    270c:	84 e0       	ldi	r24, 0x04	; 4
    270e:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC2MEN_bm | OSC_RC32KEN_bm);
    2712:	87 e0       	ldi	r24, 0x07	; 7
    2714:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <CLKSYS_Disable>
    2718:	08 95       	ret

0000271a <vT1>:
	vTaskStartScheduler();
	return 0;
}

void vT1(void *pvParameters) {	
	uint32_t cTaskCounter = 0;
    271a:	41 2c       	mov	r4, r1
    271c:	51 2c       	mov	r5, r1
    271e:	32 01       	movw	r6, r4
	for(;;) {
		if(xSemaphoreTake(data2Key, 5 / portTICK_RATE_MS)) { //Lock P-Resource data2			
			vTaskDelay(101 / portTICK_RATE_MS);
			PORTF.OUTCLR = 0x01;
    2720:	c0 ea       	ldi	r28, 0xA0	; 160
    2722:	d6 e0       	ldi	r29, 0x06	; 6
    2724:	11 e0       	ldi	r17, 0x01	; 1
			cTaskCounter++;
			data2 = cTaskCounter;
			if(xSemaphoreTake(data1Key, 5 / portTICK_RATE_MS)) { //Lock P-Resource data1
				vDisplayWriteStringAtPos(0,0,"Task1Counter: %d", cTaskCounter);
    2726:	0f 2e       	mov	r0, r31
    2728:	fd e0       	ldi	r31, 0x0D	; 13
    272a:	af 2e       	mov	r10, r31
    272c:	f0 e2       	ldi	r31, 0x20	; 32
    272e:	bf 2e       	mov	r11, r31
    2730:	f0 2d       	mov	r31, r0
				vDisplayWriteStringAtPos(1,0,"d1: %d / ", data1);
    2732:	0f 2e       	mov	r0, r31
    2734:	fe e1       	ldi	r31, 0x1E	; 30
    2736:	cf 2e       	mov	r12, r31
    2738:	f0 e2       	ldi	r31, 0x20	; 32
    273a:	df 2e       	mov	r13, r31
    273c:	f0 2d       	mov	r31, r0
				vDisplayWriteStringAtPos(1,12, "d2:%d", data2);
    273e:	0f 2e       	mov	r0, r31
    2740:	f8 e2       	ldi	r31, 0x28	; 40
    2742:	ef 2e       	mov	r14, r31
    2744:	f0 e2       	ldi	r31, 0x20	; 32
    2746:	ff 2e       	mov	r15, r31
    2748:	f0 2d       	mov	r31, r0
    274a:	0f 2e       	mov	r0, r31
    274c:	fc e0       	ldi	r31, 0x0C	; 12
    274e:	9f 2e       	mov	r9, r31
    2750:	f0 2d       	mov	r31, r0
}

void vT1(void *pvParameters) {	
	uint32_t cTaskCounter = 0;
	for(;;) {
		if(xSemaphoreTake(data2Key, 5 / portTICK_RATE_MS)) { //Lock P-Resource data2			
    2752:	45 e0       	ldi	r20, 0x05	; 5
    2754:	50 e0       	ldi	r21, 0x00	; 0
    2756:	60 e0       	ldi	r22, 0x00	; 0
    2758:	70 e0       	ldi	r23, 0x00	; 0
    275a:	80 91 cf 2c 	lds	r24, 0x2CCF	; 0x802ccf <data2Key>
    275e:	90 91 d0 2c 	lds	r25, 0x2CD0	; 0x802cd0 <data2Key+0x1>
    2762:	0e 94 c8 08 	call	0x1190	; 0x1190 <xQueueSemaphoreTake>
    2766:	88 23       	and	r24, r24
    2768:	a1 f3       	breq	.-24     	; 0x2752 <vT1+0x38>
			vTaskDelay(101 / portTICK_RATE_MS);
    276a:	65 e6       	ldi	r22, 0x65	; 101
    276c:	70 e0       	ldi	r23, 0x00	; 0
    276e:	80 e0       	ldi	r24, 0x00	; 0
    2770:	90 e0       	ldi	r25, 0x00	; 0
    2772:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <vTaskDelay>
			PORTF.OUTCLR = 0x01;
    2776:	1e 83       	std	Y+6, r17	; 0x06
			cTaskCounter++;
    2778:	8f ef       	ldi	r24, 0xFF	; 255
    277a:	48 1a       	sub	r4, r24
    277c:	58 0a       	sbc	r5, r24
    277e:	68 0a       	sbc	r6, r24
    2780:	78 0a       	sbc	r7, r24
			data2 = cTaskCounter;
    2782:	40 92 9c 2c 	sts	0x2C9C, r4	; 0x802c9c <data2>
    2786:	50 92 9d 2c 	sts	0x2C9D, r5	; 0x802c9d <data2+0x1>
    278a:	60 92 9e 2c 	sts	0x2C9E, r6	; 0x802c9e <data2+0x2>
    278e:	70 92 9f 2c 	sts	0x2C9F, r7	; 0x802c9f <data2+0x3>
			if(xSemaphoreTake(data1Key, 5 / portTICK_RATE_MS)) { //Lock P-Resource data1
    2792:	45 e0       	ldi	r20, 0x05	; 5
    2794:	50 e0       	ldi	r21, 0x00	; 0
    2796:	60 e0       	ldi	r22, 0x00	; 0
    2798:	70 e0       	ldi	r23, 0x00	; 0
    279a:	80 91 cd 2c 	lds	r24, 0x2CCD	; 0x802ccd <data1Key>
    279e:	90 91 ce 2c 	lds	r25, 0x2CCE	; 0x802cce <data1Key+0x1>
    27a2:	0e 94 c8 08 	call	0x1190	; 0x1190 <xQueueSemaphoreTake>
    27a6:	88 23       	and	r24, r24
    27a8:	c9 f1       	breq	.+114    	; 0x281c <vT1+0x102>
				vDisplayWriteStringAtPos(0,0,"Task1Counter: %d", cTaskCounter);
    27aa:	7f 92       	push	r7
    27ac:	6f 92       	push	r6
    27ae:	5f 92       	push	r5
    27b0:	4f 92       	push	r4
    27b2:	bf 92       	push	r11
    27b4:	af 92       	push	r10
    27b6:	1f 92       	push	r1
    27b8:	1f 92       	push	r1
    27ba:	1f 92       	push	r1
    27bc:	1f 92       	push	r1
    27be:	0e 94 89 17 	call	0x2f12	; 0x2f12 <vDisplayWriteStringAtPos>
				vDisplayWriteStringAtPos(1,0,"d1: %d / ", data1);
    27c2:	80 91 a3 2c 	lds	r24, 0x2CA3	; 0x802ca3 <data1+0x3>
    27c6:	8f 93       	push	r24
    27c8:	80 91 a2 2c 	lds	r24, 0x2CA2	; 0x802ca2 <data1+0x2>
    27cc:	8f 93       	push	r24
    27ce:	80 91 a1 2c 	lds	r24, 0x2CA1	; 0x802ca1 <data1+0x1>
    27d2:	8f 93       	push	r24
    27d4:	80 91 a0 2c 	lds	r24, 0x2CA0	; 0x802ca0 <data1>
    27d8:	8f 93       	push	r24
    27da:	df 92       	push	r13
    27dc:	cf 92       	push	r12
    27de:	1f 92       	push	r1
    27e0:	1f 92       	push	r1
    27e2:	1f 92       	push	r1
    27e4:	1f 93       	push	r17
    27e6:	0e 94 89 17 	call	0x2f12	; 0x2f12 <vDisplayWriteStringAtPos>
				vDisplayWriteStringAtPos(1,12, "d2:%d", data2);
    27ea:	80 91 9f 2c 	lds	r24, 0x2C9F	; 0x802c9f <data2+0x3>
    27ee:	8f 93       	push	r24
    27f0:	80 91 9e 2c 	lds	r24, 0x2C9E	; 0x802c9e <data2+0x2>
    27f4:	8f 93       	push	r24
    27f6:	80 91 9d 2c 	lds	r24, 0x2C9D	; 0x802c9d <data2+0x1>
    27fa:	8f 93       	push	r24
    27fc:	80 91 9c 2c 	lds	r24, 0x2C9C	; 0x802c9c <data2>
    2800:	8f 93       	push	r24
    2802:	ff 92       	push	r15
    2804:	ef 92       	push	r14
    2806:	1f 92       	push	r1
    2808:	9f 92       	push	r9
    280a:	1f 92       	push	r1
    280c:	1f 93       	push	r17
    280e:	0e 94 89 17 	call	0x2f12	; 0x2f12 <vDisplayWriteStringAtPos>
    2812:	8d b7       	in	r24, 0x3d	; 61
    2814:	9e b7       	in	r25, 0x3e	; 62
    2816:	4e 96       	adiw	r24, 0x1e	; 30
    2818:	8d bf       	out	0x3d, r24	; 61
    281a:	9e bf       	out	0x3e, r25	; 62
			}
			xSemaphoreGive(data1Key); //Unlock data1
    281c:	00 e0       	ldi	r16, 0x00	; 0
    281e:	20 e0       	ldi	r18, 0x00	; 0
    2820:	30 e0       	ldi	r19, 0x00	; 0
    2822:	a9 01       	movw	r20, r18
    2824:	60 e0       	ldi	r22, 0x00	; 0
    2826:	70 e0       	ldi	r23, 0x00	; 0
    2828:	80 91 cd 2c 	lds	r24, 0x2CCD	; 0x802ccd <data1Key>
    282c:	90 91 ce 2c 	lds	r25, 0x2CCE	; 0x802cce <data1Key+0x1>
    2830:	0e 94 1a 07 	call	0xe34	; 0xe34 <xQueueGenericSend>
			xSemaphoreGive(data2Key); //Unlock data2
    2834:	20 e0       	ldi	r18, 0x00	; 0
    2836:	30 e0       	ldi	r19, 0x00	; 0
    2838:	a9 01       	movw	r20, r18
    283a:	60 e0       	ldi	r22, 0x00	; 0
    283c:	70 e0       	ldi	r23, 0x00	; 0
    283e:	80 91 cf 2c 	lds	r24, 0x2CCF	; 0x802ccf <data2Key>
    2842:	90 91 d0 2c 	lds	r25, 0x2CD0	; 0x802cd0 <data2Key+0x1>
    2846:	0e 94 1a 07 	call	0xe34	; 0xe34 <xQueueGenericSend>
			PORTF.OUTSET = 0x01;
    284a:	1d 83       	std	Y+5, r17	; 0x05
    284c:	82 cf       	rjmp	.-252    	; 0x2752 <vT1+0x38>

0000284e <vT2>:
		}
	}
}

void vT2(void *pvParameters) {
	uint32_t dTaskCounter = 0;
    284e:	41 2c       	mov	r4, r1
    2850:	51 2c       	mov	r5, r1
    2852:	32 01       	movw	r6, r4
	for(;;) {
		if(xSemaphoreTake(data1Key, 5 / portTICK_RATE_MS)) { //Lock Resource data1
			vTaskDelay(100 / portTICK_RATE_MS);		
			PORTF.OUTCLR = 0x02;
    2854:	c0 ea       	ldi	r28, 0xA0	; 160
    2856:	d6 e0       	ldi	r29, 0x06	; 6
    2858:	12 e0       	ldi	r17, 0x02	; 2
			dTaskCounter++;
			data1 = dTaskCounter;
			if(xSemaphoreTake(data2Key, 5 / portTICK_RATE_MS)) { //Lock Resource data2
				vDisplayWriteStringAtPos(2,0,"Task2Counter: %d", dTaskCounter);
    285a:	0f 2e       	mov	r0, r31
    285c:	fe e2       	ldi	r31, 0x2E	; 46
    285e:	af 2e       	mov	r10, r31
    2860:	f0 e2       	ldi	r31, 0x20	; 32
    2862:	bf 2e       	mov	r11, r31
    2864:	f0 2d       	mov	r31, r0
				vDisplayWriteStringAtPos(3,0,"d1: %d / ", data1);
    2866:	0f 2e       	mov	r0, r31
    2868:	fe e1       	ldi	r31, 0x1E	; 30
    286a:	cf 2e       	mov	r12, r31
    286c:	f0 e2       	ldi	r31, 0x20	; 32
    286e:	df 2e       	mov	r13, r31
    2870:	f0 2d       	mov	r31, r0
    2872:	0f 2e       	mov	r0, r31
    2874:	f3 e0       	ldi	r31, 0x03	; 3
    2876:	9f 2e       	mov	r9, r31
    2878:	f0 2d       	mov	r31, r0
				vDisplayWriteStringAtPos(3,12, "d2:%d", data2);
    287a:	0f 2e       	mov	r0, r31
    287c:	f8 e2       	ldi	r31, 0x28	; 40
    287e:	ef 2e       	mov	r14, r31
    2880:	f0 e2       	ldi	r31, 0x20	; 32
    2882:	ff 2e       	mov	r15, r31
    2884:	f0 2d       	mov	r31, r0
    2886:	0f 2e       	mov	r0, r31
    2888:	fc e0       	ldi	r31, 0x0C	; 12
    288a:	8f 2e       	mov	r8, r31
    288c:	f0 2d       	mov	r31, r0
}

void vT2(void *pvParameters) {
	uint32_t dTaskCounter = 0;
	for(;;) {
		if(xSemaphoreTake(data1Key, 5 / portTICK_RATE_MS)) { //Lock Resource data1
    288e:	45 e0       	ldi	r20, 0x05	; 5
    2890:	50 e0       	ldi	r21, 0x00	; 0
    2892:	60 e0       	ldi	r22, 0x00	; 0
    2894:	70 e0       	ldi	r23, 0x00	; 0
    2896:	80 91 cd 2c 	lds	r24, 0x2CCD	; 0x802ccd <data1Key>
    289a:	90 91 ce 2c 	lds	r25, 0x2CCE	; 0x802cce <data1Key+0x1>
    289e:	0e 94 c8 08 	call	0x1190	; 0x1190 <xQueueSemaphoreTake>
    28a2:	88 23       	and	r24, r24
    28a4:	a1 f3       	breq	.-24     	; 0x288e <vT2+0x40>
			vTaskDelay(100 / portTICK_RATE_MS);		
    28a6:	64 e6       	ldi	r22, 0x64	; 100
    28a8:	70 e0       	ldi	r23, 0x00	; 0
    28aa:	80 e0       	ldi	r24, 0x00	; 0
    28ac:	90 e0       	ldi	r25, 0x00	; 0
    28ae:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <vTaskDelay>
			PORTF.OUTCLR = 0x02;
    28b2:	1e 83       	std	Y+6, r17	; 0x06
			dTaskCounter++;
    28b4:	8f ef       	ldi	r24, 0xFF	; 255
    28b6:	48 1a       	sub	r4, r24
    28b8:	58 0a       	sbc	r5, r24
    28ba:	68 0a       	sbc	r6, r24
    28bc:	78 0a       	sbc	r7, r24
			data1 = dTaskCounter;
    28be:	40 92 a0 2c 	sts	0x2CA0, r4	; 0x802ca0 <data1>
    28c2:	50 92 a1 2c 	sts	0x2CA1, r5	; 0x802ca1 <data1+0x1>
    28c6:	60 92 a2 2c 	sts	0x2CA2, r6	; 0x802ca2 <data1+0x2>
    28ca:	70 92 a3 2c 	sts	0x2CA3, r7	; 0x802ca3 <data1+0x3>
			if(xSemaphoreTake(data2Key, 5 / portTICK_RATE_MS)) { //Lock Resource data2
    28ce:	45 e0       	ldi	r20, 0x05	; 5
    28d0:	50 e0       	ldi	r21, 0x00	; 0
    28d2:	60 e0       	ldi	r22, 0x00	; 0
    28d4:	70 e0       	ldi	r23, 0x00	; 0
    28d6:	80 91 cf 2c 	lds	r24, 0x2CCF	; 0x802ccf <data2Key>
    28da:	90 91 d0 2c 	lds	r25, 0x2CD0	; 0x802cd0 <data2Key+0x1>
    28de:	0e 94 c8 08 	call	0x1190	; 0x1190 <xQueueSemaphoreTake>
    28e2:	88 23       	and	r24, r24
    28e4:	c9 f1       	breq	.+114    	; 0x2958 <vT2+0x10a>
				vDisplayWriteStringAtPos(2,0,"Task2Counter: %d", dTaskCounter);
    28e6:	7f 92       	push	r7
    28e8:	6f 92       	push	r6
    28ea:	5f 92       	push	r5
    28ec:	4f 92       	push	r4
    28ee:	bf 92       	push	r11
    28f0:	af 92       	push	r10
    28f2:	1f 92       	push	r1
    28f4:	1f 92       	push	r1
    28f6:	1f 92       	push	r1
    28f8:	1f 93       	push	r17
    28fa:	0e 94 89 17 	call	0x2f12	; 0x2f12 <vDisplayWriteStringAtPos>
				vDisplayWriteStringAtPos(3,0,"d1: %d / ", data1);
    28fe:	80 91 a3 2c 	lds	r24, 0x2CA3	; 0x802ca3 <data1+0x3>
    2902:	8f 93       	push	r24
    2904:	80 91 a2 2c 	lds	r24, 0x2CA2	; 0x802ca2 <data1+0x2>
    2908:	8f 93       	push	r24
    290a:	80 91 a1 2c 	lds	r24, 0x2CA1	; 0x802ca1 <data1+0x1>
    290e:	8f 93       	push	r24
    2910:	80 91 a0 2c 	lds	r24, 0x2CA0	; 0x802ca0 <data1>
    2914:	8f 93       	push	r24
    2916:	df 92       	push	r13
    2918:	cf 92       	push	r12
    291a:	1f 92       	push	r1
    291c:	1f 92       	push	r1
    291e:	1f 92       	push	r1
    2920:	9f 92       	push	r9
    2922:	0e 94 89 17 	call	0x2f12	; 0x2f12 <vDisplayWriteStringAtPos>
				vDisplayWriteStringAtPos(3,12, "d2:%d", data2);
    2926:	80 91 9f 2c 	lds	r24, 0x2C9F	; 0x802c9f <data2+0x3>
    292a:	8f 93       	push	r24
    292c:	80 91 9e 2c 	lds	r24, 0x2C9E	; 0x802c9e <data2+0x2>
    2930:	8f 93       	push	r24
    2932:	80 91 9d 2c 	lds	r24, 0x2C9D	; 0x802c9d <data2+0x1>
    2936:	8f 93       	push	r24
    2938:	80 91 9c 2c 	lds	r24, 0x2C9C	; 0x802c9c <data2>
    293c:	8f 93       	push	r24
    293e:	ff 92       	push	r15
    2940:	ef 92       	push	r14
    2942:	1f 92       	push	r1
    2944:	8f 92       	push	r8
    2946:	1f 92       	push	r1
    2948:	9f 92       	push	r9
    294a:	0e 94 89 17 	call	0x2f12	; 0x2f12 <vDisplayWriteStringAtPos>
    294e:	8d b7       	in	r24, 0x3d	; 61
    2950:	9e b7       	in	r25, 0x3e	; 62
    2952:	4e 96       	adiw	r24, 0x1e	; 30
    2954:	8d bf       	out	0x3d, r24	; 61
    2956:	9e bf       	out	0x3e, r25	; 62
			}
			xSemaphoreGive(data1Key); //Unlock data1
    2958:	00 e0       	ldi	r16, 0x00	; 0
    295a:	20 e0       	ldi	r18, 0x00	; 0
    295c:	30 e0       	ldi	r19, 0x00	; 0
    295e:	a9 01       	movw	r20, r18
    2960:	60 e0       	ldi	r22, 0x00	; 0
    2962:	70 e0       	ldi	r23, 0x00	; 0
    2964:	80 91 cd 2c 	lds	r24, 0x2CCD	; 0x802ccd <data1Key>
    2968:	90 91 ce 2c 	lds	r25, 0x2CCE	; 0x802cce <data1Key+0x1>
    296c:	0e 94 1a 07 	call	0xe34	; 0xe34 <xQueueGenericSend>
			xSemaphoreGive(data2Key); //Unlock data2
    2970:	20 e0       	ldi	r18, 0x00	; 0
    2972:	30 e0       	ldi	r19, 0x00	; 0
    2974:	a9 01       	movw	r20, r18
    2976:	60 e0       	ldi	r22, 0x00	; 0
    2978:	70 e0       	ldi	r23, 0x00	; 0
    297a:	80 91 cf 2c 	lds	r24, 0x2CCF	; 0x802ccf <data2Key>
    297e:	90 91 d0 2c 	lds	r25, 0x2CD0	; 0x802cd0 <data2Key+0x1>
    2982:	0e 94 1a 07 	call	0xe34	; 0xe34 <xQueueGenericSend>
			PORTF.OUTSET = 0x02;
    2986:	1d 83       	std	Y+5, r17	; 0x05
    2988:	82 cf       	rjmp	.-252    	; 0x288e <vT2+0x40>

0000298a <vApplicationIdleHook>:

void vT1(void *pvParameters);
void vT2(void *pvParameters);

void vApplicationIdleHook( void )
{	
    298a:	08 95       	ret

0000298c <main>:
	
}

int main(void)
{
    298c:	ef 92       	push	r14
    298e:	ff 92       	push	r15
    2990:	0f 93       	push	r16
    resetReason_t reason = getResetReason();
    2992:	0e 94 2c 1b 	call	0x3658	; 0x3658 <getResetReason>

	vInitClock();
    2996:	0e 94 55 13 	call	0x26aa	; 0x26aa <vInitClock>
	vInitDisplay();
    299a:	0e 94 02 16 	call	0x2c04	; 0x2c04 <vInitDisplay>
	
	data1Key = xSemaphoreCreateMutex(); //Create Lock
    299e:	81 e0       	ldi	r24, 0x01	; 1
    29a0:	0e 94 c0 07 	call	0xf80	; 0xf80 <xQueueCreateMutex>
    29a4:	80 93 cd 2c 	sts	0x2CCD, r24	; 0x802ccd <data1Key>
    29a8:	90 93 ce 2c 	sts	0x2CCE, r25	; 0x802cce <data1Key+0x1>
	data2Key = xSemaphoreCreateMutex(); //Create Lock
    29ac:	81 e0       	ldi	r24, 0x01	; 1
    29ae:	0e 94 c0 07 	call	0xf80	; 0xf80 <xQueueCreateMutex>
    29b2:	80 93 cf 2c 	sts	0x2CCF, r24	; 0x802ccf <data2Key>
    29b6:	90 93 d0 2c 	sts	0x2CD0, r25	; 0x802cd0 <data2Key+0x1>

	PORTF.DIRSET = PIN0_bm | PIN1_bm;
    29ba:	83 e0       	ldi	r24, 0x03	; 3
    29bc:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>

	xTaskCreate( vT1, (const char *) "T1", configMINIMAL_STACK_SIZE+10, NULL, 1, NULL);
    29c0:	e1 2c       	mov	r14, r1
    29c2:	f1 2c       	mov	r15, r1
    29c4:	01 e0       	ldi	r16, 0x01	; 1
    29c6:	20 e0       	ldi	r18, 0x00	; 0
    29c8:	30 e0       	ldi	r19, 0x00	; 0
    29ca:	42 ed       	ldi	r20, 0xD2	; 210
    29cc:	50 e0       	ldi	r21, 0x00	; 0
    29ce:	6f e3       	ldi	r22, 0x3F	; 63
    29d0:	70 e2       	ldi	r23, 0x20	; 32
    29d2:	8d e8       	ldi	r24, 0x8D	; 141
    29d4:	93 e1       	ldi	r25, 0x13	; 19
    29d6:	0e 94 85 0a 	call	0x150a	; 0x150a <xTaskCreate>
	xTaskCreate( vT2, (const char *) "T2", configMINIMAL_STACK_SIZE+10, NULL, 1, NULL);
    29da:	20 e0       	ldi	r18, 0x00	; 0
    29dc:	30 e0       	ldi	r19, 0x00	; 0
    29de:	42 ed       	ldi	r20, 0xD2	; 210
    29e0:	50 e0       	ldi	r21, 0x00	; 0
    29e2:	62 e4       	ldi	r22, 0x42	; 66
    29e4:	70 e2       	ldi	r23, 0x20	; 32
    29e6:	87 e2       	ldi	r24, 0x27	; 39
    29e8:	94 e1       	ldi	r25, 0x14	; 20
    29ea:	0e 94 85 0a 	call	0x150a	; 0x150a <xTaskCreate>

	vDisplayClear();
    29ee:	0e 94 7e 17 	call	0x2efc	; 0x2efc <vDisplayClear>
	vTaskStartScheduler();
    29f2:	0e 94 9c 0b 	call	0x1738	; 0x1738 <vTaskStartScheduler>
	return 0;
}
    29f6:	80 e0       	ldi	r24, 0x00	; 0
    29f8:	90 e0       	ldi	r25, 0x00	; 0
    29fa:	0f 91       	pop	r16
    29fc:	ff 90       	pop	r15
    29fe:	ef 90       	pop	r14
    2a00:	08 95       	ret

00002a02 <__vector_108>:
 void displayHome() {
	 command(0x02);
 }
 void _displayClear() {
	 command(0x01);
	 delayUS(2000);
    2a02:	1f 92       	push	r1
    2a04:	0f 92       	push	r0
    2a06:	0f b6       	in	r0, 0x3f	; 63
    2a08:	0f 92       	push	r0
    2a0a:	11 24       	eor	r1, r1
    2a0c:	0b b6       	in	r0, 0x3b	; 59
    2a0e:	0f 92       	push	r0
    2a10:	2f 93       	push	r18
    2a12:	3f 93       	push	r19
    2a14:	4f 93       	push	r20
    2a16:	5f 93       	push	r21
    2a18:	6f 93       	push	r22
    2a1a:	7f 93       	push	r23
    2a1c:	8f 93       	push	r24
    2a1e:	9f 93       	push	r25
    2a20:	af 93       	push	r26
    2a22:	bf 93       	push	r27
    2a24:	ef 93       	push	r30
    2a26:	ff 93       	push	r31
    2a28:	cf 93       	push	r28
    2a2a:	df 93       	push	r29
    2a2c:	1f 92       	push	r1
    2a2e:	cd b7       	in	r28, 0x3d	; 61
    2a30:	de b7       	in	r29, 0x3e	; 62
    2a32:	19 82       	std	Y+1, r1	; 0x01
    2a34:	9e 01       	movw	r18, r28
    2a36:	2f 5f       	subi	r18, 0xFF	; 255
    2a38:	3f 4f       	sbci	r19, 0xFF	; 255
    2a3a:	41 e0       	ldi	r20, 0x01	; 1
    2a3c:	50 e0       	ldi	r21, 0x00	; 0
    2a3e:	60 e0       	ldi	r22, 0x00	; 0
    2a40:	70 e0       	ldi	r23, 0x00	; 0
    2a42:	80 91 d3 2c 	lds	r24, 0x2CD3	; 0x802cd3 <egDisplayTiming>
    2a46:	90 91 d4 2c 	lds	r25, 0x2CD4	; 0x802cd4 <egDisplayTiming+0x1>
    2a4a:	0e 94 3c 03 	call	0x678	; 0x678 <xEventGroupSetBitsFromISR>
    2a4e:	60 e0       	ldi	r22, 0x00	; 0
    2a50:	80 e0       	ldi	r24, 0x00	; 0
    2a52:	9b e0       	ldi	r25, 0x0B	; 11
    2a54:	0e 94 90 01 	call	0x320	; 0x320 <TC0_ConfigClockSource>
    2a58:	10 92 06 0b 	sts	0x0B06, r1	; 0x800b06 <__TEXT_REGION_LENGTH__+0x700b06>
    2a5c:	0f 90       	pop	r0
    2a5e:	df 91       	pop	r29
    2a60:	cf 91       	pop	r28
    2a62:	ff 91       	pop	r31
    2a64:	ef 91       	pop	r30
    2a66:	bf 91       	pop	r27
    2a68:	af 91       	pop	r26
    2a6a:	9f 91       	pop	r25
    2a6c:	8f 91       	pop	r24
    2a6e:	7f 91       	pop	r23
    2a70:	6f 91       	pop	r22
    2a72:	5f 91       	pop	r21
    2a74:	4f 91       	pop	r20
    2a76:	3f 91       	pop	r19
    2a78:	2f 91       	pop	r18
    2a7a:	0f 90       	pop	r0
    2a7c:	0b be       	out	0x3b, r0	; 59
    2a7e:	0f 90       	pop	r0
    2a80:	0f be       	out	0x3f, r0	; 63
    2a82:	0f 90       	pop	r0
    2a84:	1f 90       	pop	r1
    2a86:	18 95       	reti

00002a88 <delayUS>:
    2a88:	cf 92       	push	r12
    2a8a:	df 92       	push	r13
    2a8c:	ef 92       	push	r14
    2a8e:	ff 92       	push	r15
    2a90:	0f 93       	push	r16
    2a92:	6b 01       	movw	r12, r22
    2a94:	7c 01       	movw	r14, r24
    2a96:	82 e0       	ldi	r24, 0x02	; 2
    2a98:	c8 16       	cp	r12, r24
    2a9a:	d1 04       	cpc	r13, r1
    2a9c:	e1 04       	cpc	r14, r1
    2a9e:	f1 04       	cpc	r15, r1
    2aa0:	08 f4       	brcc	.+2      	; 0x2aa4 <delayUS+0x1c>
    2aa2:	4e c0       	rjmp	.+156    	; 0x2b40 <delayUS+0xb8>
    2aa4:	e0 e0       	ldi	r30, 0x00	; 0
    2aa6:	fb e0       	ldi	r31, 0x0B	; 11
    2aa8:	81 e0       	ldi	r24, 0x01	; 1
    2aaa:	86 83       	std	Z+6, r24	; 0x06
    2aac:	10 a2       	std	Z+32, r1	; 0x20
    2aae:	11 a2       	std	Z+33, r1	; 0x21
    2ab0:	60 e0       	ldi	r22, 0x00	; 0
    2ab2:	80 e0       	ldi	r24, 0x00	; 0
    2ab4:	9b e0       	ldi	r25, 0x0B	; 11
    2ab6:	0e 94 96 01 	call	0x32c	; 0x32c <TC0_ConfigWGM>
    2aba:	8e ef       	ldi	r24, 0xFE	; 254
    2abc:	c8 16       	cp	r12, r24
    2abe:	8f ef       	ldi	r24, 0xFF	; 255
    2ac0:	d8 06       	cpc	r13, r24
    2ac2:	e1 04       	cpc	r14, r1
    2ac4:	f1 04       	cpc	r15, r1
    2ac6:	70 f4       	brcc	.+28     	; 0x2ae4 <delayUS+0x5c>
    2ac8:	f6 94       	lsr	r15
    2aca:	e7 94       	ror	r14
    2acc:	d7 94       	ror	r13
    2ace:	c7 94       	ror	r12
    2ad0:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2ad4:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2ad8:	65 e0       	ldi	r22, 0x05	; 5
    2ada:	80 e0       	ldi	r24, 0x00	; 0
    2adc:	9b e0       	ldi	r25, 0x0B	; 11
    2ade:	0e 94 90 01 	call	0x320	; 0x320 <TC0_ConfigClockSource>
    2ae2:	19 c0       	rjmp	.+50     	; 0x2b16 <delayUS+0x8e>
    2ae4:	80 e4       	ldi	r24, 0x40	; 64
    2ae6:	c8 16       	cp	r12, r24
    2ae8:	82 e4       	ldi	r24, 0x42	; 66
    2aea:	d8 06       	cpc	r13, r24
    2aec:	8f e0       	ldi	r24, 0x0F	; 15
    2aee:	e8 06       	cpc	r14, r24
    2af0:	f1 04       	cpc	r15, r1
    2af2:	88 f4       	brcc	.+34     	; 0x2b16 <delayUS+0x8e>
    2af4:	68 94       	set
    2af6:	14 f8       	bld	r1, 4
    2af8:	f6 94       	lsr	r15
    2afa:	e7 94       	ror	r14
    2afc:	d7 94       	ror	r13
    2afe:	c7 94       	ror	r12
    2b00:	16 94       	lsr	r1
    2b02:	d1 f7       	brne	.-12     	; 0x2af8 <delayUS+0x70>
    2b04:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2b08:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2b0c:	67 e0       	ldi	r22, 0x07	; 7
    2b0e:	80 e0       	ldi	r24, 0x00	; 0
    2b10:	9b e0       	ldi	r25, 0x0B	; 11
    2b12:	0e 94 90 01 	call	0x320	; 0x320 <TC0_ConfigClockSource>
    2b16:	0f 2e       	mov	r0, r31
    2b18:	f4 ef       	ldi	r31, 0xF4	; 244
    2b1a:	cf 2e       	mov	r12, r31
    2b1c:	dd 24       	eor	r13, r13
    2b1e:	d3 94       	inc	r13
    2b20:	e1 2c       	mov	r14, r1
    2b22:	f1 2c       	mov	r15, r1
    2b24:	f0 2d       	mov	r31, r0
    2b26:	00 e0       	ldi	r16, 0x00	; 0
    2b28:	21 e0       	ldi	r18, 0x01	; 1
    2b2a:	41 e0       	ldi	r20, 0x01	; 1
    2b2c:	50 e0       	ldi	r21, 0x00	; 0
    2b2e:	60 e0       	ldi	r22, 0x00	; 0
    2b30:	70 e0       	ldi	r23, 0x00	; 0
    2b32:	80 91 d3 2c 	lds	r24, 0x2CD3	; 0x802cd3 <egDisplayTiming>
    2b36:	90 91 d4 2c 	lds	r25, 0x2CD4	; 0x802cd4 <egDisplayTiming+0x1>
    2b3a:	0e 94 c1 01 	call	0x382	; 0x382 <xEventGroupWaitBits>
    2b3e:	11 c0       	rjmp	.+34     	; 0x2b62 <delayUS+0xda>
    2b40:	e0 e0       	ldi	r30, 0x00	; 0
    2b42:	fb e0       	ldi	r31, 0x0B	; 11
    2b44:	81 e0       	ldi	r24, 0x01	; 1
    2b46:	86 83       	std	Z+6, r24	; 0x06
    2b48:	10 a2       	std	Z+32, r1	; 0x20
    2b4a:	11 a2       	std	Z+33, r1	; 0x21
    2b4c:	60 e0       	ldi	r22, 0x00	; 0
    2b4e:	80 e0       	ldi	r24, 0x00	; 0
    2b50:	9b e0       	ldi	r25, 0x0B	; 11
    2b52:	0e 94 96 01 	call	0x32c	; 0x32c <TC0_ConfigWGM>
    2b56:	c1 2c       	mov	r12, r1
    2b58:	d1 2c       	mov	r13, r1
    2b5a:	76 01       	movw	r14, r12
    2b5c:	68 94       	set
    2b5e:	c1 f8       	bld	r12, 1
    2b60:	b3 cf       	rjmp	.-154    	; 0x2ac8 <delayUS+0x40>
    2b62:	0f 91       	pop	r16
    2b64:	ff 90       	pop	r15
    2b66:	ef 90       	pop	r14
    2b68:	df 90       	pop	r13
    2b6a:	cf 90       	pop	r12
    2b6c:	08 95       	ret

00002b6e <setPort>:
    2b6e:	82 95       	swap	r24
    2b70:	80 7f       	andi	r24, 0xF0	; 240
    2b72:	e0 e0       	ldi	r30, 0x00	; 0
    2b74:	f6 e0       	ldi	r31, 0x06	; 6
    2b76:	94 81       	ldd	r25, Z+4	; 0x04
    2b78:	28 2f       	mov	r18, r24
    2b7a:	2f 60       	ori	r18, 0x0F	; 15
    2b7c:	92 23       	and	r25, r18
    2b7e:	94 83       	std	Z+4, r25	; 0x04
    2b80:	94 81       	ldd	r25, Z+4	; 0x04
    2b82:	89 2b       	or	r24, r25
    2b84:	84 83       	std	Z+4, r24	; 0x04
    2b86:	08 95       	ret

00002b88 <Nybble>:
    2b88:	1f 93       	push	r17
    2b8a:	cf 93       	push	r28
    2b8c:	df 93       	push	r29
    2b8e:	c0 e6       	ldi	r28, 0x60	; 96
    2b90:	d6 e0       	ldi	r29, 0x06	; 6
    2b92:	14 e0       	ldi	r17, 0x04	; 4
    2b94:	1d 83       	std	Y+5, r17	; 0x05
    2b96:	61 e0       	ldi	r22, 0x01	; 1
    2b98:	70 e0       	ldi	r23, 0x00	; 0
    2b9a:	80 e0       	ldi	r24, 0x00	; 0
    2b9c:	90 e0       	ldi	r25, 0x00	; 0
    2b9e:	0e 94 44 15 	call	0x2a88	; 0x2a88 <delayUS>
    2ba2:	1e 83       	std	Y+6, r17	; 0x06
    2ba4:	df 91       	pop	r29
    2ba6:	cf 91       	pop	r28
    2ba8:	1f 91       	pop	r17
    2baa:	08 95       	ret

00002bac <command>:
    2bac:	cf 93       	push	r28
    2bae:	c8 2f       	mov	r28, r24
    2bb0:	82 95       	swap	r24
    2bb2:	8f 70       	andi	r24, 0x0F	; 15
    2bb4:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <setPort>
    2bb8:	e0 e6       	ldi	r30, 0x60	; 96
    2bba:	f6 e0       	ldi	r31, 0x06	; 6
    2bbc:	81 e0       	ldi	r24, 0x01	; 1
    2bbe:	86 83       	std	Z+6, r24	; 0x06
    2bc0:	82 e0       	ldi	r24, 0x02	; 2
    2bc2:	86 83       	std	Z+6, r24	; 0x06
    2bc4:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <Nybble>
    2bc8:	8c 2f       	mov	r24, r28
    2bca:	8f 70       	andi	r24, 0x0F	; 15
    2bcc:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <setPort>
    2bd0:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <Nybble>
    2bd4:	cf 91       	pop	r28
    2bd6:	08 95       	ret

00002bd8 <write>:
    2bd8:	cf 93       	push	r28
    2bda:	c8 2f       	mov	r28, r24
    2bdc:	82 95       	swap	r24
    2bde:	8f 70       	andi	r24, 0x0F	; 15
    2be0:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <setPort>
    2be4:	e0 e6       	ldi	r30, 0x60	; 96
    2be6:	f6 e0       	ldi	r31, 0x06	; 6
    2be8:	81 e0       	ldi	r24, 0x01	; 1
    2bea:	85 83       	std	Z+5, r24	; 0x05
    2bec:	82 e0       	ldi	r24, 0x02	; 2
    2bee:	86 83       	std	Z+6, r24	; 0x06
    2bf0:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <Nybble>
    2bf4:	8c 2f       	mov	r24, r28
    2bf6:	8f 70       	andi	r24, 0x0F	; 15
    2bf8:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <setPort>
    2bfc:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <Nybble>
    2c00:	cf 91       	pop	r28
    2c02:	08 95       	ret

00002c04 <vInitDisplay>:
 }
 
 void vInitDisplay() {
    2c04:	ef 92       	push	r14
    2c06:	ff 92       	push	r15
    2c08:	0f 93       	push	r16
	PORTA.DIRSET = PIN4_bm;
    2c0a:	e0 e0       	ldi	r30, 0x00	; 0
    2c0c:	f6 e0       	ldi	r31, 0x06	; 6
    2c0e:	80 e1       	ldi	r24, 0x10	; 16
    2c10:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN5_bm;
    2c12:	80 e2       	ldi	r24, 0x20	; 32
    2c14:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN6_bm;
    2c16:	80 e4       	ldi	r24, 0x40	; 64
    2c18:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN7_bm;
    2c1a:	80 e8       	ldi	r24, 0x80	; 128
    2c1c:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = PIN0_bm;
    2c1e:	a0 e6       	ldi	r26, 0x60	; 96
    2c20:	b6 e0       	ldi	r27, 0x06	; 6
    2c22:	81 e0       	ldi	r24, 0x01	; 1
    2c24:	11 96       	adiw	r26, 0x01	; 1
    2c26:	8c 93       	st	X, r24
    2c28:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN1_bm;
    2c2a:	82 e0       	ldi	r24, 0x02	; 2
    2c2c:	11 96       	adiw	r26, 0x01	; 1
    2c2e:	8c 93       	st	X, r24
    2c30:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN2_bm;
    2c32:	84 e0       	ldi	r24, 0x04	; 4
    2c34:	11 96       	adiw	r26, 0x01	; 1
    2c36:	8c 93       	st	X, r24
    2c38:	11 97       	sbiw	r26, 0x01	; 1
	PORTA.OUT &= 0x0F;
    2c3a:	84 81       	ldd	r24, Z+4	; 0x04
    2c3c:	8f 70       	andi	r24, 0x0F	; 15
    2c3e:	84 83       	std	Z+4, r24	; 0x04
	PORTD.OUT &= 0xF8;
    2c40:	14 96       	adiw	r26, 0x04	; 4
    2c42:	8c 91       	ld	r24, X
    2c44:	14 97       	sbiw	r26, 0x04	; 4
    2c46:	88 7f       	andi	r24, 0xF8	; 248
    2c48:	14 96       	adiw	r26, 0x04	; 4
    2c4a:	8c 93       	st	X, r24

	if((displayLineQueue = xQueueCreate(DISPLAY_QUEUE_DEPTH, sizeof(displayLine_t))) == NULL)
    2c4c:	40 e0       	ldi	r20, 0x00	; 0
    2c4e:	66 e1       	ldi	r22, 0x16	; 22
    2c50:	88 e0       	ldi	r24, 0x08	; 8
    2c52:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <xQueueGenericCreate>
    2c56:	80 93 d1 2c 	sts	0x2CD1, r24	; 0x802cd1 <displayLineQueue>
    2c5a:	90 93 d2 2c 	sts	0x2CD2, r25	; 0x802cd2 <displayLineQueue+0x1>
	{
		//error(ERR_QUEUE_CREATE_HANDLE_NULL);
	}
	
	egDisplayTiming = xEventGroupCreate();
    2c5e:	0e 94 ac 01 	call	0x358	; 0x358 <xEventGroupCreate>
    2c62:	80 93 d3 2c 	sts	0x2CD3, r24	; 0x802cd3 <egDisplayTiming>
    2c66:	90 93 d4 2c 	sts	0x2CD4, r25	; 0x802cd4 <egDisplayTiming+0x1>
	

	xTaskCreate(vDisplayUpdateTask, (const char*) "dispUpdate", configMINIMAL_STACK_SIZE+150, NULL, 1, NULL);	
    2c6a:	e1 2c       	mov	r14, r1
    2c6c:	f1 2c       	mov	r15, r1
    2c6e:	01 e0       	ldi	r16, 0x01	; 1
    2c70:	20 e0       	ldi	r18, 0x00	; 0
    2c72:	30 e0       	ldi	r19, 0x00	; 0
    2c74:	4e e5       	ldi	r20, 0x5E	; 94
    2c76:	51 e0       	ldi	r21, 0x01	; 1
    2c78:	65 e4       	ldi	r22, 0x45	; 69
    2c7a:	70 e2       	ldi	r23, 0x20	; 32
    2c7c:	80 ea       	ldi	r24, 0xA0	; 160
    2c7e:	96 e1       	ldi	r25, 0x16	; 22
    2c80:	0e 94 85 0a 	call	0x150a	; 0x150a <xTaskCreate>
 }
    2c84:	0f 91       	pop	r16
    2c86:	ff 90       	pop	r15
    2c88:	ef 90       	pop	r14
    2c8a:	08 95       	ret

00002c8c <_displaySetPos>:
 
 void _displaySetPos(int line, int pos) {
	 switch(line) {
    2c8c:	81 30       	cpi	r24, 0x01	; 1
    2c8e:	91 05       	cpc	r25, r1
    2c90:	79 f0       	breq	.+30     	; 0x2cb0 <_displaySetPos+0x24>
    2c92:	1c f4       	brge	.+6      	; 0x2c9a <_displaySetPos+0xe>
    2c94:	89 2b       	or	r24, r25
    2c96:	39 f0       	breq	.+14     	; 0x2ca6 <_displaySetPos+0x1a>
    2c98:	19 c0       	rjmp	.+50     	; 0x2ccc <_displaySetPos+0x40>
    2c9a:	82 30       	cpi	r24, 0x02	; 2
    2c9c:	91 05       	cpc	r25, r1
    2c9e:	69 f0       	breq	.+26     	; 0x2cba <_displaySetPos+0x2e>
    2ca0:	03 97       	sbiw	r24, 0x03	; 3
    2ca2:	81 f0       	breq	.+32     	; 0x2cc4 <_displaySetPos+0x38>
    2ca4:	13 c0       	rjmp	.+38     	; 0x2ccc <_displaySetPos+0x40>
		 case 0:
		 command(0x80 + 0x00 + pos);
    2ca6:	80 e8       	ldi	r24, 0x80	; 128
    2ca8:	86 0f       	add	r24, r22
    2caa:	0e 94 d6 15 	call	0x2bac	; 0x2bac <command>
		 break;
    2cae:	0e c0       	rjmp	.+28     	; 0x2ccc <_displaySetPos+0x40>
		 case 1:
		 command(0x80 + 0x40 + pos);
    2cb0:	80 ec       	ldi	r24, 0xC0	; 192
    2cb2:	86 0f       	add	r24, r22
    2cb4:	0e 94 d6 15 	call	0x2bac	; 0x2bac <command>
		 break;
    2cb8:	09 c0       	rjmp	.+18     	; 0x2ccc <_displaySetPos+0x40>
		 case 2:
		 command(0x80 + 0x14 + pos);
    2cba:	84 e9       	ldi	r24, 0x94	; 148
    2cbc:	86 0f       	add	r24, r22
    2cbe:	0e 94 d6 15 	call	0x2bac	; 0x2bac <command>
		 break;
    2cc2:	04 c0       	rjmp	.+8      	; 0x2ccc <_displaySetPos+0x40>
		 case 3:
		 command(0x80 + 0x54 + pos);
    2cc4:	84 ed       	ldi	r24, 0xD4	; 212
    2cc6:	86 0f       	add	r24, r22
    2cc8:	0e 94 d6 15 	call	0x2bac	; 0x2bac <command>
		 break;
	 }
	 delayUS(39);
    2ccc:	67 e2       	ldi	r22, 0x27	; 39
    2cce:	70 e0       	ldi	r23, 0x00	; 0
    2cd0:	80 e0       	ldi	r24, 0x00	; 0
    2cd2:	90 e0       	ldi	r25, 0x00	; 0
    2cd4:	0e 94 44 15 	call	0x2a88	; 0x2a88 <delayUS>
    2cd8:	08 95       	ret

00002cda <_displayWriteChar>:
 }

 void _displayWriteChar(char c) {
	 write(c);
    2cda:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <write>
	 delayUS(43);
    2cde:	6b e2       	ldi	r22, 0x2B	; 43
    2ce0:	70 e0       	ldi	r23, 0x00	; 0
    2ce2:	80 e0       	ldi	r24, 0x00	; 0
    2ce4:	90 e0       	ldi	r25, 0x00	; 0
    2ce6:	0e 94 44 15 	call	0x2a88	; 0x2a88 <delayUS>
    2cea:	08 95       	ret

00002cec <_displayWriteString>:
 }
 
 void _displayWriteString(char* s) {
    2cec:	0f 93       	push	r16
    2cee:	1f 93       	push	r17
    2cf0:	cf 93       	push	r28
    2cf2:	df 93       	push	r29
    2cf4:	fc 01       	movw	r30, r24
	 for(int i = 0; i < 20; i++) {
		 if(s[i] == '\0') {
    2cf6:	80 81       	ld	r24, Z
    2cf8:	81 11       	cpse	r24, r1
    2cfa:	0a c0       	rjmp	.+20     	; 0x2d10 <_displayWriteString+0x24>
    2cfc:	11 c0       	rjmp	.+34     	; 0x2d20 <_displayWriteString+0x34>
    2cfe:	89 91       	ld	r24, Y+
    2d00:	88 23       	and	r24, r24
    2d02:	71 f0       	breq	.+28     	; 0x2d20 <_displayWriteString+0x34>
			 break;
		 }
		 _displayWriteChar(s[i]);
    2d04:	0e 94 6d 16 	call	0x2cda	; 0x2cda <_displayWriteChar>
	 write(c);
	 delayUS(43);
 }
 
 void _displayWriteString(char* s) {
	 for(int i = 0; i < 20; i++) {
    2d08:	0c 17       	cp	r16, r28
    2d0a:	1d 07       	cpc	r17, r29
    2d0c:	c1 f7       	brne	.-16     	; 0x2cfe <_displayWriteString+0x12>
    2d0e:	08 c0       	rjmp	.+16     	; 0x2d20 <_displayWriteString+0x34>
    2d10:	8f 01       	movw	r16, r30
		 if(s[i] == '\0') {
			 break;
		 }
		 _displayWriteChar(s[i]);
    2d12:	0e 94 6d 16 	call	0x2cda	; 0x2cda <_displayWriteChar>
    2d16:	e8 01       	movw	r28, r16
    2d18:	21 96       	adiw	r28, 0x01	; 1
    2d1a:	0c 5e       	subi	r16, 0xEC	; 236
    2d1c:	1f 4f       	sbci	r17, 0xFF	; 255
    2d1e:	ef cf       	rjmp	.-34     	; 0x2cfe <_displayWriteString+0x12>
	 }
 }
    2d20:	df 91       	pop	r29
    2d22:	cf 91       	pop	r28
    2d24:	1f 91       	pop	r17
    2d26:	0f 91       	pop	r16
    2d28:	08 95       	ret

00002d2a <_displayWriteStringAtPos>:

 void _displayWriteStringAtPos(int line, int pos, char* s) {
    2d2a:	cf 93       	push	r28
    2d2c:	df 93       	push	r29
    2d2e:	ea 01       	movw	r28, r20
	 _displaySetPos(line, pos);
    2d30:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <_displaySetPos>
	 _displayWriteString(s);
    2d34:	ce 01       	movw	r24, r28
    2d36:	0e 94 76 16 	call	0x2cec	; 0x2cec <_displayWriteString>
 }
    2d3a:	df 91       	pop	r29
    2d3c:	cf 91       	pop	r28
    2d3e:	08 95       	ret

00002d40 <vDisplayUpdateTask>:

 void vDisplayUpdateTask(void *pvParameters) {
    2d40:	cf 93       	push	r28
    2d42:	df 93       	push	r29
    2d44:	cd b7       	in	r28, 0x3d	; 61
    2d46:	de b7       	in	r29, 0x3e	; 62
    2d48:	c6 56       	subi	r28, 0x66	; 102
    2d4a:	d1 09       	sbc	r29, r1
    2d4c:	cd bf       	out	0x3d, r28	; 61
    2d4e:	de bf       	out	0x3e, r29	; 62
    2d50:	5e 01       	movw	r10, r28
    2d52:	41 e5       	ldi	r20, 0x51	; 81
    2d54:	a4 0e       	add	r10, r20
    2d56:	b1 1c       	adc	r11, r1
    2d58:	fe 01       	movw	r30, r28
    2d5a:	31 96       	adiw	r30, 0x01	; 1
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
			displayLines[i][j] = 0x20;
    2d5c:	20 e2       	ldi	r18, 0x20	; 32
    2d5e:	08 c0       	rjmp	.+16     	; 0x2d70 <vDisplayUpdateTask+0x30>
    2d60:	21 93       	st	Z+, r18
 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
    2d62:	e8 17       	cp	r30, r24
    2d64:	f9 07       	cpc	r31, r25
    2d66:	e1 f7       	brne	.-8      	; 0x2d60 <vDisplayUpdateTask+0x20>
    2d68:	fc 01       	movw	r30, r24

 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
    2d6a:	a8 16       	cp	r10, r24
    2d6c:	b9 06       	cpc	r11, r25
    2d6e:	19 f0       	breq	.+6      	; 0x2d76 <vDisplayUpdateTask+0x36>
    2d70:	cf 01       	movw	r24, r30
    2d72:	44 96       	adiw	r24, 0x14	; 20
    2d74:	f5 cf       	rjmp	.-22     	; 0x2d60 <vDisplayUpdateTask+0x20>
			displayLines[i][j] = 0x20;
		}
	 }
	 displayLine_t newLine;

	 delayUS(40000);
    2d76:	60 e4       	ldi	r22, 0x40	; 64
    2d78:	7c e9       	ldi	r23, 0x9C	; 156
    2d7a:	80 e0       	ldi	r24, 0x00	; 0
    2d7c:	90 e0       	ldi	r25, 0x00	; 0
    2d7e:	0e 94 44 15 	call	0x2a88	; 0x2a88 <delayUS>
	 setPort(0x03);
    2d82:	83 e0       	ldi	r24, 0x03	; 3
    2d84:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <setPort>
	 delayUS(5000);
    2d88:	68 e8       	ldi	r22, 0x88	; 136
    2d8a:	73 e1       	ldi	r23, 0x13	; 19
    2d8c:	80 e0       	ldi	r24, 0x00	; 0
    2d8e:	90 e0       	ldi	r25, 0x00	; 0
    2d90:	0e 94 44 15 	call	0x2a88	; 0x2a88 <delayUS>
	 Nybble();
    2d94:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <Nybble>
	 delayUS(160);
    2d98:	60 ea       	ldi	r22, 0xA0	; 160
    2d9a:	70 e0       	ldi	r23, 0x00	; 0
    2d9c:	80 e0       	ldi	r24, 0x00	; 0
    2d9e:	90 e0       	ldi	r25, 0x00	; 0
    2da0:	0e 94 44 15 	call	0x2a88	; 0x2a88 <delayUS>
	 Nybble();
    2da4:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <Nybble>
	 delayUS(160);
    2da8:	60 ea       	ldi	r22, 0xA0	; 160
    2daa:	70 e0       	ldi	r23, 0x00	; 0
    2dac:	80 e0       	ldi	r24, 0x00	; 0
    2dae:	90 e0       	ldi	r25, 0x00	; 0
    2db0:	0e 94 44 15 	call	0x2a88	; 0x2a88 <delayUS>
	 Nybble();
    2db4:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <Nybble>
	 delayUS(160);
    2db8:	60 ea       	ldi	r22, 0xA0	; 160
    2dba:	70 e0       	ldi	r23, 0x00	; 0
    2dbc:	80 e0       	ldi	r24, 0x00	; 0
    2dbe:	90 e0       	ldi	r25, 0x00	; 0
    2dc0:	0e 94 44 15 	call	0x2a88	; 0x2a88 <delayUS>
	 setPort(0x02);
    2dc4:	82 e0       	ldi	r24, 0x02	; 2
    2dc6:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <setPort>
	 Nybble();
    2dca:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <Nybble>
	 command(0x28);
    2dce:	88 e2       	ldi	r24, 0x28	; 40
    2dd0:	0e 94 d6 15 	call	0x2bac	; 0x2bac <command>
	 command(0x10);
    2dd4:	80 e1       	ldi	r24, 0x10	; 16
    2dd6:	0e 94 d6 15 	call	0x2bac	; 0x2bac <command>
	 command(0x0C); //Cursor and Blinking off
    2dda:	8c e0       	ldi	r24, 0x0C	; 12
    2ddc:	0e 94 d6 15 	call	0x2bac	; 0x2bac <command>
	 command(0x06);
    2de0:	86 e0       	ldi	r24, 0x06	; 6
    2de2:	0e 94 d6 15 	call	0x2bac	; 0x2bac <command>
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2de6:	10 e2       	ldi	r17, 0x20	; 32
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2de8:	6e 01       	movw	r12, r28
    2dea:	51 e5       	ldi	r21, 0x51	; 81
    2dec:	c5 0e       	add	r12, r21
    2dee:	d1 1c       	adc	r13, r1
    2df0:	0f 2e       	mov	r0, r31
    2df2:	f4 e1       	ldi	r31, 0x14	; 20
    2df4:	4f 2e       	mov	r4, r31
    2df6:	f0 2d       	mov	r31, r0
    2df8:	0f 2e       	mov	r0, r31
    2dfa:	f6 e1       	ldi	r31, 0x16	; 22
    2dfc:	8f 2e       	mov	r8, r31
    2dfe:	91 2c       	mov	r9, r1
    2e00:	f0 2d       	mov	r31, r0
    2e02:	5c 2c       	mov	r5, r12
    2e04:	0d 2d       	mov	r16, r13
	 command(0x10);
	 command(0x0C); //Cursor and Blinking off
	 command(0x06);
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
    2e06:	68 ec       	ldi	r22, 0xC8	; 200
    2e08:	70 e0       	ldi	r23, 0x00	; 0
    2e0a:	80 e0       	ldi	r24, 0x00	; 0
    2e0c:	90 e0       	ldi	r25, 0x00	; 0
    2e0e:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <vTaskDelay>
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
    2e12:	40 e0       	ldi	r20, 0x00	; 0
    2e14:	50 e0       	ldi	r21, 0x00	; 0
    2e16:	ba 01       	movw	r22, r20
    2e18:	80 91 d3 2c 	lds	r24, 0x2CD3	; 0x802cd3 <egDisplayTiming>
    2e1c:	90 91 d4 2c 	lds	r25, 0x2CD4	; 0x802cd4 <egDisplayTiming+0x1>
    2e20:	0e 94 86 02 	call	0x50c	; 0x50c <xEventGroupClearBits>
    2e24:	67 2b       	or	r22, r23
    2e26:	68 2b       	or	r22, r24
    2e28:	69 2b       	or	r22, r25
    2e2a:	09 f4       	brne	.+2      	; 0x2e2e <vDisplayUpdateTask+0xee>
    2e2c:	49 c0       	rjmp	.+146    	; 0x2ec0 <vDisplayUpdateTask+0x180>
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2e2e:	42 e0       	ldi	r20, 0x02	; 2
    2e30:	50 e0       	ldi	r21, 0x00	; 0
    2e32:	60 e0       	ldi	r22, 0x00	; 0
    2e34:	70 e0       	ldi	r23, 0x00	; 0
    2e36:	80 91 d3 2c 	lds	r24, 0x2CD3	; 0x802cd3 <egDisplayTiming>
    2e3a:	90 91 d4 2c 	lds	r25, 0x2CD4	; 0x802cd4 <egDisplayTiming+0x1>
    2e3e:	0e 94 86 02 	call	0x50c	; 0x50c <xEventGroupClearBits>
    2e42:	fe 01       	movw	r30, r28
    2e44:	31 96       	adiw	r30, 0x01	; 1
    2e46:	08 c0       	rjmp	.+16     	; 0x2e58 <vDisplayUpdateTask+0x118>
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2e48:	11 93       	st	Z+, r17
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
    2e4a:	e8 17       	cp	r30, r24
    2e4c:	f9 07       	cpc	r31, r25
    2e4e:	e1 f7       	brne	.-8      	; 0x2e48 <vDisplayUpdateTask+0x108>
    2e50:	fc 01       	movw	r30, r24
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
    2e52:	8a 15       	cp	r24, r10
    2e54:	9b 05       	cpc	r25, r11
    2e56:	a1 f1       	breq	.+104    	; 0x2ec0 <vDisplayUpdateTask+0x180>
    2e58:	cf 01       	movw	r24, r30
    2e5a:	44 96       	adiw	r24, 0x14	; 20
    2e5c:	f5 cf       	rjmp	.-22     	; 0x2e48 <vDisplayUpdateTask+0x108>
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2e5e:	2f ef       	ldi	r18, 0xFF	; 255
    2e60:	3f ef       	ldi	r19, 0xFF	; 255
    2e62:	a9 01       	movw	r20, r18
    2e64:	65 2d       	mov	r22, r5
    2e66:	70 2f       	mov	r23, r16
    2e68:	80 91 d1 2c 	lds	r24, 0x2CD1	; 0x802cd1 <displayLineQueue>
    2e6c:	90 91 d2 2c 	lds	r25, 0x2CD2	; 0x802cd2 <displayLineQueue+0x1>
    2e70:	0e 94 22 08 	call	0x1044	; 0x1044 <xQueueReceive>
    2e74:	88 23       	and	r24, r24
    2e76:	21 f1       	breq	.+72     	; 0x2ec0 <vDisplayUpdateTask+0x180>
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2e78:	f6 01       	movw	r30, r12
    2e7a:	21 81       	ldd	r18, Z+1	; 0x01
    2e7c:	82 2f       	mov	r24, r18
    2e7e:	90 e0       	ldi	r25, 0x00	; 0
    2e80:	44 97       	sbiw	r24, 0x14	; 20
    2e82:	f4 f4       	brge	.+60     	; 0x2ec0 <vDisplayUpdateTask+0x180>
    2e84:	82 81       	ldd	r24, Z+2	; 0x02
    2e86:	88 23       	and	r24, r24
    2e88:	d9 f0       	breq	.+54     	; 0x2ec0 <vDisplayUpdateTask+0x180>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
    2e8a:	90 81       	ld	r25, Z
    2e8c:	30 e0       	ldi	r19, 0x00	; 0
    2e8e:	d9 01       	movw	r26, r18
    2e90:	49 9e       	mul	r4, r25
    2e92:	a0 0d       	add	r26, r0
    2e94:	b1 1d       	adc	r27, r1
    2e96:	11 24       	eor	r1, r1
    2e98:	41 e0       	ldi	r20, 0x01	; 1
    2e9a:	50 e0       	ldi	r21, 0x00	; 0
    2e9c:	4c 0f       	add	r20, r28
    2e9e:	5d 1f       	adc	r21, r29
    2ea0:	a4 0f       	add	r26, r20
    2ea2:	b5 1f       	adc	r27, r21
    2ea4:	33 96       	adiw	r30, 0x03	; 3
    2ea6:	a4 01       	movw	r20, r8
    2ea8:	42 1b       	sub	r20, r18
    2eaa:	53 0b       	sbc	r21, r19
    2eac:	9a 01       	movw	r18, r20
    2eae:	2c 0d       	add	r18, r12
    2eb0:	3d 1d       	adc	r19, r13
    2eb2:	8d 93       	st	X+, r24
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2eb4:	e2 17       	cp	r30, r18
    2eb6:	f3 07       	cpc	r31, r19
    2eb8:	19 f0       	breq	.+6      	; 0x2ec0 <vDisplayUpdateTask+0x180>
    2eba:	81 91       	ld	r24, Z+
    2ebc:	81 11       	cpse	r24, r1
    2ebe:	f9 cf       	rjmp	.-14     	; 0x2eb2 <vDisplayUpdateTask+0x172>
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
    2ec0:	80 91 d1 2c 	lds	r24, 0x2CD1	; 0x802cd1 <displayLineQueue>
    2ec4:	90 91 d2 2c 	lds	r25, 0x2CD2	; 0x802cd2 <displayLineQueue+0x1>
    2ec8:	0e 94 ad 09 	call	0x135a	; 0x135a <uxQueueMessagesWaiting>
    2ecc:	81 11       	cpse	r24, r1
    2ece:	c7 cf       	rjmp	.-114    	; 0x2e5e <vDisplayUpdateTask+0x11e>
    2ed0:	ce 01       	movw	r24, r28
    2ed2:	01 96       	adiw	r24, 0x01	; 1
    2ed4:	7c 01       	movw	r14, r24
    2ed6:	61 2c       	mov	r6, r1
    2ed8:	71 2c       	mov	r7, r1
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
			 _displayWriteStringAtPos(i,0,&displayLines[i][0]);
    2eda:	a7 01       	movw	r20, r14
    2edc:	60 e0       	ldi	r22, 0x00	; 0
    2ede:	70 e0       	ldi	r23, 0x00	; 0
    2ee0:	c3 01       	movw	r24, r6
    2ee2:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <_displayWriteStringAtPos>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
    2ee6:	9f ef       	ldi	r25, 0xFF	; 255
    2ee8:	69 1a       	sub	r6, r25
    2eea:	79 0a       	sbc	r7, r25
    2eec:	e4 e1       	ldi	r30, 0x14	; 20
    2eee:	ee 0e       	add	r14, r30
    2ef0:	f1 1c       	adc	r15, r1
    2ef2:	f4 e0       	ldi	r31, 0x04	; 4
    2ef4:	6f 16       	cp	r6, r31
    2ef6:	71 04       	cpc	r7, r1
    2ef8:	81 f7       	brne	.-32     	; 0x2eda <vDisplayUpdateTask+0x19a>
    2efa:	85 cf       	rjmp	.-246    	; 0x2e06 <vDisplayUpdateTask+0xc6>

00002efc <vDisplayClear>:
	 }
 }
 

void vDisplayClear() {
	xEventGroupSetBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2efc:	42 e0       	ldi	r20, 0x02	; 2
    2efe:	50 e0       	ldi	r21, 0x00	; 0
    2f00:	60 e0       	ldi	r22, 0x00	; 0
    2f02:	70 e0       	ldi	r23, 0x00	; 0
    2f04:	80 91 d3 2c 	lds	r24, 0x2CD3	; 0x802cd3 <egDisplayTiming>
    2f08:	90 91 d4 2c 	lds	r25, 0x2CD4	; 0x802cd4 <egDisplayTiming+0x1>
    2f0c:	0e 94 a7 02 	call	0x54e	; 0x54e <xEventGroupSetBits>
    2f10:	08 95       	ret

00002f12 <vDisplayWriteStringAtPos>:
}

void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
    2f12:	2f 92       	push	r2
    2f14:	3f 92       	push	r3
    2f16:	4f 92       	push	r4
    2f18:	5f 92       	push	r5
    2f1a:	6f 92       	push	r6
    2f1c:	7f 92       	push	r7
    2f1e:	8f 92       	push	r8
    2f20:	9f 92       	push	r9
    2f22:	af 92       	push	r10
    2f24:	bf 92       	push	r11
    2f26:	cf 92       	push	r12
    2f28:	df 92       	push	r13
    2f2a:	ef 92       	push	r14
    2f2c:	ff 92       	push	r15
    2f2e:	0f 93       	push	r16
    2f30:	1f 93       	push	r17
    2f32:	cf 93       	push	r28
    2f34:	df 93       	push	r29
    2f36:	cd b7       	in	r28, 0x3d	; 61
    2f38:	de b7       	in	r29, 0x3e	; 62
    2f3a:	6d 97       	sbiw	r28, 0x1d	; 29
    2f3c:	cd bf       	out	0x3d, r28	; 61
    2f3e:	de bf       	out	0x3e, r29	; 62
    2f40:	2b a9       	ldd	r18, Y+51	; 0x33
    2f42:	2b 8f       	std	Y+27, r18	; 0x1b
    2f44:	af a9       	ldd	r26, Y+55	; 0x37
    2f46:	b8 ad       	ldd	r27, Y+56	; 0x38
	va_list arg;	
	va_start(arg, fmt);
    2f48:	7e 01       	movw	r14, r28
    2f4a:	39 e3       	ldi	r19, 0x39	; 57
    2f4c:	e3 0e       	add	r14, r19
    2f4e:	f1 1c       	adc	r15, r1
    2f50:	2c ec       	ldi	r18, 0xCC	; 204
    2f52:	3c e2       	ldi	r19, 0x2C	; 44
	display_vprintf(line, pos, fmt, arg);
    2f54:	e8 eb       	ldi	r30, 0xB8	; 184
    2f56:	fc e2       	ldi	r31, 0x2C	; 44
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
    2f58:	11 92       	st	Z+, r1
	char ch;
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
    2f5a:	e2 17       	cp	r30, r18
    2f5c:	f3 07       	cpc	r31, r19
    2f5e:	e1 f7       	brne	.-8      	; 0x2f58 <vDisplayWriteStringAtPos+0x46>
    2f60:	0f 2e       	mov	r0, r31
    2f62:	f4 ea       	ldi	r31, 0xA4	; 164
    2f64:	af 2e       	mov	r10, r31
    2f66:	fc e2       	ldi	r31, 0x2C	; 44
    2f68:	bf 2e       	mov	r11, r31
    2f6a:	f0 2d       	mov	r31, r0
    2f6c:	28 eb       	ldi	r18, 0xB8	; 184
    2f6e:	3c e2       	ldi	r19, 0x2C	; 44
    2f70:	f5 01       	movw	r30, r10
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
    2f72:	11 92       	st	Z+, r1
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    2f74:	e2 17       	cp	r30, r18
    2f76:	f3 07       	cpc	r31, r19
    2f78:	e1 f7       	brne	.-8      	; 0x2f72 <vDisplayWriteStringAtPos+0x60>
    2f7a:	81 2c       	mov	r8, r1
    2f7c:	91 2c       	mov	r9, r1
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    2f7e:	0f 2e       	mov	r0, r31
    2f80:	f8 eb       	ldi	r31, 0xB8	; 184
    2f82:	cf 2e       	mov	r12, r31
    2f84:	fc e2       	ldi	r31, 0x2C	; 44
    2f86:	df 2e       	mov	r13, r31
    2f88:	f0 2d       	mov	r31, r0
    2f8a:	fc c2       	rjmp	.+1528   	; 0x3584 <vDisplayWriteStringAtPos+0x672>
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
    2f8c:	85 32       	cpi	r24, 0x25	; 37
    2f8e:	09 f0       	breq	.+2      	; 0x2f92 <vDisplayWriteStringAtPos+0x80>
    2f90:	e8 c2       	rjmp	.+1488   	; 0x3562 <vDisplayWriteStringAtPos+0x650>
			switch (ch = *fmt++) {
    2f92:	2d 01       	movw	r4, r26
    2f94:	82 e0       	ldi	r24, 0x02	; 2
    2f96:	48 0e       	add	r4, r24
    2f98:	51 1c       	adc	r5, r1
    2f9a:	11 96       	adiw	r26, 0x01	; 1
    2f9c:	8c 91       	ld	r24, X
    2f9e:	85 36       	cpi	r24, 0x65	; 101
    2fa0:	09 f4       	brne	.+2      	; 0x2fa4 <vDisplayWriteStringAtPos+0x92>
    2fa2:	db c1       	rjmp	.+950    	; 0x335a <vDisplayWriteStringAtPos+0x448>
    2fa4:	38 f4       	brcc	.+14     	; 0x2fb4 <vDisplayWriteStringAtPos+0xa2>
    2fa6:	83 36       	cpi	r24, 0x63	; 99
    2fa8:	c1 f0       	breq	.+48     	; 0x2fda <vDisplayWriteStringAtPos+0xc8>
    2faa:	08 f0       	brcs	.+2      	; 0x2fae <vDisplayWriteStringAtPos+0x9c>
    2fac:	48 c0       	rjmp	.+144    	; 0x303e <vDisplayWriteStringAtPos+0x12c>
    2fae:	85 32       	cpi	r24, 0x25	; 37
    2fb0:	51 f0       	breq	.+20     	; 0x2fc6 <vDisplayWriteStringAtPos+0xb4>
    2fb2:	e7 c2       	rjmp	.+1486   	; 0x3582 <vDisplayWriteStringAtPos+0x670>
    2fb4:	83 37       	cpi	r24, 0x73	; 115
    2fb6:	f9 f0       	breq	.+62     	; 0x2ff6 <vDisplayWriteStringAtPos+0xe4>
    2fb8:	88 37       	cpi	r24, 0x78	; 120
    2fba:	09 f4       	brne	.+2      	; 0x2fbe <vDisplayWriteStringAtPos+0xac>
    2fbc:	68 c0       	rjmp	.+208    	; 0x308e <vDisplayWriteStringAtPos+0x17c>
    2fbe:	86 36       	cpi	r24, 0x66	; 102
    2fc0:	09 f0       	breq	.+2      	; 0x2fc4 <vDisplayWriteStringAtPos+0xb2>
    2fc2:	df c2       	rjmp	.+1470   	; 0x3582 <vDisplayWriteStringAtPos+0x670>
    2fc4:	8c c0       	rjmp	.+280    	; 0x30de <vDisplayWriteStringAtPos+0x1cc>
				/* %% - print out a single %    */
				case '%':
				str[length] = '%';
    2fc6:	f4 01       	movw	r30, r8
    2fc8:	ec 55       	subi	r30, 0x5C	; 92
    2fca:	f3 4d       	sbci	r31, 0xD3	; 211
    2fcc:	95 e2       	ldi	r25, 0x25	; 37
    2fce:	90 83       	st	Z, r25
				length++;
    2fd0:	af ef       	ldi	r26, 0xFF	; 255
    2fd2:	8a 1a       	sub	r8, r26
    2fd4:	9a 0a       	sbc	r9, r26
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2fd6:	d2 01       	movw	r26, r4
    2fd8:	d5 c2       	rjmp	.+1450   	; 0x3584 <vDisplayWriteStringAtPos+0x672>
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
				str[length] = char_temp;
    2fda:	f4 01       	movw	r30, r8
    2fdc:	ec 55       	subi	r30, 0x5C	; 92
    2fde:	f3 4d       	sbci	r31, 0xD3	; 211
    2fe0:	d7 01       	movw	r26, r14
    2fe2:	8c 91       	ld	r24, X
    2fe4:	80 83       	st	Z, r24
				length++;
    2fe6:	bf ef       	ldi	r27, 0xFF	; 255
    2fe8:	8b 1a       	sub	r8, r27
    2fea:	9b 0a       	sbc	r9, r27
				length++;
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
    2fec:	f7 01       	movw	r30, r14
    2fee:	32 96       	adiw	r30, 0x02	; 2
    2ff0:	7f 01       	movw	r14, r30
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2ff2:	d2 01       	movw	r26, r4
    2ff4:	c7 c2       	rjmp	.+1422   	; 0x3584 <vDisplayWriteStringAtPos+0x672>
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    2ff6:	a7 01       	movw	r20, r14
    2ff8:	4e 5f       	subi	r20, 0xFE	; 254
    2ffa:	5f 4f       	sbci	r21, 0xFF	; 255
    2ffc:	d7 01       	movw	r26, r14
    2ffe:	8d 91       	ld	r24, X+
    3000:	9c 91       	ld	r25, X
    3002:	9c 01       	movw	r18, r24
    3004:	b4 01       	movw	r22, r8
    3006:	f4 01       	movw	r30, r8
    3008:	ec 55       	subi	r30, 0x5C	; 92
    300a:	f3 4d       	sbci	r31, 0xD3	; 211
				for(int i = 0; i < strlen(string_temp);i++) {
    300c:	00 e0       	ldi	r16, 0x00	; 0
    300e:	10 e0       	ldi	r17, 0x00	; 0
    3010:	06 c0       	rjmp	.+12     	; 0x301e <vDisplayWriteStringAtPos+0x10c>
					str[length+i] = string_temp[i];
    3012:	d9 01       	movw	r26, r18
    3014:	fd 90       	ld	r15, X+
    3016:	9d 01       	movw	r18, r26
    3018:	f1 92       	st	Z+, r15
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
				for(int i = 0; i < strlen(string_temp);i++) {
    301a:	0f 5f       	subi	r16, 0xFF	; 255
    301c:	1f 4f       	sbci	r17, 0xFF	; 255
    301e:	dc 01       	movw	r26, r24
    3020:	0d 90       	ld	r0, X+
    3022:	00 20       	and	r0, r0
    3024:	e9 f7       	brne	.-6      	; 0x3020 <vDisplayWriteStringAtPos+0x10e>
    3026:	11 97       	sbiw	r26, 0x01	; 1
    3028:	a8 1b       	sub	r26, r24
    302a:	b9 0b       	sbc	r27, r25
    302c:	0a 17       	cp	r16, r26
    302e:	1b 07       	cpc	r17, r27
    3030:	80 f3       	brcs	.-32     	; 0x3012 <vDisplayWriteStringAtPos+0x100>
					str[length+i] = string_temp[i];
				}
				length += strlen(string_temp);
    3032:	4d 01       	movw	r8, r26
    3034:	86 0e       	add	r8, r22
    3036:	97 1e       	adc	r9, r23
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    3038:	7a 01       	movw	r14, r20
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    303a:	d2 01       	movw	r26, r4
    303c:	a3 c2       	rjmp	.+1350   	; 0x3584 <vDisplayWriteStringAtPos+0x672>
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    303e:	87 01       	movw	r16, r14
    3040:	0e 5f       	subi	r16, 0xFE	; 254
    3042:	1f 4f       	sbci	r17, 0xFF	; 255
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    3044:	4a e0       	ldi	r20, 0x0A	; 10
    3046:	b6 01       	movw	r22, r12
    3048:	f7 01       	movw	r30, r14
    304a:	80 81       	ld	r24, Z
    304c:	91 81       	ldd	r25, Z+1	; 0x01
    304e:	0e 94 a8 1d 	call	0x3b50	; 0x3b50 <__itoa_ncheck>
    3052:	94 01       	movw	r18, r8
    3054:	d4 01       	movw	r26, r8
    3056:	ac 55       	subi	r26, 0x5C	; 92
    3058:	b3 4d       	sbci	r27, 0xD3	; 211
    305a:	48 eb       	ldi	r20, 0xB8	; 184
    305c:	5c e2       	ldi	r21, 0x2C	; 44
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    305e:	80 e0       	ldi	r24, 0x00	; 0
    3060:	90 e0       	ldi	r25, 0x00	; 0
    3062:	05 c0       	rjmp	.+10     	; 0x306e <vDisplayWriteStringAtPos+0x15c>
					str[length+i] = buffer[i];
    3064:	fa 01       	movw	r30, r20
    3066:	61 91       	ld	r22, Z+
    3068:	af 01       	movw	r20, r30
    306a:	6d 93       	st	X+, r22

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    306c:	01 96       	adiw	r24, 0x01	; 1
    306e:	f6 01       	movw	r30, r12
    3070:	01 90       	ld	r0, Z+
    3072:	00 20       	and	r0, r0
    3074:	e9 f7       	brne	.-6      	; 0x3070 <vDisplayWriteStringAtPos+0x15e>
    3076:	31 97       	sbiw	r30, 0x01	; 1
    3078:	e8 5b       	subi	r30, 0xB8	; 184
    307a:	fc 42       	sbci	r31, 0x2C	; 44
    307c:	8e 17       	cp	r24, r30
    307e:	9f 07       	cpc	r25, r31
    3080:	88 f3       	brcs	.-30     	; 0x3064 <vDisplayWriteStringAtPos+0x152>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    3082:	4f 01       	movw	r8, r30
    3084:	82 0e       	add	r8, r18
    3086:	93 1e       	adc	r9, r19
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    3088:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    308a:	d2 01       	movw	r26, r4
    308c:	7b c2       	rjmp	.+1270   	; 0x3584 <vDisplayWriteStringAtPos+0x672>
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    308e:	87 01       	movw	r16, r14
    3090:	0e 5f       	subi	r16, 0xFE	; 254
    3092:	1f 4f       	sbci	r17, 0xFF	; 255
    3094:	40 e1       	ldi	r20, 0x10	; 16
    3096:	b6 01       	movw	r22, r12
    3098:	d7 01       	movw	r26, r14
    309a:	8d 91       	ld	r24, X+
    309c:	9c 91       	ld	r25, X
    309e:	0e 94 a8 1d 	call	0x3b50	; 0x3b50 <__itoa_ncheck>
    30a2:	94 01       	movw	r18, r8
    30a4:	f4 01       	movw	r30, r8
    30a6:	ec 55       	subi	r30, 0x5C	; 92
    30a8:	f3 4d       	sbci	r31, 0xD3	; 211
    30aa:	48 eb       	ldi	r20, 0xB8	; 184
    30ac:	5c e2       	ldi	r21, 0x2C	; 44
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    30ae:	80 e0       	ldi	r24, 0x00	; 0
    30b0:	90 e0       	ldi	r25, 0x00	; 0
    30b2:	05 c0       	rjmp	.+10     	; 0x30be <vDisplayWriteStringAtPos+0x1ac>
					str[length+i] = buffer[i];
    30b4:	da 01       	movw	r26, r20
    30b6:	6d 91       	ld	r22, X+
    30b8:	ad 01       	movw	r20, r26
    30ba:	61 93       	st	Z+, r22

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    30bc:	01 96       	adiw	r24, 0x01	; 1
    30be:	d6 01       	movw	r26, r12
    30c0:	0d 90       	ld	r0, X+
    30c2:	00 20       	and	r0, r0
    30c4:	e9 f7       	brne	.-6      	; 0x30c0 <vDisplayWriteStringAtPos+0x1ae>
    30c6:	11 97       	sbiw	r26, 0x01	; 1
    30c8:	a8 5b       	subi	r26, 0xB8	; 184
    30ca:	bc 42       	sbci	r27, 0x2C	; 44
    30cc:	8a 17       	cp	r24, r26
    30ce:	9b 07       	cpc	r25, r27
    30d0:	88 f3       	brcs	.-30     	; 0x30b4 <vDisplayWriteStringAtPos+0x1a2>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    30d2:	4d 01       	movw	r8, r26
    30d4:	82 0e       	add	r8, r18
    30d6:	93 1e       	adc	r9, r19
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    30d8:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    30da:	d2 01       	movw	r26, r4
    30dc:	53 c2       	rjmp	.+1190   	; 0x3584 <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    30de:	17 01       	movw	r2, r14
    30e0:	b4 e0       	ldi	r27, 0x04	; 4
    30e2:	2b 0e       	add	r2, r27
    30e4:	31 1c       	adc	r3, r1
    30e6:	d7 01       	movw	r26, r14
    30e8:	8d 91       	ld	r24, X+
    30ea:	9d 91       	ld	r25, X+
    30ec:	0d 90       	ld	r0, X+
    30ee:	bc 91       	ld	r27, X
    30f0:	a0 2d       	mov	r26, r0
    30f2:	8f 8b       	std	Y+23, r24	; 0x17
    30f4:	98 8f       	std	Y+24, r25	; 0x18
    30f6:	a9 8f       	std	Y+25, r26	; 0x19
    30f8:	ba 8f       	std	Y+26, r27	; 0x1a

    int exponent = 0;
    int places = 0;
    static const int width = 4;

    if (value == 0.0) {
    30fa:	20 e0       	ldi	r18, 0x00	; 0
    30fc:	30 e0       	ldi	r19, 0x00	; 0
    30fe:	a9 01       	movw	r20, r18
    3100:	bc 01       	movw	r22, r24
    3102:	cd 01       	movw	r24, r26
    3104:	0e 94 bf 1b 	call	0x377e	; 0x377e <__cmpsf2>
    3108:	81 11       	cpse	r24, r1
    310a:	05 c0       	rjmp	.+10     	; 0x3116 <vDisplayWriteStringAtPos+0x204>
        buffer[0] = '0';
    310c:	20 e3       	ldi	r18, 0x30	; 48
    310e:	f6 01       	movw	r30, r12
    3110:	20 83       	st	Z, r18
        buffer[1] = '\0';
    3112:	11 82       	std	Z+1, r1	; 0x01
    3114:	04 c1       	rjmp	.+520    	; 0x331e <vDisplayWriteStringAtPos+0x40c>
        return;
    }         

    if (value < 0.0) {
    3116:	20 e0       	ldi	r18, 0x00	; 0
    3118:	30 e0       	ldi	r19, 0x00	; 0
    311a:	a9 01       	movw	r20, r18
    311c:	6f 89       	ldd	r22, Y+23	; 0x17
    311e:	78 8d       	ldd	r23, Y+24	; 0x18
    3120:	89 8d       	ldd	r24, Y+25	; 0x19
    3122:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3124:	0e 94 bf 1b 	call	0x377e	; 0x377e <__cmpsf2>
    3128:	88 23       	and	r24, r24
    312a:	9c f4       	brge	.+38     	; 0x3152 <vDisplayWriteStringAtPos+0x240>
        *buffer++ = '-';
    312c:	ed e2       	ldi	r30, 0x2D	; 45
    312e:	d6 01       	movw	r26, r12
    3130:	ec 93       	st	X, r30
        value = -value;
    3132:	8f 89       	ldd	r24, Y+23	; 0x17
    3134:	98 8d       	ldd	r25, Y+24	; 0x18
    3136:	a9 8d       	ldd	r26, Y+25	; 0x19
    3138:	ba 8d       	ldd	r27, Y+26	; 0x1a
    313a:	b0 58       	subi	r27, 0x80	; 128
    313c:	8f 8b       	std	Y+23, r24	; 0x17
    313e:	98 8f       	std	Y+24, r25	; 0x18
    3140:	a9 8f       	std	Y+25, r26	; 0x19
    3142:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
        *buffer++ = '-';
    3144:	0f 2e       	mov	r0, r31
    3146:	f9 eb       	ldi	r31, 0xB9	; 185
    3148:	6f 2e       	mov	r6, r31
    314a:	fc e2       	ldi	r31, 0x2C	; 44
    314c:	7f 2e       	mov	r7, r31
    314e:	f0 2d       	mov	r31, r0
    3150:	01 c0       	rjmp	.+2      	; 0x3154 <vDisplayWriteStringAtPos+0x242>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
    3152:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3154:	20 e0       	ldi	r18, 0x00	; 0
    3156:	30 e0       	ldi	r19, 0x00	; 0
    3158:	40 e8       	ldi	r20, 0x80	; 128
    315a:	5f e3       	ldi	r21, 0x3F	; 63
    315c:	6f 89       	ldd	r22, Y+23	; 0x17
    315e:	78 8d       	ldd	r23, Y+24	; 0x18
    3160:	89 8d       	ldd	r24, Y+25	; 0x19
    3162:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3164:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <__gesf2>
    3168:	88 23       	and	r24, r24
    316a:	0c f4       	brge	.+2      	; 0x316e <vDisplayWriteStringAtPos+0x25c>
    316c:	44 c2       	rjmp	.+1160   	; 0x35f6 <vDisplayWriteStringAtPos+0x6e4>
    316e:	00 e0       	ldi	r16, 0x00	; 0
    3170:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    3172:	20 e0       	ldi	r18, 0x00	; 0
    3174:	30 e0       	ldi	r19, 0x00	; 0
    3176:	40 e2       	ldi	r20, 0x20	; 32
    3178:	51 e4       	ldi	r21, 0x41	; 65
    317a:	6f 89       	ldd	r22, Y+23	; 0x17
    317c:	78 8d       	ldd	r23, Y+24	; 0x18
    317e:	89 8d       	ldd	r24, Y+25	; 0x19
    3180:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3182:	0e 94 c4 1b 	call	0x3788	; 0x3788 <__divsf3>
    3186:	6f 8b       	std	Y+23, r22	; 0x17
    3188:	78 8f       	std	Y+24, r23	; 0x18
    318a:	89 8f       	std	Y+25, r24	; 0x19
    318c:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    318e:	0f 5f       	subi	r16, 0xFF	; 255
    3190:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3192:	20 e0       	ldi	r18, 0x00	; 0
    3194:	30 e0       	ldi	r19, 0x00	; 0
    3196:	40 e8       	ldi	r20, 0x80	; 128
    3198:	5f e3       	ldi	r21, 0x3F	; 63
    319a:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <__gesf2>
    319e:	88 23       	and	r24, r24
    31a0:	44 f7       	brge	.-48     	; 0x3172 <vDisplayWriteStringAtPos+0x260>
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    31a2:	2d ec       	ldi	r18, 0xCD	; 205
    31a4:	3c ec       	ldi	r19, 0xCC	; 204
    31a6:	4c ec       	ldi	r20, 0xCC	; 204
    31a8:	5d e3       	ldi	r21, 0x3D	; 61
    31aa:	6f 89       	ldd	r22, Y+23	; 0x17
    31ac:	78 8d       	ldd	r23, Y+24	; 0x18
    31ae:	89 8d       	ldd	r24, Y+25	; 0x19
    31b0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    31b2:	0e 94 bf 1b 	call	0x377e	; 0x377e <__cmpsf2>
    31b6:	88 23       	and	r24, r24
    31b8:	1c f0       	brlt	.+6      	; 0x31c0 <vDisplayWriteStringAtPos+0x2ae>
    31ba:	1a c0       	rjmp	.+52     	; 0x31f0 <vDisplayWriteStringAtPos+0x2de>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    31bc:	00 e0       	ldi	r16, 0x00	; 0
    31be:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
        value *= 10.0;
    31c0:	20 e0       	ldi	r18, 0x00	; 0
    31c2:	30 e0       	ldi	r19, 0x00	; 0
    31c4:	40 e2       	ldi	r20, 0x20	; 32
    31c6:	51 e4       	ldi	r21, 0x41	; 65
    31c8:	6f 89       	ldd	r22, Y+23	; 0x17
    31ca:	78 8d       	ldd	r23, Y+24	; 0x18
    31cc:	89 8d       	ldd	r24, Y+25	; 0x19
    31ce:	9a 8d       	ldd	r25, Y+26	; 0x1a
    31d0:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <__mulsf3>
    31d4:	6f 8b       	std	Y+23, r22	; 0x17
    31d6:	78 8f       	std	Y+24, r23	; 0x18
    31d8:	89 8f       	std	Y+25, r24	; 0x19
    31da:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    31dc:	01 50       	subi	r16, 0x01	; 1
    31de:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    31e0:	2d ec       	ldi	r18, 0xCD	; 205
    31e2:	3c ec       	ldi	r19, 0xCC	; 204
    31e4:	4c ec       	ldi	r20, 0xCC	; 204
    31e6:	5d e3       	ldi	r21, 0x3D	; 61
    31e8:	0e 94 bf 1b 	call	0x377e	; 0x377e <__cmpsf2>
    31ec:	88 23       	and	r24, r24
    31ee:	44 f3       	brlt	.-48     	; 0x31c0 <vDisplayWriteStringAtPos+0x2ae>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    31f0:	10 16       	cp	r1, r16
    31f2:	11 06       	cpc	r1, r17
    31f4:	ac f5       	brge	.+106    	; 0x3260 <vDisplayWriteStringAtPos+0x34e>
    31f6:	73 01       	movw	r14, r6
    31f8:	d3 01       	movw	r26, r6
    31fa:	a0 0f       	add	r26, r16
    31fc:	b1 1f       	adc	r27, r17
    31fe:	ac 8f       	std	Y+28, r26	; 0x1c
    3200:	bd 8f       	std	Y+29, r27	; 0x1d
    3202:	3d 01       	movw	r6, r26
    3204:	6f 89       	ldd	r22, Y+23	; 0x17
    3206:	78 8d       	ldd	r23, Y+24	; 0x18
    3208:	89 8d       	ldd	r24, Y+25	; 0x19
    320a:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10;
    320c:	20 e0       	ldi	r18, 0x00	; 0
    320e:	30 e0       	ldi	r19, 0x00	; 0
    3210:	40 e2       	ldi	r20, 0x20	; 32
    3212:	51 e4       	ldi	r21, 0x41	; 65
    3214:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <__mulsf3>
    3218:	6f 8b       	std	Y+23, r22	; 0x17
    321a:	78 8f       	std	Y+24, r23	; 0x18
    321c:	89 8f       	std	Y+25, r24	; 0x19
    321e:	9a 8f       	std	Y+26, r25	; 0x1a
    3220:	0e 94 36 1c 	call	0x386c	; 0x386c <__fixsfsi>
        *buffer++ = digit + '0';
    3224:	20 e3       	ldi	r18, 0x30	; 48
    3226:	26 0f       	add	r18, r22
    3228:	f7 01       	movw	r30, r14
    322a:	21 93       	st	Z+, r18
    322c:	7f 01       	movw	r14, r30
        value = value * 10 - digit;
    322e:	07 2e       	mov	r0, r23
    3230:	00 0c       	add	r0, r0
    3232:	88 0b       	sbc	r24, r24
    3234:	99 0b       	sbc	r25, r25
    3236:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <__floatsisf>
    323a:	9b 01       	movw	r18, r22
    323c:	ac 01       	movw	r20, r24
    323e:	6f 89       	ldd	r22, Y+23	; 0x17
    3240:	78 8d       	ldd	r23, Y+24	; 0x18
    3242:	89 8d       	ldd	r24, Y+25	; 0x19
    3244:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3246:	0e 94 52 1b 	call	0x36a4	; 0x36a4 <__subsf3>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    324a:	e6 14       	cp	r14, r6
    324c:	f7 04       	cpc	r15, r7
    324e:	f1 f6       	brne	.-68     	; 0x320c <vDisplayWriteStringAtPos+0x2fa>
    3250:	6f 8b       	std	Y+23, r22	; 0x17
    3252:	78 8f       	std	Y+24, r23	; 0x18
    3254:	89 8f       	std	Y+25, r24	; 0x19
    3256:	9a 8f       	std	Y+26, r25	; 0x1a
        value = value * 10 - digit;
        ++places;
        --exponent;
    }

    if (places == 0)
    3258:	01 15       	cp	r16, r1
    325a:	11 05       	cpc	r17, r1
    325c:	89 f4       	brne	.+34     	; 0x3280 <vDisplayWriteStringAtPos+0x36e>
    325e:	db c1       	rjmp	.+950    	; 0x3616 <vDisplayWriteStringAtPos+0x704>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    3260:	c8 01       	movw	r24, r16
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    3262:	e0 e3       	ldi	r30, 0x30	; 48
    3264:	d3 01       	movw	r26, r6
    3266:	ec 93       	st	X, r30

    *buffer++ = '.';
    3268:	73 01       	movw	r14, r6
    326a:	f2 e0       	ldi	r31, 0x02	; 2
    326c:	ef 0e       	add	r14, r31
    326e:	f1 1c       	adc	r15, r1
    3270:	2e e2       	ldi	r18, 0x2E	; 46
    3272:	11 96       	adiw	r26, 0x01	; 1
    3274:	2c 93       	st	X, r18

    while (exponent < 0 && places < width) {
    3276:	99 23       	and	r25, r25
    3278:	6c f0       	brlt	.+26     	; 0x3294 <vDisplayWriteStringAtPos+0x382>
    327a:	00 e0       	ldi	r16, 0x00	; 0
    327c:	10 e0       	ldi	r17, 0x00	; 0
    327e:	1f c0       	rjmp	.+62     	; 0x32be <vDisplayWriteStringAtPos+0x3ac>
    }

    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';
    3280:	ec 8c       	ldd	r14, Y+28	; 0x1c
    3282:	fd 8c       	ldd	r15, Y+29	; 0x1d
    3284:	3f ef       	ldi	r19, 0xFF	; 255
    3286:	e3 1a       	sub	r14, r19
    3288:	f3 0a       	sbc	r15, r19
    328a:	ee e2       	ldi	r30, 0x2E	; 46
    328c:	ac 8d       	ldd	r26, Y+28	; 0x1c
    328e:	bd 8d       	ldd	r27, Y+29	; 0x1d
    3290:	ec 93       	st	X, r30
    3292:	12 c0       	rjmp	.+36     	; 0x32b8 <vDisplayWriteStringAtPos+0x3a6>

    while (exponent < 0 && places < width) {
    3294:	00 e0       	ldi	r16, 0x00	; 0
    3296:	10 e0       	ldi	r17, 0x00	; 0
        *buffer++ = '0';
    3298:	ff ef       	ldi	r31, 0xFF	; 255
    329a:	ef 1a       	sub	r14, r31
    329c:	ff 0a       	sbc	r15, r31
    329e:	f7 01       	movw	r30, r14
    32a0:	31 97       	sbiw	r30, 0x01	; 1
    32a2:	20 e3       	ldi	r18, 0x30	; 48
    32a4:	20 83       	st	Z, r18
        --exponent;
    32a6:	01 97       	sbiw	r24, 0x01	; 1
        ++places;
    32a8:	0f 5f       	subi	r16, 0xFF	; 255
    32aa:	1f 4f       	sbci	r17, 0xFF	; 255
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    32ac:	99 23       	and	r25, r25
    32ae:	24 f4       	brge	.+8      	; 0x32b8 <vDisplayWriteStringAtPos+0x3a6>
    32b0:	04 30       	cpi	r16, 0x04	; 4
    32b2:	11 05       	cpc	r17, r1
    32b4:	8c f3       	brlt	.-30     	; 0x3298 <vDisplayWriteStringAtPos+0x386>
    32b6:	31 c0       	rjmp	.+98     	; 0x331a <vDisplayWriteStringAtPos+0x408>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    32b8:	04 30       	cpi	r16, 0x04	; 4
    32ba:	11 05       	cpc	r17, r1
    32bc:	74 f5       	brge	.+92     	; 0x331a <vDisplayWriteStringAtPos+0x408>
    32be:	37 01       	movw	r6, r14
    32c0:	84 e0       	ldi	r24, 0x04	; 4
    32c2:	90 e0       	ldi	r25, 0x00	; 0
    32c4:	80 1b       	sub	r24, r16
    32c6:	91 0b       	sbc	r25, r17
    32c8:	e8 0e       	add	r14, r24
    32ca:	f9 1e       	adc	r15, r25
    32cc:	87 01       	movw	r16, r14
    32ce:	6f 89       	ldd	r22, Y+23	; 0x17
    32d0:	78 8d       	ldd	r23, Y+24	; 0x18
    32d2:	89 8d       	ldd	r24, Y+25	; 0x19
    32d4:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10.0;
    32d6:	20 e0       	ldi	r18, 0x00	; 0
    32d8:	30 e0       	ldi	r19, 0x00	; 0
    32da:	40 e2       	ldi	r20, 0x20	; 32
    32dc:	51 e4       	ldi	r21, 0x41	; 65
    32de:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <__mulsf3>
    32e2:	6f 8b       	std	Y+23, r22	; 0x17
    32e4:	78 8f       	std	Y+24, r23	; 0x18
    32e6:	89 8f       	std	Y+25, r24	; 0x19
    32e8:	9a 8f       	std	Y+26, r25	; 0x1a
    32ea:	0e 94 36 1c 	call	0x386c	; 0x386c <__fixsfsi>
        *buffer++ = digit + '0';
    32ee:	20 e3       	ldi	r18, 0x30	; 48
    32f0:	26 0f       	add	r18, r22
    32f2:	d3 01       	movw	r26, r6
    32f4:	2d 93       	st	X+, r18
    32f6:	3d 01       	movw	r6, r26
        value = value * 10.0 - digit;
    32f8:	07 2e       	mov	r0, r23
    32fa:	00 0c       	add	r0, r0
    32fc:	88 0b       	sbc	r24, r24
    32fe:	99 0b       	sbc	r25, r25
    3300:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <__floatsisf>
    3304:	9b 01       	movw	r18, r22
    3306:	ac 01       	movw	r20, r24
    3308:	6f 89       	ldd	r22, Y+23	; 0x17
    330a:	78 8d       	ldd	r23, Y+24	; 0x18
    330c:	89 8d       	ldd	r24, Y+25	; 0x19
    330e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3310:	0e 94 52 1b 	call	0x36a4	; 0x36a4 <__subsf3>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    3314:	60 16       	cp	r6, r16
    3316:	71 06       	cpc	r7, r17
    3318:	f1 f6       	brne	.-68     	; 0x32d6 <vDisplayWriteStringAtPos+0x3c4>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
        ++places;
    }
    *buffer = '\0';
    331a:	f7 01       	movw	r30, r14
    331c:	10 82       	st	Z, r1
    331e:	94 01       	movw	r18, r8
    3320:	f4 01       	movw	r30, r8
    3322:	ec 55       	subi	r30, 0x5C	; 92
    3324:	f3 4d       	sbci	r31, 0xD3	; 211
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    3326:	48 eb       	ldi	r20, 0xB8	; 184
    3328:	5c e2       	ldi	r21, 0x2C	; 44
    332a:	80 e0       	ldi	r24, 0x00	; 0
    332c:	90 e0       	ldi	r25, 0x00	; 0
    332e:	05 c0       	rjmp	.+10     	; 0x333a <vDisplayWriteStringAtPos+0x428>

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    3330:	da 01       	movw	r26, r20
    3332:	6d 91       	ld	r22, X+
    3334:	ad 01       	movw	r20, r26
    3336:	61 93       	st	Z+, r22
				break;

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    3338:	01 96       	adiw	r24, 0x01	; 1
    333a:	d6 01       	movw	r26, r12
    333c:	0d 90       	ld	r0, X+
    333e:	00 20       	and	r0, r0
    3340:	e9 f7       	brne	.-6      	; 0x333c <vDisplayWriteStringAtPos+0x42a>
    3342:	11 97       	sbiw	r26, 0x01	; 1
    3344:	a8 5b       	subi	r26, 0xB8	; 184
    3346:	bc 42       	sbci	r27, 0x2C	; 44
    3348:	8a 17       	cp	r24, r26
    334a:	9b 07       	cpc	r25, r27
    334c:	88 f3       	brcs	.-30     	; 0x3330 <vDisplayWriteStringAtPos+0x41e>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    334e:	4d 01       	movw	r8, r26
    3350:	82 0e       	add	r8, r18
    3352:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    3354:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3356:	d2 01       	movw	r26, r4
    3358:	15 c1       	rjmp	.+554    	; 0x3584 <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    335a:	17 01       	movw	r2, r14
    335c:	b4 e0       	ldi	r27, 0x04	; 4
    335e:	2b 0e       	add	r2, r27
    3360:	31 1c       	adc	r3, r1
    3362:	d7 01       	movw	r26, r14
    3364:	8d 91       	ld	r24, X+
    3366:	9d 91       	ld	r25, X+
    3368:	0d 90       	ld	r0, X+
    336a:	bc 91       	ld	r27, X
    336c:	a0 2d       	mov	r26, r0
    336e:	8f 8b       	std	Y+23, r24	; 0x17
    3370:	98 8f       	std	Y+24, r25	; 0x18
    3372:	a9 8f       	std	Y+25, r26	; 0x19
    3374:	ba 8f       	std	Y+26, r27	; 0x1a

void ftoa_sci(char *buffer, double value) {
    int exponent = 0;    
    static const int width = 4;

    if (value == 0.0) {
    3376:	20 e0       	ldi	r18, 0x00	; 0
    3378:	30 e0       	ldi	r19, 0x00	; 0
    337a:	a9 01       	movw	r20, r18
    337c:	bc 01       	movw	r22, r24
    337e:	cd 01       	movw	r24, r26
    3380:	0e 94 bf 1b 	call	0x377e	; 0x377e <__cmpsf2>
    3384:	81 11       	cpse	r24, r1
    3386:	05 c0       	rjmp	.+10     	; 0x3392 <vDisplayWriteStringAtPos+0x480>
        buffer[0] = '0';
    3388:	20 e3       	ldi	r18, 0x30	; 48
    338a:	f6 01       	movw	r30, r12
    338c:	20 83       	st	Z, r18
        buffer[1] = '\0';
    338e:	11 82       	std	Z+1, r1	; 0x01
    3390:	ca c0       	rjmp	.+404    	; 0x3526 <vDisplayWriteStringAtPos+0x614>
        return;
    }

    if (value < 0.0) {
    3392:	20 e0       	ldi	r18, 0x00	; 0
    3394:	30 e0       	ldi	r19, 0x00	; 0
    3396:	a9 01       	movw	r20, r18
    3398:	6f 89       	ldd	r22, Y+23	; 0x17
    339a:	78 8d       	ldd	r23, Y+24	; 0x18
    339c:	89 8d       	ldd	r24, Y+25	; 0x19
    339e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    33a0:	0e 94 bf 1b 	call	0x377e	; 0x377e <__cmpsf2>
    33a4:	88 23       	and	r24, r24
    33a6:	9c f4       	brge	.+38     	; 0x33ce <vDisplayWriteStringAtPos+0x4bc>
        *buffer++ = '-';
    33a8:	ed e2       	ldi	r30, 0x2D	; 45
    33aa:	d6 01       	movw	r26, r12
    33ac:	ec 93       	st	X, r30
        value = -value;
    33ae:	8f 89       	ldd	r24, Y+23	; 0x17
    33b0:	98 8d       	ldd	r25, Y+24	; 0x18
    33b2:	a9 8d       	ldd	r26, Y+25	; 0x19
    33b4:	ba 8d       	ldd	r27, Y+26	; 0x1a
    33b6:	b0 58       	subi	r27, 0x80	; 128
    33b8:	8f 8b       	std	Y+23, r24	; 0x17
    33ba:	98 8f       	std	Y+24, r25	; 0x18
    33bc:	a9 8f       	std	Y+25, r26	; 0x19
    33be:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
        *buffer++ = '-';
    33c0:	0f 2e       	mov	r0, r31
    33c2:	f9 eb       	ldi	r31, 0xB9	; 185
    33c4:	6f 2e       	mov	r6, r31
    33c6:	fc e2       	ldi	r31, 0x2C	; 44
    33c8:	7f 2e       	mov	r7, r31
    33ca:	f0 2d       	mov	r31, r0
    33cc:	01 c0       	rjmp	.+2      	; 0x33d0 <vDisplayWriteStringAtPos+0x4be>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
    33ce:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    33d0:	20 e0       	ldi	r18, 0x00	; 0
    33d2:	30 e0       	ldi	r19, 0x00	; 0
    33d4:	40 e8       	ldi	r20, 0x80	; 128
    33d6:	5f e3       	ldi	r21, 0x3F	; 63
    33d8:	6f 89       	ldd	r22, Y+23	; 0x17
    33da:	78 8d       	ldd	r23, Y+24	; 0x18
    33dc:	89 8d       	ldd	r24, Y+25	; 0x19
    33de:	9a 8d       	ldd	r25, Y+26	; 0x1a
    33e0:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <__gesf2>
    33e4:	88 23       	and	r24, r24
    33e6:	dc f0       	brlt	.+54     	; 0x341e <vDisplayWriteStringAtPos+0x50c>
    33e8:	00 e0       	ldi	r16, 0x00	; 0
    33ea:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    33ec:	20 e0       	ldi	r18, 0x00	; 0
    33ee:	30 e0       	ldi	r19, 0x00	; 0
    33f0:	40 e2       	ldi	r20, 0x20	; 32
    33f2:	51 e4       	ldi	r21, 0x41	; 65
    33f4:	6f 89       	ldd	r22, Y+23	; 0x17
    33f6:	78 8d       	ldd	r23, Y+24	; 0x18
    33f8:	89 8d       	ldd	r24, Y+25	; 0x19
    33fa:	9a 8d       	ldd	r25, Y+26	; 0x1a
    33fc:	0e 94 c4 1b 	call	0x3788	; 0x3788 <__divsf3>
    3400:	6f 8b       	std	Y+23, r22	; 0x17
    3402:	78 8f       	std	Y+24, r23	; 0x18
    3404:	89 8f       	std	Y+25, r24	; 0x19
    3406:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    3408:	0f 5f       	subi	r16, 0xFF	; 255
    340a:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    340c:	20 e0       	ldi	r18, 0x00	; 0
    340e:	30 e0       	ldi	r19, 0x00	; 0
    3410:	40 e8       	ldi	r20, 0x80	; 128
    3412:	5f e3       	ldi	r21, 0x3F	; 63
    3414:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <__gesf2>
    3418:	88 23       	and	r24, r24
    341a:	44 f7       	brge	.-48     	; 0x33ec <vDisplayWriteStringAtPos+0x4da>
    341c:	02 c0       	rjmp	.+4      	; 0x3422 <vDisplayWriteStringAtPos+0x510>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    341e:	00 e0       	ldi	r16, 0x00	; 0
    3420:	10 e0       	ldi	r17, 0x00	; 0
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3422:	2d ec       	ldi	r18, 0xCD	; 205
    3424:	3c ec       	ldi	r19, 0xCC	; 204
    3426:	4c ec       	ldi	r20, 0xCC	; 204
    3428:	5d e3       	ldi	r21, 0x3D	; 61
    342a:	6f 89       	ldd	r22, Y+23	; 0x17
    342c:	78 8d       	ldd	r23, Y+24	; 0x18
    342e:	89 8d       	ldd	r24, Y+25	; 0x19
    3430:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3432:	0e 94 bf 1b 	call	0x377e	; 0x377e <__cmpsf2>
    3436:	88 23       	and	r24, r24
    3438:	c4 f4       	brge	.+48     	; 0x346a <vDisplayWriteStringAtPos+0x558>
        value *= 10.0;
    343a:	20 e0       	ldi	r18, 0x00	; 0
    343c:	30 e0       	ldi	r19, 0x00	; 0
    343e:	40 e2       	ldi	r20, 0x20	; 32
    3440:	51 e4       	ldi	r21, 0x41	; 65
    3442:	6f 89       	ldd	r22, Y+23	; 0x17
    3444:	78 8d       	ldd	r23, Y+24	; 0x18
    3446:	89 8d       	ldd	r24, Y+25	; 0x19
    3448:	9a 8d       	ldd	r25, Y+26	; 0x1a
    344a:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <__mulsf3>
    344e:	6f 8b       	std	Y+23, r22	; 0x17
    3450:	78 8f       	std	Y+24, r23	; 0x18
    3452:	89 8f       	std	Y+25, r24	; 0x19
    3454:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    3456:	01 50       	subi	r16, 0x01	; 1
    3458:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    345a:	2d ec       	ldi	r18, 0xCD	; 205
    345c:	3c ec       	ldi	r19, 0xCC	; 204
    345e:	4c ec       	ldi	r20, 0xCC	; 204
    3460:	5d e3       	ldi	r21, 0x3D	; 61
    3462:	0e 94 bf 1b 	call	0x377e	; 0x377e <__cmpsf2>
    3466:	88 23       	and	r24, r24
    3468:	44 f3       	brlt	.-48     	; 0x343a <vDisplayWriteStringAtPos+0x528>
        value = -value;
    }

    exponent = normalize(&value);

    int digit = value * 10.0;
    346a:	20 e0       	ldi	r18, 0x00	; 0
    346c:	30 e0       	ldi	r19, 0x00	; 0
    346e:	40 e2       	ldi	r20, 0x20	; 32
    3470:	51 e4       	ldi	r21, 0x41	; 65
    3472:	6f 89       	ldd	r22, Y+23	; 0x17
    3474:	78 8d       	ldd	r23, Y+24	; 0x18
    3476:	89 8d       	ldd	r24, Y+25	; 0x19
    3478:	9a 8d       	ldd	r25, Y+26	; 0x1a
    347a:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <__mulsf3>
    347e:	6f 8b       	std	Y+23, r22	; 0x17
    3480:	78 8f       	std	Y+24, r23	; 0x18
    3482:	89 8f       	std	Y+25, r24	; 0x19
    3484:	9a 8f       	std	Y+26, r25	; 0x1a
    3486:	0e 94 36 1c 	call	0x386c	; 0x386c <__fixsfsi>
    *buffer++ = digit + '0';
    348a:	20 e3       	ldi	r18, 0x30	; 48
    348c:	26 0f       	add	r18, r22
    348e:	d3 01       	movw	r26, r6
    3490:	2c 93       	st	X, r18
    value = value * 10.0 - digit;
    3492:	07 2e       	mov	r0, r23
    3494:	00 0c       	add	r0, r0
    3496:	88 0b       	sbc	r24, r24
    3498:	99 0b       	sbc	r25, r25
    349a:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <__floatsisf>
    349e:	9b 01       	movw	r18, r22
    34a0:	ac 01       	movw	r20, r24
    34a2:	6f 89       	ldd	r22, Y+23	; 0x17
    34a4:	78 8d       	ldd	r23, Y+24	; 0x18
    34a6:	89 8d       	ldd	r24, Y+25	; 0x19
    34a8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    34aa:	0e 94 52 1b 	call	0x36a4	; 0x36a4 <__subsf3>
    --exponent;
    34ae:	f8 01       	movw	r30, r16
    34b0:	31 97       	sbiw	r30, 0x01	; 1
    34b2:	ec 8f       	std	Y+28, r30	; 0x1c
    34b4:	fd 8f       	std	Y+29, r31	; 0x1d

    *buffer++ = '.';
    34b6:	ee e2       	ldi	r30, 0x2E	; 46
    34b8:	d3 01       	movw	r26, r6
    34ba:	11 96       	adiw	r26, 0x01	; 1
    34bc:	ec 93       	st	X, r30
    34be:	83 01       	movw	r16, r6
    34c0:	0e 5f       	subi	r16, 0xFE	; 254
    34c2:	1f 4f       	sbci	r17, 0xFF	; 255
    34c4:	73 01       	movw	r14, r6
    34c6:	f6 e0       	ldi	r31, 0x06	; 6
    34c8:	ef 0e       	add	r14, r31
    34ca:	f1 1c       	adc	r15, r1

    for (int i = 0; i < width; i++) {
        int digit = value * 10.0;
    34cc:	20 e0       	ldi	r18, 0x00	; 0
    34ce:	30 e0       	ldi	r19, 0x00	; 0
    34d0:	40 e2       	ldi	r20, 0x20	; 32
    34d2:	51 e4       	ldi	r21, 0x41	; 65
    34d4:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <__mulsf3>
    34d8:	6f 8b       	std	Y+23, r22	; 0x17
    34da:	78 8f       	std	Y+24, r23	; 0x18
    34dc:	89 8f       	std	Y+25, r24	; 0x19
    34de:	9a 8f       	std	Y+26, r25	; 0x1a
    34e0:	0e 94 36 1c 	call	0x386c	; 0x386c <__fixsfsi>
        *buffer++ = digit + '0';
    34e4:	20 e3       	ldi	r18, 0x30	; 48
    34e6:	26 0f       	add	r18, r22
    34e8:	d8 01       	movw	r26, r16
    34ea:	2d 93       	st	X+, r18
    34ec:	8d 01       	movw	r16, r26
        value = value * 10.0 - digit;
    34ee:	07 2e       	mov	r0, r23
    34f0:	00 0c       	add	r0, r0
    34f2:	88 0b       	sbc	r24, r24
    34f4:	99 0b       	sbc	r25, r25
    34f6:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <__floatsisf>
    34fa:	9b 01       	movw	r18, r22
    34fc:	ac 01       	movw	r20, r24
    34fe:	6f 89       	ldd	r22, Y+23	; 0x17
    3500:	78 8d       	ldd	r23, Y+24	; 0x18
    3502:	89 8d       	ldd	r24, Y+25	; 0x19
    3504:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3506:	0e 94 52 1b 	call	0x36a4	; 0x36a4 <__subsf3>
    value = value * 10.0 - digit;
    --exponent;

    *buffer++ = '.';

    for (int i = 0; i < width; i++) {
    350a:	0e 15       	cp	r16, r14
    350c:	1f 05       	cpc	r17, r15
    350e:	f1 f6       	brne	.-68     	; 0x34cc <vDisplayWriteStringAtPos+0x5ba>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
    }

    *buffer++ = 'e';
    3510:	25 e6       	ldi	r18, 0x65	; 101
    3512:	f3 01       	movw	r30, r6
    3514:	26 83       	std	Z+6, r18	; 0x06
    3516:	b3 01       	movw	r22, r6
    3518:	69 5f       	subi	r22, 0xF9	; 249
    351a:	7f 4f       	sbci	r23, 0xFF	; 255
    351c:	4a e0       	ldi	r20, 0x0A	; 10
    351e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3520:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3522:	0e 94 a8 1d 	call	0x3b50	; 0x3b50 <__itoa_ncheck>
    3526:	94 01       	movw	r18, r8
    3528:	f4 01       	movw	r30, r8
    352a:	ec 55       	subi	r30, 0x5C	; 92
    352c:	f3 4d       	sbci	r31, 0xD3	; 211
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    352e:	48 eb       	ldi	r20, 0xB8	; 184
    3530:	5c e2       	ldi	r21, 0x2C	; 44
    3532:	80 e0       	ldi	r24, 0x00	; 0
    3534:	90 e0       	ldi	r25, 0x00	; 0
    3536:	05 c0       	rjmp	.+10     	; 0x3542 <vDisplayWriteStringAtPos+0x630>

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    3538:	da 01       	movw	r26, r20
    353a:	6d 91       	ld	r22, X+
    353c:	ad 01       	movw	r20, r26
    353e:	61 93       	st	Z+, r22
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    3540:	01 96       	adiw	r24, 0x01	; 1
    3542:	d6 01       	movw	r26, r12
    3544:	0d 90       	ld	r0, X+
    3546:	00 20       	and	r0, r0
    3548:	e9 f7       	brne	.-6      	; 0x3544 <vDisplayWriteStringAtPos+0x632>
    354a:	11 97       	sbiw	r26, 0x01	; 1
    354c:	a8 5b       	subi	r26, 0xB8	; 184
    354e:	bc 42       	sbci	r27, 0x2C	; 44
    3550:	8a 17       	cp	r24, r26
    3552:	9b 07       	cpc	r25, r27
    3554:	88 f3       	brcs	.-30     	; 0x3538 <vDisplayWriteStringAtPos+0x626>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    3556:	4d 01       	movw	r8, r26
    3558:	82 0e       	add	r8, r18
    355a:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    355c:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    355e:	d2 01       	movw	r26, r4
    3560:	11 c0       	rjmp	.+34     	; 0x3584 <vDisplayWriteStringAtPos+0x672>
				break;
			}
		}
		else {
			str[length] = ch;
			if(str[length] == '\n') {
    3562:	8a 30       	cpi	r24, 0x0A	; 10
    3564:	29 f0       	breq	.+10     	; 0x3570 <vDisplayWriteStringAtPos+0x65e>
				length += strlen(buffer);
				break;
			}
		}
		else {
			str[length] = ch;
    3566:	f4 01       	movw	r30, r8
    3568:	ec 55       	subi	r30, 0x5C	; 92
    356a:	f3 4d       	sbci	r31, 0xD3	; 211
    356c:	80 83       	st	Z, r24
    356e:	04 c0       	rjmp	.+8      	; 0x3578 <vDisplayWriteStringAtPos+0x666>
			if(str[length] == '\n') {
				str[length] = '\0';				
    3570:	f4 01       	movw	r30, r8
    3572:	ec 55       	subi	r30, 0x5C	; 92
    3574:	f3 4d       	sbci	r31, 0xD3	; 211
    3576:	10 82       	st	Z, r1
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    3578:	11 96       	adiw	r26, 0x01	; 1
		else {
			str[length] = ch;
			if(str[length] == '\n') {
				str[length] = '\0';				
			}
			length++;
    357a:	ef ef       	ldi	r30, 0xFF	; 255
    357c:	8e 1a       	sub	r8, r30
    357e:	9e 0a       	sbc	r9, r30
    3580:	01 c0       	rjmp	.+2      	; 0x3584 <vDisplayWriteStringAtPos+0x672>
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3582:	d2 01       	movw	r26, r4
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    3584:	8c 91       	ld	r24, X
    3586:	81 11       	cpse	r24, r1
    3588:	01 cd       	rjmp	.-1534   	; 0x2f8c <vDisplayWriteStringAtPos+0x7a>
				str[length] = '\0';				
			}
			length++;
		}
	}
	if(length + pos >= 20) {
    358a:	8d a9       	ldd	r24, Y+53	; 0x35
    358c:	9e a9       	ldd	r25, Y+54	; 0x36
    358e:	88 0d       	add	r24, r8
    3590:	99 1d       	adc	r25, r9
    3592:	44 97       	sbiw	r24, 0x14	; 20
    3594:	3c f0       	brlt	.+14     	; 0x35a4 <vDisplayWriteStringAtPos+0x692>
		length = 20-pos;
    3596:	84 e1       	ldi	r24, 0x14	; 20
    3598:	90 e0       	ldi	r25, 0x00	; 0
    359a:	4c 01       	movw	r8, r24
    359c:	2d a9       	ldd	r18, Y+53	; 0x35
    359e:	3e a9       	ldd	r19, Y+54	; 0x36
    35a0:	82 1a       	sub	r8, r18
    35a2:	93 0a       	sbc	r9, r19
    35a4:	fe 01       	movw	r30, r28
    35a6:	33 96       	adiw	r30, 0x03	; 3
    35a8:	ce 01       	movw	r24, r28
    35aa:	47 96       	adiw	r24, 0x17	; 23
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    35ac:	df 01       	movw	r26, r30
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
    35ae:	1d 92       	st	X+, r1
	}
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
    35b0:	a8 17       	cp	r26, r24
    35b2:	b9 07       	cpc	r27, r25
    35b4:	e1 f7       	brne	.-8      	; 0x35ae <vDisplayWriteStringAtPos+0x69c>
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
    35b6:	3b 8d       	ldd	r19, Y+27	; 0x1b
    35b8:	39 83       	std	Y+1, r19	; 0x01
	newLine.displayPos = pos;
    35ba:	8d a9       	ldd	r24, Y+53	; 0x35
    35bc:	8a 83       	std	Y+2, r24	; 0x02
	for(int i = 0; i < length;i++) {
    35be:	18 14       	cp	r1, r8
    35c0:	19 04       	cpc	r1, r9
    35c2:	5c f4       	brge	.+22     	; 0x35da <vDisplayWriteStringAtPos+0x6c8>
    35c4:	ce 01       	movw	r24, r28
    35c6:	88 0d       	add	r24, r8
    35c8:	99 1d       	adc	r25, r9
    35ca:	03 96       	adiw	r24, 0x03	; 3
		newLine.displayBuffer[i] = str[i];
    35cc:	d5 01       	movw	r26, r10
    35ce:	2d 91       	ld	r18, X+
    35d0:	5d 01       	movw	r10, r26
    35d2:	21 93       	st	Z+, r18
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
	newLine.displayPos = pos;
	for(int i = 0; i < length;i++) {
    35d4:	8e 17       	cp	r24, r30
    35d6:	9f 07       	cpc	r25, r31
    35d8:	c9 f7       	brne	.-14     	; 0x35cc <vDisplayWriteStringAtPos+0x6ba>
		newLine.displayBuffer[i] = str[i];
	}	
	xQueueSend(displayLineQueue, (void *) &newLine, portMAX_DELAY);
    35da:	00 e0       	ldi	r16, 0x00	; 0
    35dc:	2f ef       	ldi	r18, 0xFF	; 255
    35de:	3f ef       	ldi	r19, 0xFF	; 255
    35e0:	a9 01       	movw	r20, r18
    35e2:	be 01       	movw	r22, r28
    35e4:	6f 5f       	subi	r22, 0xFF	; 255
    35e6:	7f 4f       	sbci	r23, 0xFF	; 255
    35e8:	80 91 d1 2c 	lds	r24, 0x2CD1	; 0x802cd1 <displayLineQueue>
    35ec:	90 91 d2 2c 	lds	r25, 0x2CD2	; 0x802cd2 <displayLineQueue+0x1>
    35f0:	0e 94 1a 07 	call	0xe34	; 0xe34 <xQueueGenericSend>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    35f4:	1b c0       	rjmp	.+54     	; 0x362c <vDisplayWriteStringAtPos+0x71a>
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    35f6:	2d ec       	ldi	r18, 0xCD	; 205
    35f8:	3c ec       	ldi	r19, 0xCC	; 204
    35fa:	4c ec       	ldi	r20, 0xCC	; 204
    35fc:	5d e3       	ldi	r21, 0x3D	; 61
    35fe:	6f 89       	ldd	r22, Y+23	; 0x17
    3600:	78 8d       	ldd	r23, Y+24	; 0x18
    3602:	89 8d       	ldd	r24, Y+25	; 0x19
    3604:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3606:	0e 94 bf 1b 	call	0x377e	; 0x377e <__cmpsf2>
    360a:	88 23       	and	r24, r24
    360c:	0c f4       	brge	.+2      	; 0x3610 <vDisplayWriteStringAtPos+0x6fe>
    360e:	d6 cd       	rjmp	.-1108   	; 0x31bc <vDisplayWriteStringAtPos+0x2aa>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    3610:	80 e0       	ldi	r24, 0x00	; 0
    3612:	90 e0       	ldi	r25, 0x00	; 0
    3614:	26 ce       	rjmp	.-948    	; 0x3262 <vDisplayWriteStringAtPos+0x350>
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    3616:	20 e3       	ldi	r18, 0x30	; 48
    3618:	ec 8d       	ldd	r30, Y+28	; 0x1c
    361a:	fd 8d       	ldd	r31, Y+29	; 0x1d
    361c:	20 83       	st	Z, r18

    *buffer++ = '.';
    361e:	7f 01       	movw	r14, r30
    3620:	32 e0       	ldi	r19, 0x02	; 2
    3622:	e3 0e       	add	r14, r19
    3624:	f1 1c       	adc	r15, r1
    3626:	8e e2       	ldi	r24, 0x2E	; 46
    3628:	81 83       	std	Z+1, r24	; 0x01
    362a:	46 ce       	rjmp	.-884    	; 0x32b8 <vDisplayWriteStringAtPos+0x3a6>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    362c:	6d 96       	adiw	r28, 0x1d	; 29
    362e:	cd bf       	out	0x3d, r28	; 61
    3630:	de bf       	out	0x3e, r29	; 62
    3632:	df 91       	pop	r29
    3634:	cf 91       	pop	r28
    3636:	1f 91       	pop	r17
    3638:	0f 91       	pop	r16
    363a:	ff 90       	pop	r15
    363c:	ef 90       	pop	r14
    363e:	df 90       	pop	r13
    3640:	cf 90       	pop	r12
    3642:	bf 90       	pop	r11
    3644:	af 90       	pop	r10
    3646:	9f 90       	pop	r9
    3648:	8f 90       	pop	r8
    364a:	7f 90       	pop	r7
    364c:	6f 90       	pop	r6
    364e:	5f 90       	pop	r5
    3650:	4f 90       	pop	r4
    3652:	3f 90       	pop	r3
    3654:	2f 90       	pop	r2
    3656:	08 95       	ret

00003658 <getResetReason>:
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
	 // software reset ?
	 if( RST.STATUS & RST_SRF_bm )
    3658:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    365c:	85 ff       	sbrs	r24, 5
    365e:	05 c0       	rjmp	.+10     	; 0x366a <getResetReason+0x12>
	 {
		 // reset this bit
		 RST.STATUS = RST_SRF_bm;
    3660:	80 e2       	ldi	r24, 0x20	; 32
    3662:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_SOFTWARERESET;
    3666:	81 e0       	ldi	r24, 0x01	; 1
    3668:	08 95       	ret
	 }
	 // power on reset ?
	 else if( RST.STATUS & RST_PORF_bm)
    366a:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    366e:	80 ff       	sbrs	r24, 0
    3670:	05 c0       	rjmp	.+10     	; 0x367c <getResetReason+0x24>
	 {
		 // reset this bit
		 RST.STATUS = RST_PORF_bm;
    3672:	81 e0       	ldi	r24, 0x01	; 1
    3674:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_POWERONRESET;
    3678:	82 e0       	ldi	r24, 0x02	; 2
    367a:	08 95       	ret
	 }
	 // debugger reset ?
	 else if( RST.STATUS & RST_PDIRF_bm)
    367c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3680:	84 ff       	sbrs	r24, 4
    3682:	05 c0       	rjmp	.+10     	; 0x368e <getResetReason+0x36>
	 {
		 // reset this bit
		 RST.STATUS = RST_PDIRF_bm;
    3684:	80 e1       	ldi	r24, 0x10	; 16
    3686:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_DEBUGGERRESET;
    368a:	83 e0       	ldi	r24, 0x03	; 3
    368c:	08 95       	ret
	 }
	 // external reset ?
	 else if( RST.STATUS & RST_EXTRF_bm)
    368e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3692:	81 ff       	sbrs	r24, 1
    3694:	05 c0       	rjmp	.+10     	; 0x36a0 <getResetReason+0x48>
	 {
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
    3696:	82 e0       	ldi	r24, 0x02	; 2
    3698:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_EXTERNALRESET;
    369c:	84 e0       	ldi	r24, 0x04	; 4
    369e:	08 95       	ret
 */ 
 #include "avr_compiler.h"
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
    36a0:	82 e0       	ldi	r24, 0x02	; 2
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
		 returnValue = RESETREASON_EXTERNALRESET;
	 }
	 return returnValue;
    36a2:	08 95       	ret

000036a4 <__subsf3>:
    36a4:	50 58       	subi	r21, 0x80	; 128

000036a6 <__addsf3>:
    36a6:	bb 27       	eor	r27, r27
    36a8:	aa 27       	eor	r26, r26
    36aa:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <__addsf3x>
    36ae:	0c 94 e4 1c 	jmp	0x39c8	; 0x39c8 <__fp_round>
    36b2:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <__fp_pscA>
    36b6:	38 f0       	brcs	.+14     	; 0x36c6 <__addsf3+0x20>
    36b8:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__fp_pscB>
    36bc:	20 f0       	brcs	.+8      	; 0x36c6 <__addsf3+0x20>
    36be:	39 f4       	brne	.+14     	; 0x36ce <__addsf3+0x28>
    36c0:	9f 3f       	cpi	r25, 0xFF	; 255
    36c2:	19 f4       	brne	.+6      	; 0x36ca <__addsf3+0x24>
    36c4:	26 f4       	brtc	.+8      	; 0x36ce <__addsf3+0x28>
    36c6:	0c 94 d3 1c 	jmp	0x39a6	; 0x39a6 <__fp_nan>
    36ca:	0e f4       	brtc	.+2      	; 0x36ce <__addsf3+0x28>
    36cc:	e0 95       	com	r30
    36ce:	e7 fb       	bst	r30, 7
    36d0:	0c 94 cd 1c 	jmp	0x399a	; 0x399a <__fp_inf>

000036d4 <__addsf3x>:
    36d4:	e9 2f       	mov	r30, r25
    36d6:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <__fp_split3>
    36da:	58 f3       	brcs	.-42     	; 0x36b2 <__addsf3+0xc>
    36dc:	ba 17       	cp	r27, r26
    36de:	62 07       	cpc	r22, r18
    36e0:	73 07       	cpc	r23, r19
    36e2:	84 07       	cpc	r24, r20
    36e4:	95 07       	cpc	r25, r21
    36e6:	20 f0       	brcs	.+8      	; 0x36f0 <__addsf3x+0x1c>
    36e8:	79 f4       	brne	.+30     	; 0x3708 <__addsf3x+0x34>
    36ea:	a6 f5       	brtc	.+104    	; 0x3754 <__addsf3x+0x80>
    36ec:	0c 94 17 1d 	jmp	0x3a2e	; 0x3a2e <__fp_zero>
    36f0:	0e f4       	brtc	.+2      	; 0x36f4 <__addsf3x+0x20>
    36f2:	e0 95       	com	r30
    36f4:	0b 2e       	mov	r0, r27
    36f6:	ba 2f       	mov	r27, r26
    36f8:	a0 2d       	mov	r26, r0
    36fa:	0b 01       	movw	r0, r22
    36fc:	b9 01       	movw	r22, r18
    36fe:	90 01       	movw	r18, r0
    3700:	0c 01       	movw	r0, r24
    3702:	ca 01       	movw	r24, r20
    3704:	a0 01       	movw	r20, r0
    3706:	11 24       	eor	r1, r1
    3708:	ff 27       	eor	r31, r31
    370a:	59 1b       	sub	r21, r25
    370c:	99 f0       	breq	.+38     	; 0x3734 <__addsf3x+0x60>
    370e:	59 3f       	cpi	r21, 0xF9	; 249
    3710:	50 f4       	brcc	.+20     	; 0x3726 <__addsf3x+0x52>
    3712:	50 3e       	cpi	r21, 0xE0	; 224
    3714:	68 f1       	brcs	.+90     	; 0x3770 <__addsf3x+0x9c>
    3716:	1a 16       	cp	r1, r26
    3718:	f0 40       	sbci	r31, 0x00	; 0
    371a:	a2 2f       	mov	r26, r18
    371c:	23 2f       	mov	r18, r19
    371e:	34 2f       	mov	r19, r20
    3720:	44 27       	eor	r20, r20
    3722:	58 5f       	subi	r21, 0xF8	; 248
    3724:	f3 cf       	rjmp	.-26     	; 0x370c <__addsf3x+0x38>
    3726:	46 95       	lsr	r20
    3728:	37 95       	ror	r19
    372a:	27 95       	ror	r18
    372c:	a7 95       	ror	r26
    372e:	f0 40       	sbci	r31, 0x00	; 0
    3730:	53 95       	inc	r21
    3732:	c9 f7       	brne	.-14     	; 0x3726 <__addsf3x+0x52>
    3734:	7e f4       	brtc	.+30     	; 0x3754 <__addsf3x+0x80>
    3736:	1f 16       	cp	r1, r31
    3738:	ba 0b       	sbc	r27, r26
    373a:	62 0b       	sbc	r22, r18
    373c:	73 0b       	sbc	r23, r19
    373e:	84 0b       	sbc	r24, r20
    3740:	ba f0       	brmi	.+46     	; 0x3770 <__addsf3x+0x9c>
    3742:	91 50       	subi	r25, 0x01	; 1
    3744:	a1 f0       	breq	.+40     	; 0x376e <__addsf3x+0x9a>
    3746:	ff 0f       	add	r31, r31
    3748:	bb 1f       	adc	r27, r27
    374a:	66 1f       	adc	r22, r22
    374c:	77 1f       	adc	r23, r23
    374e:	88 1f       	adc	r24, r24
    3750:	c2 f7       	brpl	.-16     	; 0x3742 <__addsf3x+0x6e>
    3752:	0e c0       	rjmp	.+28     	; 0x3770 <__addsf3x+0x9c>
    3754:	ba 0f       	add	r27, r26
    3756:	62 1f       	adc	r22, r18
    3758:	73 1f       	adc	r23, r19
    375a:	84 1f       	adc	r24, r20
    375c:	48 f4       	brcc	.+18     	; 0x3770 <__addsf3x+0x9c>
    375e:	87 95       	ror	r24
    3760:	77 95       	ror	r23
    3762:	67 95       	ror	r22
    3764:	b7 95       	ror	r27
    3766:	f7 95       	ror	r31
    3768:	9e 3f       	cpi	r25, 0xFE	; 254
    376a:	08 f0       	brcs	.+2      	; 0x376e <__addsf3x+0x9a>
    376c:	b0 cf       	rjmp	.-160    	; 0x36ce <__addsf3+0x28>
    376e:	93 95       	inc	r25
    3770:	88 0f       	add	r24, r24
    3772:	08 f0       	brcs	.+2      	; 0x3776 <__addsf3x+0xa2>
    3774:	99 27       	eor	r25, r25
    3776:	ee 0f       	add	r30, r30
    3778:	97 95       	ror	r25
    377a:	87 95       	ror	r24
    377c:	08 95       	ret

0000377e <__cmpsf2>:
    377e:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__fp_cmp>
    3782:	08 f4       	brcc	.+2      	; 0x3786 <__cmpsf2+0x8>
    3784:	81 e0       	ldi	r24, 0x01	; 1
    3786:	08 95       	ret

00003788 <__divsf3>:
    3788:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__divsf3x>
    378c:	0c 94 e4 1c 	jmp	0x39c8	; 0x39c8 <__fp_round>
    3790:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__fp_pscB>
    3794:	58 f0       	brcs	.+22     	; 0x37ac <__divsf3+0x24>
    3796:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <__fp_pscA>
    379a:	40 f0       	brcs	.+16     	; 0x37ac <__divsf3+0x24>
    379c:	29 f4       	brne	.+10     	; 0x37a8 <__divsf3+0x20>
    379e:	5f 3f       	cpi	r21, 0xFF	; 255
    37a0:	29 f0       	breq	.+10     	; 0x37ac <__divsf3+0x24>
    37a2:	0c 94 cd 1c 	jmp	0x399a	; 0x399a <__fp_inf>
    37a6:	51 11       	cpse	r21, r1
    37a8:	0c 94 18 1d 	jmp	0x3a30	; 0x3a30 <__fp_szero>
    37ac:	0c 94 d3 1c 	jmp	0x39a6	; 0x39a6 <__fp_nan>

000037b0 <__divsf3x>:
    37b0:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <__fp_split3>
    37b4:	68 f3       	brcs	.-38     	; 0x3790 <__divsf3+0x8>

000037b6 <__divsf3_pse>:
    37b6:	99 23       	and	r25, r25
    37b8:	b1 f3       	breq	.-20     	; 0x37a6 <__divsf3+0x1e>
    37ba:	55 23       	and	r21, r21
    37bc:	91 f3       	breq	.-28     	; 0x37a2 <__divsf3+0x1a>
    37be:	95 1b       	sub	r25, r21
    37c0:	55 0b       	sbc	r21, r21
    37c2:	bb 27       	eor	r27, r27
    37c4:	aa 27       	eor	r26, r26
    37c6:	62 17       	cp	r22, r18
    37c8:	73 07       	cpc	r23, r19
    37ca:	84 07       	cpc	r24, r20
    37cc:	38 f0       	brcs	.+14     	; 0x37dc <__divsf3_pse+0x26>
    37ce:	9f 5f       	subi	r25, 0xFF	; 255
    37d0:	5f 4f       	sbci	r21, 0xFF	; 255
    37d2:	22 0f       	add	r18, r18
    37d4:	33 1f       	adc	r19, r19
    37d6:	44 1f       	adc	r20, r20
    37d8:	aa 1f       	adc	r26, r26
    37da:	a9 f3       	breq	.-22     	; 0x37c6 <__divsf3_pse+0x10>
    37dc:	35 d0       	rcall	.+106    	; 0x3848 <__divsf3_pse+0x92>
    37de:	0e 2e       	mov	r0, r30
    37e0:	3a f0       	brmi	.+14     	; 0x37f0 <__divsf3_pse+0x3a>
    37e2:	e0 e8       	ldi	r30, 0x80	; 128
    37e4:	32 d0       	rcall	.+100    	; 0x384a <__divsf3_pse+0x94>
    37e6:	91 50       	subi	r25, 0x01	; 1
    37e8:	50 40       	sbci	r21, 0x00	; 0
    37ea:	e6 95       	lsr	r30
    37ec:	00 1c       	adc	r0, r0
    37ee:	ca f7       	brpl	.-14     	; 0x37e2 <__divsf3_pse+0x2c>
    37f0:	2b d0       	rcall	.+86     	; 0x3848 <__divsf3_pse+0x92>
    37f2:	fe 2f       	mov	r31, r30
    37f4:	29 d0       	rcall	.+82     	; 0x3848 <__divsf3_pse+0x92>
    37f6:	66 0f       	add	r22, r22
    37f8:	77 1f       	adc	r23, r23
    37fa:	88 1f       	adc	r24, r24
    37fc:	bb 1f       	adc	r27, r27
    37fe:	26 17       	cp	r18, r22
    3800:	37 07       	cpc	r19, r23
    3802:	48 07       	cpc	r20, r24
    3804:	ab 07       	cpc	r26, r27
    3806:	b0 e8       	ldi	r27, 0x80	; 128
    3808:	09 f0       	breq	.+2      	; 0x380c <__divsf3_pse+0x56>
    380a:	bb 0b       	sbc	r27, r27
    380c:	80 2d       	mov	r24, r0
    380e:	bf 01       	movw	r22, r30
    3810:	ff 27       	eor	r31, r31
    3812:	93 58       	subi	r25, 0x83	; 131
    3814:	5f 4f       	sbci	r21, 0xFF	; 255
    3816:	3a f0       	brmi	.+14     	; 0x3826 <__divsf3_pse+0x70>
    3818:	9e 3f       	cpi	r25, 0xFE	; 254
    381a:	51 05       	cpc	r21, r1
    381c:	78 f0       	brcs	.+30     	; 0x383c <__divsf3_pse+0x86>
    381e:	0c 94 cd 1c 	jmp	0x399a	; 0x399a <__fp_inf>
    3822:	0c 94 18 1d 	jmp	0x3a30	; 0x3a30 <__fp_szero>
    3826:	5f 3f       	cpi	r21, 0xFF	; 255
    3828:	e4 f3       	brlt	.-8      	; 0x3822 <__divsf3_pse+0x6c>
    382a:	98 3e       	cpi	r25, 0xE8	; 232
    382c:	d4 f3       	brlt	.-12     	; 0x3822 <__divsf3_pse+0x6c>
    382e:	86 95       	lsr	r24
    3830:	77 95       	ror	r23
    3832:	67 95       	ror	r22
    3834:	b7 95       	ror	r27
    3836:	f7 95       	ror	r31
    3838:	9f 5f       	subi	r25, 0xFF	; 255
    383a:	c9 f7       	brne	.-14     	; 0x382e <__divsf3_pse+0x78>
    383c:	88 0f       	add	r24, r24
    383e:	91 1d       	adc	r25, r1
    3840:	96 95       	lsr	r25
    3842:	87 95       	ror	r24
    3844:	97 f9       	bld	r25, 7
    3846:	08 95       	ret
    3848:	e1 e0       	ldi	r30, 0x01	; 1
    384a:	66 0f       	add	r22, r22
    384c:	77 1f       	adc	r23, r23
    384e:	88 1f       	adc	r24, r24
    3850:	bb 1f       	adc	r27, r27
    3852:	62 17       	cp	r22, r18
    3854:	73 07       	cpc	r23, r19
    3856:	84 07       	cpc	r24, r20
    3858:	ba 07       	cpc	r27, r26
    385a:	20 f0       	brcs	.+8      	; 0x3864 <__divsf3_pse+0xae>
    385c:	62 1b       	sub	r22, r18
    385e:	73 0b       	sbc	r23, r19
    3860:	84 0b       	sbc	r24, r20
    3862:	ba 0b       	sbc	r27, r26
    3864:	ee 1f       	adc	r30, r30
    3866:	88 f7       	brcc	.-30     	; 0x384a <__divsf3_pse+0x94>
    3868:	e0 95       	com	r30
    386a:	08 95       	ret

0000386c <__fixsfsi>:
    386c:	0e 94 3d 1c 	call	0x387a	; 0x387a <__fixunssfsi>
    3870:	68 94       	set
    3872:	b1 11       	cpse	r27, r1
    3874:	0c 94 18 1d 	jmp	0x3a30	; 0x3a30 <__fp_szero>
    3878:	08 95       	ret

0000387a <__fixunssfsi>:
    387a:	0e 94 fd 1c 	call	0x39fa	; 0x39fa <__fp_splitA>
    387e:	88 f0       	brcs	.+34     	; 0x38a2 <__fixunssfsi+0x28>
    3880:	9f 57       	subi	r25, 0x7F	; 127
    3882:	98 f0       	brcs	.+38     	; 0x38aa <__fixunssfsi+0x30>
    3884:	b9 2f       	mov	r27, r25
    3886:	99 27       	eor	r25, r25
    3888:	b7 51       	subi	r27, 0x17	; 23
    388a:	b0 f0       	brcs	.+44     	; 0x38b8 <__fixunssfsi+0x3e>
    388c:	e1 f0       	breq	.+56     	; 0x38c6 <__fixunssfsi+0x4c>
    388e:	66 0f       	add	r22, r22
    3890:	77 1f       	adc	r23, r23
    3892:	88 1f       	adc	r24, r24
    3894:	99 1f       	adc	r25, r25
    3896:	1a f0       	brmi	.+6      	; 0x389e <__fixunssfsi+0x24>
    3898:	ba 95       	dec	r27
    389a:	c9 f7       	brne	.-14     	; 0x388e <__fixunssfsi+0x14>
    389c:	14 c0       	rjmp	.+40     	; 0x38c6 <__fixunssfsi+0x4c>
    389e:	b1 30       	cpi	r27, 0x01	; 1
    38a0:	91 f0       	breq	.+36     	; 0x38c6 <__fixunssfsi+0x4c>
    38a2:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <__fp_zero>
    38a6:	b1 e0       	ldi	r27, 0x01	; 1
    38a8:	08 95       	ret
    38aa:	0c 94 17 1d 	jmp	0x3a2e	; 0x3a2e <__fp_zero>
    38ae:	67 2f       	mov	r22, r23
    38b0:	78 2f       	mov	r23, r24
    38b2:	88 27       	eor	r24, r24
    38b4:	b8 5f       	subi	r27, 0xF8	; 248
    38b6:	39 f0       	breq	.+14     	; 0x38c6 <__fixunssfsi+0x4c>
    38b8:	b9 3f       	cpi	r27, 0xF9	; 249
    38ba:	cc f3       	brlt	.-14     	; 0x38ae <__fixunssfsi+0x34>
    38bc:	86 95       	lsr	r24
    38be:	77 95       	ror	r23
    38c0:	67 95       	ror	r22
    38c2:	b3 95       	inc	r27
    38c4:	d9 f7       	brne	.-10     	; 0x38bc <__fixunssfsi+0x42>
    38c6:	3e f4       	brtc	.+14     	; 0x38d6 <__fixunssfsi+0x5c>
    38c8:	90 95       	com	r25
    38ca:	80 95       	com	r24
    38cc:	70 95       	com	r23
    38ce:	61 95       	neg	r22
    38d0:	7f 4f       	sbci	r23, 0xFF	; 255
    38d2:	8f 4f       	sbci	r24, 0xFF	; 255
    38d4:	9f 4f       	sbci	r25, 0xFF	; 255
    38d6:	08 95       	ret

000038d8 <__floatunsisf>:
    38d8:	e8 94       	clt
    38da:	09 c0       	rjmp	.+18     	; 0x38ee <__floatsisf+0x12>

000038dc <__floatsisf>:
    38dc:	97 fb       	bst	r25, 7
    38de:	3e f4       	brtc	.+14     	; 0x38ee <__floatsisf+0x12>
    38e0:	90 95       	com	r25
    38e2:	80 95       	com	r24
    38e4:	70 95       	com	r23
    38e6:	61 95       	neg	r22
    38e8:	7f 4f       	sbci	r23, 0xFF	; 255
    38ea:	8f 4f       	sbci	r24, 0xFF	; 255
    38ec:	9f 4f       	sbci	r25, 0xFF	; 255
    38ee:	99 23       	and	r25, r25
    38f0:	a9 f0       	breq	.+42     	; 0x391c <__floatsisf+0x40>
    38f2:	f9 2f       	mov	r31, r25
    38f4:	96 e9       	ldi	r25, 0x96	; 150
    38f6:	bb 27       	eor	r27, r27
    38f8:	93 95       	inc	r25
    38fa:	f6 95       	lsr	r31
    38fc:	87 95       	ror	r24
    38fe:	77 95       	ror	r23
    3900:	67 95       	ror	r22
    3902:	b7 95       	ror	r27
    3904:	f1 11       	cpse	r31, r1
    3906:	f8 cf       	rjmp	.-16     	; 0x38f8 <__floatsisf+0x1c>
    3908:	fa f4       	brpl	.+62     	; 0x3948 <__floatsisf+0x6c>
    390a:	bb 0f       	add	r27, r27
    390c:	11 f4       	brne	.+4      	; 0x3912 <__floatsisf+0x36>
    390e:	60 ff       	sbrs	r22, 0
    3910:	1b c0       	rjmp	.+54     	; 0x3948 <__floatsisf+0x6c>
    3912:	6f 5f       	subi	r22, 0xFF	; 255
    3914:	7f 4f       	sbci	r23, 0xFF	; 255
    3916:	8f 4f       	sbci	r24, 0xFF	; 255
    3918:	9f 4f       	sbci	r25, 0xFF	; 255
    391a:	16 c0       	rjmp	.+44     	; 0x3948 <__floatsisf+0x6c>
    391c:	88 23       	and	r24, r24
    391e:	11 f0       	breq	.+4      	; 0x3924 <__floatsisf+0x48>
    3920:	96 e9       	ldi	r25, 0x96	; 150
    3922:	11 c0       	rjmp	.+34     	; 0x3946 <__floatsisf+0x6a>
    3924:	77 23       	and	r23, r23
    3926:	21 f0       	breq	.+8      	; 0x3930 <__floatsisf+0x54>
    3928:	9e e8       	ldi	r25, 0x8E	; 142
    392a:	87 2f       	mov	r24, r23
    392c:	76 2f       	mov	r23, r22
    392e:	05 c0       	rjmp	.+10     	; 0x393a <__floatsisf+0x5e>
    3930:	66 23       	and	r22, r22
    3932:	71 f0       	breq	.+28     	; 0x3950 <__floatsisf+0x74>
    3934:	96 e8       	ldi	r25, 0x86	; 134
    3936:	86 2f       	mov	r24, r22
    3938:	70 e0       	ldi	r23, 0x00	; 0
    393a:	60 e0       	ldi	r22, 0x00	; 0
    393c:	2a f0       	brmi	.+10     	; 0x3948 <__floatsisf+0x6c>
    393e:	9a 95       	dec	r25
    3940:	66 0f       	add	r22, r22
    3942:	77 1f       	adc	r23, r23
    3944:	88 1f       	adc	r24, r24
    3946:	da f7       	brpl	.-10     	; 0x393e <__floatsisf+0x62>
    3948:	88 0f       	add	r24, r24
    394a:	96 95       	lsr	r25
    394c:	87 95       	ror	r24
    394e:	97 f9       	bld	r25, 7
    3950:	08 95       	ret

00003952 <__fp_cmp>:
    3952:	99 0f       	add	r25, r25
    3954:	00 08       	sbc	r0, r0
    3956:	55 0f       	add	r21, r21
    3958:	aa 0b       	sbc	r26, r26
    395a:	e0 e8       	ldi	r30, 0x80	; 128
    395c:	fe ef       	ldi	r31, 0xFE	; 254
    395e:	16 16       	cp	r1, r22
    3960:	17 06       	cpc	r1, r23
    3962:	e8 07       	cpc	r30, r24
    3964:	f9 07       	cpc	r31, r25
    3966:	c0 f0       	brcs	.+48     	; 0x3998 <__fp_cmp+0x46>
    3968:	12 16       	cp	r1, r18
    396a:	13 06       	cpc	r1, r19
    396c:	e4 07       	cpc	r30, r20
    396e:	f5 07       	cpc	r31, r21
    3970:	98 f0       	brcs	.+38     	; 0x3998 <__fp_cmp+0x46>
    3972:	62 1b       	sub	r22, r18
    3974:	73 0b       	sbc	r23, r19
    3976:	84 0b       	sbc	r24, r20
    3978:	95 0b       	sbc	r25, r21
    397a:	39 f4       	brne	.+14     	; 0x398a <__fp_cmp+0x38>
    397c:	0a 26       	eor	r0, r26
    397e:	61 f0       	breq	.+24     	; 0x3998 <__fp_cmp+0x46>
    3980:	23 2b       	or	r18, r19
    3982:	24 2b       	or	r18, r20
    3984:	25 2b       	or	r18, r21
    3986:	21 f4       	brne	.+8      	; 0x3990 <__fp_cmp+0x3e>
    3988:	08 95       	ret
    398a:	0a 26       	eor	r0, r26
    398c:	09 f4       	brne	.+2      	; 0x3990 <__fp_cmp+0x3e>
    398e:	a1 40       	sbci	r26, 0x01	; 1
    3990:	a6 95       	lsr	r26
    3992:	8f ef       	ldi	r24, 0xFF	; 255
    3994:	81 1d       	adc	r24, r1
    3996:	81 1d       	adc	r24, r1
    3998:	08 95       	ret

0000399a <__fp_inf>:
    399a:	97 f9       	bld	r25, 7
    399c:	9f 67       	ori	r25, 0x7F	; 127
    399e:	80 e8       	ldi	r24, 0x80	; 128
    39a0:	70 e0       	ldi	r23, 0x00	; 0
    39a2:	60 e0       	ldi	r22, 0x00	; 0
    39a4:	08 95       	ret

000039a6 <__fp_nan>:
    39a6:	9f ef       	ldi	r25, 0xFF	; 255
    39a8:	80 ec       	ldi	r24, 0xC0	; 192
    39aa:	08 95       	ret

000039ac <__fp_pscA>:
    39ac:	00 24       	eor	r0, r0
    39ae:	0a 94       	dec	r0
    39b0:	16 16       	cp	r1, r22
    39b2:	17 06       	cpc	r1, r23
    39b4:	18 06       	cpc	r1, r24
    39b6:	09 06       	cpc	r0, r25
    39b8:	08 95       	ret

000039ba <__fp_pscB>:
    39ba:	00 24       	eor	r0, r0
    39bc:	0a 94       	dec	r0
    39be:	12 16       	cp	r1, r18
    39c0:	13 06       	cpc	r1, r19
    39c2:	14 06       	cpc	r1, r20
    39c4:	05 06       	cpc	r0, r21
    39c6:	08 95       	ret

000039c8 <__fp_round>:
    39c8:	09 2e       	mov	r0, r25
    39ca:	03 94       	inc	r0
    39cc:	00 0c       	add	r0, r0
    39ce:	11 f4       	brne	.+4      	; 0x39d4 <__fp_round+0xc>
    39d0:	88 23       	and	r24, r24
    39d2:	52 f0       	brmi	.+20     	; 0x39e8 <__fp_round+0x20>
    39d4:	bb 0f       	add	r27, r27
    39d6:	40 f4       	brcc	.+16     	; 0x39e8 <__fp_round+0x20>
    39d8:	bf 2b       	or	r27, r31
    39da:	11 f4       	brne	.+4      	; 0x39e0 <__fp_round+0x18>
    39dc:	60 ff       	sbrs	r22, 0
    39de:	04 c0       	rjmp	.+8      	; 0x39e8 <__fp_round+0x20>
    39e0:	6f 5f       	subi	r22, 0xFF	; 255
    39e2:	7f 4f       	sbci	r23, 0xFF	; 255
    39e4:	8f 4f       	sbci	r24, 0xFF	; 255
    39e6:	9f 4f       	sbci	r25, 0xFF	; 255
    39e8:	08 95       	ret

000039ea <__fp_split3>:
    39ea:	57 fd       	sbrc	r21, 7
    39ec:	90 58       	subi	r25, 0x80	; 128
    39ee:	44 0f       	add	r20, r20
    39f0:	55 1f       	adc	r21, r21
    39f2:	59 f0       	breq	.+22     	; 0x3a0a <__fp_splitA+0x10>
    39f4:	5f 3f       	cpi	r21, 0xFF	; 255
    39f6:	71 f0       	breq	.+28     	; 0x3a14 <__fp_splitA+0x1a>
    39f8:	47 95       	ror	r20

000039fa <__fp_splitA>:
    39fa:	88 0f       	add	r24, r24
    39fc:	97 fb       	bst	r25, 7
    39fe:	99 1f       	adc	r25, r25
    3a00:	61 f0       	breq	.+24     	; 0x3a1a <__fp_splitA+0x20>
    3a02:	9f 3f       	cpi	r25, 0xFF	; 255
    3a04:	79 f0       	breq	.+30     	; 0x3a24 <__fp_splitA+0x2a>
    3a06:	87 95       	ror	r24
    3a08:	08 95       	ret
    3a0a:	12 16       	cp	r1, r18
    3a0c:	13 06       	cpc	r1, r19
    3a0e:	14 06       	cpc	r1, r20
    3a10:	55 1f       	adc	r21, r21
    3a12:	f2 cf       	rjmp	.-28     	; 0x39f8 <__fp_split3+0xe>
    3a14:	46 95       	lsr	r20
    3a16:	f1 df       	rcall	.-30     	; 0x39fa <__fp_splitA>
    3a18:	08 c0       	rjmp	.+16     	; 0x3a2a <__fp_splitA+0x30>
    3a1a:	16 16       	cp	r1, r22
    3a1c:	17 06       	cpc	r1, r23
    3a1e:	18 06       	cpc	r1, r24
    3a20:	99 1f       	adc	r25, r25
    3a22:	f1 cf       	rjmp	.-30     	; 0x3a06 <__fp_splitA+0xc>
    3a24:	86 95       	lsr	r24
    3a26:	71 05       	cpc	r23, r1
    3a28:	61 05       	cpc	r22, r1
    3a2a:	08 94       	sec
    3a2c:	08 95       	ret

00003a2e <__fp_zero>:
    3a2e:	e8 94       	clt

00003a30 <__fp_szero>:
    3a30:	bb 27       	eor	r27, r27
    3a32:	66 27       	eor	r22, r22
    3a34:	77 27       	eor	r23, r23
    3a36:	cb 01       	movw	r24, r22
    3a38:	97 f9       	bld	r25, 7
    3a3a:	08 95       	ret

00003a3c <__gesf2>:
    3a3c:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__fp_cmp>
    3a40:	08 f4       	brcc	.+2      	; 0x3a44 <__gesf2+0x8>
    3a42:	8f ef       	ldi	r24, 0xFF	; 255
    3a44:	08 95       	ret

00003a46 <__mulsf3>:
    3a46:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <__mulsf3x>
    3a4a:	0c 94 e4 1c 	jmp	0x39c8	; 0x39c8 <__fp_round>
    3a4e:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <__fp_pscA>
    3a52:	38 f0       	brcs	.+14     	; 0x3a62 <__mulsf3+0x1c>
    3a54:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__fp_pscB>
    3a58:	20 f0       	brcs	.+8      	; 0x3a62 <__mulsf3+0x1c>
    3a5a:	95 23       	and	r25, r21
    3a5c:	11 f0       	breq	.+4      	; 0x3a62 <__mulsf3+0x1c>
    3a5e:	0c 94 cd 1c 	jmp	0x399a	; 0x399a <__fp_inf>
    3a62:	0c 94 d3 1c 	jmp	0x39a6	; 0x39a6 <__fp_nan>
    3a66:	11 24       	eor	r1, r1
    3a68:	0c 94 18 1d 	jmp	0x3a30	; 0x3a30 <__fp_szero>

00003a6c <__mulsf3x>:
    3a6c:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <__fp_split3>
    3a70:	70 f3       	brcs	.-36     	; 0x3a4e <__mulsf3+0x8>

00003a72 <__mulsf3_pse>:
    3a72:	95 9f       	mul	r25, r21
    3a74:	c1 f3       	breq	.-16     	; 0x3a66 <__mulsf3+0x20>
    3a76:	95 0f       	add	r25, r21
    3a78:	50 e0       	ldi	r21, 0x00	; 0
    3a7a:	55 1f       	adc	r21, r21
    3a7c:	62 9f       	mul	r22, r18
    3a7e:	f0 01       	movw	r30, r0
    3a80:	72 9f       	mul	r23, r18
    3a82:	bb 27       	eor	r27, r27
    3a84:	f0 0d       	add	r31, r0
    3a86:	b1 1d       	adc	r27, r1
    3a88:	63 9f       	mul	r22, r19
    3a8a:	aa 27       	eor	r26, r26
    3a8c:	f0 0d       	add	r31, r0
    3a8e:	b1 1d       	adc	r27, r1
    3a90:	aa 1f       	adc	r26, r26
    3a92:	64 9f       	mul	r22, r20
    3a94:	66 27       	eor	r22, r22
    3a96:	b0 0d       	add	r27, r0
    3a98:	a1 1d       	adc	r26, r1
    3a9a:	66 1f       	adc	r22, r22
    3a9c:	82 9f       	mul	r24, r18
    3a9e:	22 27       	eor	r18, r18
    3aa0:	b0 0d       	add	r27, r0
    3aa2:	a1 1d       	adc	r26, r1
    3aa4:	62 1f       	adc	r22, r18
    3aa6:	73 9f       	mul	r23, r19
    3aa8:	b0 0d       	add	r27, r0
    3aaa:	a1 1d       	adc	r26, r1
    3aac:	62 1f       	adc	r22, r18
    3aae:	83 9f       	mul	r24, r19
    3ab0:	a0 0d       	add	r26, r0
    3ab2:	61 1d       	adc	r22, r1
    3ab4:	22 1f       	adc	r18, r18
    3ab6:	74 9f       	mul	r23, r20
    3ab8:	33 27       	eor	r19, r19
    3aba:	a0 0d       	add	r26, r0
    3abc:	61 1d       	adc	r22, r1
    3abe:	23 1f       	adc	r18, r19
    3ac0:	84 9f       	mul	r24, r20
    3ac2:	60 0d       	add	r22, r0
    3ac4:	21 1d       	adc	r18, r1
    3ac6:	82 2f       	mov	r24, r18
    3ac8:	76 2f       	mov	r23, r22
    3aca:	6a 2f       	mov	r22, r26
    3acc:	11 24       	eor	r1, r1
    3ace:	9f 57       	subi	r25, 0x7F	; 127
    3ad0:	50 40       	sbci	r21, 0x00	; 0
    3ad2:	9a f0       	brmi	.+38     	; 0x3afa <__mulsf3_pse+0x88>
    3ad4:	f1 f0       	breq	.+60     	; 0x3b12 <__mulsf3_pse+0xa0>
    3ad6:	88 23       	and	r24, r24
    3ad8:	4a f0       	brmi	.+18     	; 0x3aec <__mulsf3_pse+0x7a>
    3ada:	ee 0f       	add	r30, r30
    3adc:	ff 1f       	adc	r31, r31
    3ade:	bb 1f       	adc	r27, r27
    3ae0:	66 1f       	adc	r22, r22
    3ae2:	77 1f       	adc	r23, r23
    3ae4:	88 1f       	adc	r24, r24
    3ae6:	91 50       	subi	r25, 0x01	; 1
    3ae8:	50 40       	sbci	r21, 0x00	; 0
    3aea:	a9 f7       	brne	.-22     	; 0x3ad6 <__mulsf3_pse+0x64>
    3aec:	9e 3f       	cpi	r25, 0xFE	; 254
    3aee:	51 05       	cpc	r21, r1
    3af0:	80 f0       	brcs	.+32     	; 0x3b12 <__mulsf3_pse+0xa0>
    3af2:	0c 94 cd 1c 	jmp	0x399a	; 0x399a <__fp_inf>
    3af6:	0c 94 18 1d 	jmp	0x3a30	; 0x3a30 <__fp_szero>
    3afa:	5f 3f       	cpi	r21, 0xFF	; 255
    3afc:	e4 f3       	brlt	.-8      	; 0x3af6 <__mulsf3_pse+0x84>
    3afe:	98 3e       	cpi	r25, 0xE8	; 232
    3b00:	d4 f3       	brlt	.-12     	; 0x3af6 <__mulsf3_pse+0x84>
    3b02:	86 95       	lsr	r24
    3b04:	77 95       	ror	r23
    3b06:	67 95       	ror	r22
    3b08:	b7 95       	ror	r27
    3b0a:	f7 95       	ror	r31
    3b0c:	e7 95       	ror	r30
    3b0e:	9f 5f       	subi	r25, 0xFF	; 255
    3b10:	c1 f7       	brne	.-16     	; 0x3b02 <__mulsf3_pse+0x90>
    3b12:	fe 2b       	or	r31, r30
    3b14:	88 0f       	add	r24, r24
    3b16:	91 1d       	adc	r25, r1
    3b18:	96 95       	lsr	r25
    3b1a:	87 95       	ror	r24
    3b1c:	97 f9       	bld	r25, 7
    3b1e:	08 95       	ret

00003b20 <__tablejump2__>:
    3b20:	ee 0f       	add	r30, r30
    3b22:	ff 1f       	adc	r31, r31
    3b24:	88 1f       	adc	r24, r24
    3b26:	8b bf       	out	0x3b, r24	; 59
    3b28:	07 90       	elpm	r0, Z+
    3b2a:	f6 91       	elpm	r31, Z
    3b2c:	e0 2d       	mov	r30, r0
    3b2e:	19 94       	eijmp

00003b30 <memcpy>:
    3b30:	fb 01       	movw	r30, r22
    3b32:	dc 01       	movw	r26, r24
    3b34:	02 c0       	rjmp	.+4      	; 0x3b3a <memcpy+0xa>
    3b36:	01 90       	ld	r0, Z+
    3b38:	0d 92       	st	X+, r0
    3b3a:	41 50       	subi	r20, 0x01	; 1
    3b3c:	50 40       	sbci	r21, 0x00	; 0
    3b3e:	d8 f7       	brcc	.-10     	; 0x3b36 <memcpy+0x6>
    3b40:	08 95       	ret

00003b42 <memset>:
    3b42:	dc 01       	movw	r26, r24
    3b44:	01 c0       	rjmp	.+2      	; 0x3b48 <memset+0x6>
    3b46:	6d 93       	st	X+, r22
    3b48:	41 50       	subi	r20, 0x01	; 1
    3b4a:	50 40       	sbci	r21, 0x00	; 0
    3b4c:	e0 f7       	brcc	.-8      	; 0x3b46 <memset+0x4>
    3b4e:	08 95       	ret

00003b50 <__itoa_ncheck>:
    3b50:	bb 27       	eor	r27, r27
    3b52:	4a 30       	cpi	r20, 0x0A	; 10
    3b54:	31 f4       	brne	.+12     	; 0x3b62 <__itoa_ncheck+0x12>
    3b56:	99 23       	and	r25, r25
    3b58:	22 f4       	brpl	.+8      	; 0x3b62 <__itoa_ncheck+0x12>
    3b5a:	bd e2       	ldi	r27, 0x2D	; 45
    3b5c:	90 95       	com	r25
    3b5e:	81 95       	neg	r24
    3b60:	9f 4f       	sbci	r25, 0xFF	; 255
    3b62:	0c 94 b4 1d 	jmp	0x3b68	; 0x3b68 <__utoa_common>

00003b66 <__utoa_ncheck>:
    3b66:	bb 27       	eor	r27, r27

00003b68 <__utoa_common>:
    3b68:	fb 01       	movw	r30, r22
    3b6a:	55 27       	eor	r21, r21
    3b6c:	aa 27       	eor	r26, r26
    3b6e:	88 0f       	add	r24, r24
    3b70:	99 1f       	adc	r25, r25
    3b72:	aa 1f       	adc	r26, r26
    3b74:	a4 17       	cp	r26, r20
    3b76:	10 f0       	brcs	.+4      	; 0x3b7c <__utoa_common+0x14>
    3b78:	a4 1b       	sub	r26, r20
    3b7a:	83 95       	inc	r24
    3b7c:	50 51       	subi	r21, 0x10	; 16
    3b7e:	b9 f7       	brne	.-18     	; 0x3b6e <__utoa_common+0x6>
    3b80:	a0 5d       	subi	r26, 0xD0	; 208
    3b82:	aa 33       	cpi	r26, 0x3A	; 58
    3b84:	08 f0       	brcs	.+2      	; 0x3b88 <__utoa_common+0x20>
    3b86:	a9 5d       	subi	r26, 0xD9	; 217
    3b88:	a1 93       	st	Z+, r26
    3b8a:	00 97       	sbiw	r24, 0x00	; 0
    3b8c:	79 f7       	brne	.-34     	; 0x3b6c <__utoa_common+0x4>
    3b8e:	b1 11       	cpse	r27, r1
    3b90:	b1 93       	st	Z+, r27
    3b92:	11 92       	st	Z+, r1
    3b94:	cb 01       	movw	r24, r22
    3b96:	0c 94 cd 1d 	jmp	0x3b9a	; 0x3b9a <strrev>

00003b9a <strrev>:
    3b9a:	dc 01       	movw	r26, r24
    3b9c:	fc 01       	movw	r30, r24
    3b9e:	67 2f       	mov	r22, r23
    3ba0:	71 91       	ld	r23, Z+
    3ba2:	77 23       	and	r23, r23
    3ba4:	e1 f7       	brne	.-8      	; 0x3b9e <strrev+0x4>
    3ba6:	32 97       	sbiw	r30, 0x02	; 2
    3ba8:	04 c0       	rjmp	.+8      	; 0x3bb2 <strrev+0x18>
    3baa:	7c 91       	ld	r23, X
    3bac:	6d 93       	st	X+, r22
    3bae:	70 83       	st	Z, r23
    3bb0:	62 91       	ld	r22, -Z
    3bb2:	ae 17       	cp	r26, r30
    3bb4:	bf 07       	cpc	r27, r31
    3bb6:	c8 f3       	brcs	.-14     	; 0x3baa <strrev+0x10>
    3bb8:	08 95       	ret

00003bba <_exit>:
    3bba:	f8 94       	cli

00003bbc <__stop_program>:
    3bbc:	ff cf       	rjmp	.-2      	; 0x3bbc <__stop_program>
